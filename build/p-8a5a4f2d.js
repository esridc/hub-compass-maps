import{jv as t,aY as r,bt as e,iv as n,jw as o}from"./p-3013819f.js";import{O as s}from"./p-9b885976.js";import{e as l}from"./p-897991e6.js";import{t as a,n as i}from"./p-325c6878.js";import{a as f,b as c,d as u}from"./p-f25dc33e.js";import{I as p,w as b,c as m,l as d}from"./p-94b36fbe.js";import{O as w}from"./p-004ef643.js";import"./p-3b51db5e.js";import"./p-10315be7.js";import"./p-c99b552a.js";import"./p-5f148c96.js";import"./p-71ed4ac4.js";import"./p-1f7d3618.js";function h(t,r,e,n){const{rendererJSON:o,isRGBRenderer:s}=t;let l=null,a=null;if(r&&s)l=r;else if(r&&"pointCloudUniqueValueRenderer"===o?.type){a=f.fromJSON(o);const t=a.colorUniqueValueInfos;l=new Uint8Array(3*n);const e=C(a.fieldTransformType);for(let o=0;o<n;o++){const n=(e?e(r[o]):r[o])+"";for(let r=0;r<t.length;r++)if(t[r].values.includes(n)){l[3*o]=t[r].color.r,l[3*o+1]=t[r].color.g,l[3*o+2]=t[r].color.b;break}}}else if(r&&"pointCloudStretchRenderer"===o?.type){a=c.fromJSON(o);const t=a.stops;l=new Uint8Array(3*n);const e=C(a.fieldTransformType);for(let o=0;o<n;o++){const n=e?e(r[o]):r[o],s=t.length-1;if(n<t[0].value)l[3*o]=t[0].color.r,l[3*o+1]=t[0].color.g,l[3*o+2]=t[0].color.b;else if(n>=t[s].value)l[3*o]=t[s].color.r,l[3*o+1]=t[s].color.g,l[3*o+2]=t[s].color.b;else for(let r=1;r<t.length;r++)if(n<t[r].value){const e=(n-t[r-1].value)/(t[r].value-t[r-1].value);l[3*o]=t[r].color.r*e+t[r-1].color.r*(1-e),l[3*o+1]=t[r].color.g*e+t[r-1].color.g*(1-e),l[3*o+2]=t[r].color.b*e+t[r-1].color.b*(1-e);break}}}else if(r&&"pointCloudClassBreaksRenderer"===o?.type){a=u.fromJSON(o);const t=a.colorClassBreakInfos;l=new Uint8Array(3*n);const e=C(a.fieldTransformType);for(let o=0;o<n;o++){const n=e?e(r[o]):r[o];for(let r=0;r<t.length;r++)if(n>=t[r].minValue&&n<=t[r].maxValue){l[3*o]=t[r].color.r,l[3*o+1]=t[r].color.g,l[3*o+2]=t[r].color.b;break}}}else l=new Uint8Array(3*n).fill(255);if(e&&a?.colorModulation){const t=a.colorModulation.minValue,r=a.colorModulation.maxValue,o=.3;for(let s=0;s<n;s++){const n=e[s],a=n>=r?1:n<=t?o:o+(1-o)*(n-t)/(r-t);l[3*s]=a*l[3*s],l[3*s+1]=a*l[3*s+1],l[3*s+2]=a*l[3*s+2]}}return l}function j(t,r){if(null==t.encoding||""===t.encoding){const e=b(r,t);if(null==e.vertexAttributes.position)return;const n=d(r,e.vertexAttributes.position),o=e.header.fields,s=[o.offsetX,o.offsetY,o.offsetZ],l=[o.scaleX,o.scaleY,o.scaleZ],a=n.length/3,i=new Float64Array(3*a);for(let t=0;t<a;t++)i[3*t]=n[3*t]*l[0]+s[0],i[3*t+1]=n[3*t+1]*l[1]+s[1],i[3*t+2]=n[3*t+2]*l[2]+s[2];return i}if("lepcc-xyz"===t.encoding)return m(r).result}function y(t,r,e){return t?.attributeInfo.useElevation?r?A(r,e):null:t?.attributeInfo.storageInfo?p(t.attributeInfo.storageInfo,t.buffer,e):null}function A(t,r){const e=new Float64Array(r);for(let n=0;n<r;n++)e[n]=t[3*n+2];return e}function M(t,r,e,n,o){const s=t.length/3;let l=0;for(let a=0;a<s;a++){let s=!0;for(let t=0;t<n.length&&s;t++){const{filterJSON:r}=n[t],e=o[t].values[a];switch(r.type){case"pointCloudValueFilter":{const t="exclude"===r.mode;r.values.includes(e)===t&&(s=!1);break}case"pointCloudBitfieldFilter":{const t=k(r.requiredSetBits),n=k(r.requiredClearBits);(e&t)===t&&0==(e&n)||(s=!1);break}case"pointCloudReturnFilter":{const t=15&e,n=e>>>4&15,o=n>1,l=1===t,a=t===n;let i=!1;for(const t of r.includedReturns)if("last"===t&&a||"firstOfMany"===t&&l&&o||"lastOfMany"===t&&a&&o||"single"===t&&!o){i=!0;break}i||(s=!1);break}}}s&&(e[l]=a,t[3*l]=t[3*a],t[3*l+1]=t[3*a+1],t[3*l+2]=t[3*a+2],r[3*l]=r[3*a],r[3*l+1]=r[3*a+1],r[3*l+2]=r[3*a+2],l++)}return l}function C(t){switch(t){default:case null:case"none":return t=>t;case"low-four-bit":return t=>15&t;case"high-four-bit":return t=>(240&t)>>4;case"absolute-value":return t=>Math.abs(t);case"modulo-ten":return t=>t%10}}function k(t){let r=0;for(const e of t||[])r|=1<<e;return r}class v{transform(r){const e=this._transform(r),n=[e.points.buffer,e.rgb.buffer];null!=e.pointIdFilterMap&&n.push(e.pointIdFilterMap.buffer);for(const r of e.attributes)"buffer"in r.values&&t(r.values.buffer)&&r.values.buffer!==e.rgb.buffer&&n.push(r.values.buffer);return Promise.resolve({result:e,transferList:n})}_transform(t){const n=j(t.schema,t.geometryBuffer);let o=n.length/3,s=null;const l=new Array,a=y(t.primaryAttributeData,n,o);null!=t.primaryAttributeData&&a&&l.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:a});const i=y(t.modulationAttributeData,n,o);null!=t.modulationAttributeData&&i&&l.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:i});let f=h(t.rendererInfo,a,i,o);if(t.filterInfo&&t.filterInfo.length>0&&null!=t.filterAttributesData){const e=t.filterAttributesData.filter(r).map((t=>{const r=y(t,n,o),e={attributeInfo:t.attributeInfo,values:r};return l.push(e),e}));s=new Uint32Array(o),o=M(n,f,s,t.filterInfo,e)}for(const r of t.userAttributesData){const t=y(r,n,o);l.push({attributeInfo:r.attributeInfo,values:t})}3*o<f.length&&(f=new Uint8Array(f.buffer.slice(0,3*o))),this._applyElevationOffsetInPlace(n,o,t.elevationOffset);const c=this._transformCoordinates(n,o,w.fromData(t.obbData),e.fromJSON(t.inSR),e.fromJSON(t.outSR));return{obbData:t.obbData,points:c,rgb:f,attributes:l,pointIdFilterMap:s}}_transformCoordinates(t,r,e,l,f){if(!n(t,l,0,t,f,0,r))throw new Error("Can't reproject");const c=a(e.center),u=i(),p=i(),b=a(e.halfSize);s(F,e.quaternion);const m=new Float32Array(3*r);for(let e=0;e<r;e++){let r=3*e;u[0]=t[r]-c[0],u[1]=t[r+1]-c[1],u[2]=t[r+2]-c[2],o(p,u,F),b[0]=Math.max(b[0],Math.abs(p[0])),b[1]=Math.max(b[1],Math.abs(p[1])),b[2]=Math.max(b[2],Math.abs(p[2])),m[r++]=u[0],m[r++]=u[1],m[r]=u[2]}return e.halfSize=b,m}_applyElevationOffsetInPlace(t,r,e){if(0!==e)for(let n=0;n<r;n++)t[3*n+2]+=e}}const F=l();function I(){return new v}export default I;
//# sourceMappingURL=p-8a5a4f2d.js.map