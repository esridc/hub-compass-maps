import{ch as t,d8 as s,c4 as i,da as e,U as n,d_ as h,k7 as r,jo as o,d9 as a,P as c,eX as l,di as u,hr as f,kz as y,kA as d,b4 as p,eH as w,eF as m,cn as g,c6 as b,kB as M,gK as A,dz as v,dy as S,dx as _,dq as T,kC as I,dQ as x,dC as D,du as k,dr as P,d2 as j,jN as U,e as R,hP as L,iX as C,gH as O,kD as F,dN as q,j as z,n as V,iY as B,iZ as K,a7 as N,a0 as $,r as H,p as X,q as W}from"./p-aad64c9f.js";import{I as Y,E as G}from"./p-d26004a3.js";import{t as Q}from"./p-e7a66915.js";import{n as E}from"./p-21ce5524.js";import{l as J}from"./p-aefd4328.js";import{w as Z,d as tt}from"./p-b8a25c33.js";import{E as st}from"./p-2ea4a2b9.js";import{o as it}from"./p-44881b12.js";import{e as et,t as nt,c as ht}from"./p-9ad0e060.js";import{r as rt}from"./p-682c165c.js";import{n as ot,r as at,l as ct,i as lt,a as ut}from"./p-204b6b8c.js";import{i as ft}from"./p-d6556377.js";import{h as yt}from"./p-5ae33da2.js";import{e as dt,s as pt}from"./p-c9522bc9.js";import{L as wt,l as mt}from"./p-773a2311.js";import{j as gt,y as bt}from"./p-bbb18646.js";import{i as Mt}from"./p-3e7cecc4.js";import"./p-2af77f97.js";import"./p-de84037a.js";import"./p-deddb82e.js";import"./p-22458323.js";import"./p-1c4b55c0.js";import"./p-7ce0ff48.js";import"./p-a0004a96.js";import"./p-e7002be3.js";import"./p-717596a8.js";import"./p-3f2fef32.js";import"./p-c0b174ee.js";import"./p-875cbb57.js";import"./p-da522976.js";import"./p-aff89b86.js";import"./p-d492d39b.js";class At{constructor(t,s){this._width=0,this._height=0,this._free=[],this._width=t,this._height=s,this._free.push(new Q(0,0,t,s))}get width(){return this._width}get height(){return this._height}allocate(t,s){if(t>this._width||s>this._height)return new Q;let i=null,e=-1;for(let n=0;n<this._free.length;++n){const h=this._free[n];t<=h.width&&s<=h.height&&(null===i||h.y<=i.y&&h.x<=i.x)&&(i=h,e=n)}return null===i?new Q:(this._free.splice(e,1),i.width<i.height?(i.width>t&&this._free.push(new Q(i.x+t,i.y,i.width-t,s)),i.height>s&&this._free.push(new Q(i.x,i.y+s,i.width,i.height-s))):(i.width>t&&this._free.push(new Q(i.x+t,i.y,i.width-t,i.height)),i.height>s&&this._free.push(new Q(i.x,i.y+s,t,i.height-s))),new Q(i.x,i.y,t,s))}release(t){for(let s=0;s<this._free.length;++s){const i=this._free[s];if(i.y===t.y&&i.height===t.height&&i.x+i.width===t.x)i.width+=t.width;else if(i.x===t.x&&i.width===t.width&&i.y+i.height===t.y)i.height+=t.height;else if(t.y===i.y&&t.height===i.height&&t.x+t.width===i.x)i.x=t.x,i.width+=t.width;else{if(t.x!==i.x||t.width!==i.width||t.y+t.height!==i.y)continue;i.y=t.y,i.height+=t.height}this._free.splice(s,1),this.release(t)}this._free.push(t)}}class vt{constructor(t,s,i){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=t,this.height=s,this._glyphSource=i,this._binPack=new At(t-4,s-4),this._glyphData.push(new Uint8Array(t*s)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(t,s){const i=[],e=this._glyphSource,n=new Set,h=1/256;for(const t of s){const s=Math.floor(t*h);n.add(s)}const r=[];return n.forEach((s=>{const i=t+s;if(this._rangePromises.has(i))r.push(this._rangePromises.get(i));else{const n=e.getRange(t,s).then((()=>{this._rangePromises.delete(i)}),(()=>{this._rangePromises.delete(i)}));this._rangePromises.set(i,n),r.push(n)}})),Promise.all(r).then((()=>{let n=this._glyphIndex[t];n||(n={},this._glyphIndex[t]=n);for(const h of s){const s=n[h];if(s){i[h]={sdf:!0,rect:s.rect,metrics:s.metrics,page:s.page,code:h};continue}const r=e.getGlyph(t,h);if(!r?.metrics)continue;const o=r.metrics;let a;if(0===o.width)a=new Q(0,0,0,0);else{const t=3,s=o.width+2*t,i=o.height+2*t;let e=s%4?4-s%4:4,n=i%4?4-i%4:4;1===e&&(e=5),1===n&&(n=5),a=this._binPack.allocate(s+e,i+n),a.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new At(this.width-4,this.height-4),a=this._binPack.allocate(s+e,i+n));const h=this._glyphData[this._currentPage],c=r.bitmap;let l,u;if(c)for(let t=0;t<i;t++){l=s*t,u=this.width*(a.y+t+1)+a.x;for(let t=0;t<s;t++)h[u+t+1]=c.at(l+t)}}n[h]={rect:a,metrics:o,tileIDs:null,page:this._currentPage},i[h]={sdf:!0,rect:a,metrics:o,page:this._currentPage,code:h},this._dirties[this._currentPage]=!0}return i}))}removeGlyphs(t){for(const s in this._glyphIndex){const i=this._glyphIndex[s];if(!i)continue;let e;for(const s in i)if(e=i[s],e.tileIDs.delete(t),0===e.tileIDs.size){const t=this._glyphData[e.page],n=e.rect;let h,r;for(let s=0;s<n.height;s++)for(h=this.width*(n.y+s)+n.x,r=0;r<n.width;r++)t[h+r]=0;delete i[s],this._dirties[e.page]=!0}}}bind(n,h,r,o=0){if(!this._textures[r]){const h=new e;h.pixelFormat=t.ALPHA,h.wrapMode=s.CLAMP_TO_EDGE,h.width=this.width,h.height=this.height,this._textures[r]=new i(n,h,new Uint8Array(this.width*this.height))}const a=this._textures[r];a.setSamplingMode(h),this._dirties[r]&&a.setData(this._glyphData[r]),n.bindTexture(a,o),this._dirties[r]=!1}destroy(){this.dispose()}dispose(){this._glyphData.length=0,this._binPack=null;for(const t of this._textures)t&&t.dispose();this._textures.length=0}}class St{constructor(t){if(this._metrics=[],!t)return void(this._allBitmaps=null);const s=new Map;let i=0;for(;t.next();)switch(t.tag()){case 1:{const e=t.getMessage();for(;e.next();)switch(e.tag()){case 3:{const t=e.getMessage();let n,h,r,o,a,c,l;for(;t.next();)switch(t.tag()){case 1:n=t.getUInt32();break;case 2:h=t.getBytes();break;case 3:r=t.getUInt32();break;case 4:o=t.getUInt32();break;case 5:a=t.getSInt32();break;case 6:c=t.getSInt32();break;case 7:l=t.getUInt32();break;default:t.skip()}if(t.release(),n){const t=h?.length??0;this._metrics[n]={width:r,height:o,left:a,top:c,advance:l,startOffset:i,length:t},s.set(n,h),i+=t}break}default:e.skip()}e.release();break}default:t.skip()}const e=new Uint8Array(i),n=this._metrics;for(const[t,i]of s){const{startOffset:s,length:h}=n[t];if(i)for(let t=0;t<h;++t)e[s+t]=i[t]}this._allBitmaps=e}getMetrics(t){return this._metrics[t]}getBitmap(t){if(!this._allBitmaps)return;const s=this._metrics[t];if(void 0===s)return;const{startOffset:i,length:e}=s;return 0!==e?new It(this._allBitmaps,i,e):void 0}}class _t{constructor(){this._ranges=[]}get ranges(){return this._ranges}getRange(t){return this._ranges[t]}addRange(t,s){this._ranges[t]=s}}class Tt{constructor(t){this._glyphInfo={},this._baseURL=t}getRange(t,s){const i=this._getFontStack(t);if(i.getRange(s))return Promise.resolve();const e=256*s,h=e+255;if(this._baseURL){const r=this._baseURL.replace("{fontstack}",t).replace("{range}",e+"-"+h);return n(r,{responseType:"array-buffer"}).then((t=>{i.addRange(s,new St(new E(new Uint8Array(t.data),new DataView(t.data))))})).catch((()=>{i.addRange(s,new St)}))}return i.addRange(s,new St),Promise.resolve()}getGlyph(t,s){const i=this._getFontStack(t);if(!i)return;const e=Math.floor(s/256),n=i.getRange(e);return n?{metrics:n.getMetrics(s),bitmap:n.getBitmap(s)}:void 0}_getFontStack(t){let s=this._glyphInfo[t];return s||(s=this._glyphInfo[t]=new _t),s}}class It{constructor(t,s,i){this._array=t,this._start=s,this.length=i}at(t){return 0<=t&&t<this.length?this._array[this._start+t]:void 0}}const xt="dasharray-";class Dt{constructor(t,s,i=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,s<=0&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=t,this._pageHeight=s,i>0&&(this._maxItemSize=i),this._binPack=new At(t-4,s-4)}destroy(){this.dispose()}dispose(){this._binPack=null,this._mosaicsData.length=0,this._mosaicRects={};for(const t of this._textures)t&&t.dispose();this._textures.length=0}getWidth(t){return t>=this._size.length?-1:this._size[t][0]}getHeight(t){return t>=this._size.length?-1:this._size[t][1]}getPageSize(t){return t>=this._size.length?null:this._size[t]}setSpriteSource(t){if(this.dispose(),this.pixelRatio=t.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new At(this._pageWidth-4,this._pageHeight-4);const t=Math.floor(this._pageWidth),s=Math.floor(this._pageHeight),i=new Uint32Array(t*s);this._mosaicsData[0]=i,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=t}getSpriteItem(t,s=!1){let i,e,n=this._mosaicRects[t];if(n)return n;if(!this._sprites||"loaded"!==this._sprites.loadStatus)return null;if(t&&t.startsWith(xt)?([i,e]=this._rasterizeDash(t),s=!0):i=this._sprites.getSpriteInfo(t),!i?.width||!i.height||i.width<0||i.height<0)return null;const h=i.width,r=i.height,[o,a,c]=this._allocateImage(h,r);return o.width<=0?null:(this._copy(o,i,a,c,s,e),n={type:"sprite",rect:o,width:h,height:r,sdf:i.sdf,simplePattern:!1,rasterizationScale:i.pixelRatio,page:a},this._mosaicRects[t]=n,n)}getSpriteItems(t){const s={};for(const i of t)s[i.name]=this.getSpriteItem(i.name,i.repeat);return s}getMosaicItemPosition(t,s){const i=this.getSpriteItem(t,s),e=i?.rect;if(!e)return null;e.width=i.width,e.height=i.height;const n=i.width,h=i.height,r=2;return{tl:[e.x+r,e.y+r],br:[e.x+r+n,e.y+r+h],page:i.page}}bind(t,n,h=0,r=0){if(h>=this._size.length||h>=this._mosaicsData.length)return;if(!this._textures[h]){const n=new e;n.wrapMode=s.CLAMP_TO_EDGE,n.width=this._size[h][0],n.height=this._size[h][1],this._textures[h]=new i(t,n,new Uint8Array(this._mosaicsData[h].buffer))}const o=this._textures[h];o.setSamplingMode(n),this._dirties[h]&&o.setData(new Uint8Array(this._mosaicsData[h].buffer)),t.bindTexture(o,r),this._dirties[h]=!1}static _copyBits(t,s,i,e,n,h,r,o,a,c,l){let u=e*s+i,f=o*h+r;if(l){f-=h;for(let r=-1;r<=c;r++,u=((r+c)%c+e)*s+i,f+=h)for(let s=-1;s<=a;s++)n[f+s]=t[u+(s+a)%a]}else for(let i=0;i<c;i++){for(let s=0;s<a;s++)n[f+s]=t[u+s];u+=s,f+=h}}_copy(t,s,i,e,n,h){if(!this._sprites||"loaded"!==this._sprites.loadStatus||i>=this._mosaicsData.length)return;const r=new Uint32Array(h?h.buffer:this._sprites.image.buffer),o=this._mosaicsData[i],a=2,c=h?s.width:this._sprites.width;Dt._copyBits(r,c,s.x,s.y,o,e[0],t.x+a,t.y+a,s.width,s.height,n),this._dirties[i]=!0}_allocateImage(t,s){t+=2,s+=2;const i=Math.max(t,s);if(this._maxItemSize&&this._maxItemSize<i){const i=new Q(0,0,t,s);return this._mosaicsData.push(new Uint32Array(t*s)),this._dirties.push(!0),this._size.push([t,s]),this._textures.push(void 0),[i,this._mosaicsData.length-1,[t,s]]}let e=t%4?4-t%4:4,n=s%4?4-s%4:4;1===e&&(e=5),1===n&&(n=5);const h=this._binPack.allocate(t+e,s+n);return h.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new At(this._pageWidth-4,this._pageHeight-4),this._allocateImage(t,s)):[h,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(t){const s=/\[(.*?)\]/,i=t.match(s);if(!i)return null;const e=i[1].split(",").map(Number),n=t.slice(t.lastIndexOf("-")+1),[h,r,o]=J(e,n);return[{x:0,y:0,width:r,height:o,sdf:!0,pixelRatio:1},new Uint8Array(h.buffer)]}}class kt{constructor(t,s,i,e){this._layer=t,this._styleRepository=s,this.devicePixelRatio=i,this._sourceDataMaxLOD=e,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){this._connection?.close(),this._connection=null,this._styleRepository=null,this._layer=null,this._spriteMosaic?.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=h(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then((()=>this._spriteMosaic))}get glyphMosaic(){return this._glyphMosaic}async start(t){this._requestSprite(t);const s=this._layer.currentStyleInfo.glyphsUrl,i=new Tt(s?r(s,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new vt(1024,1024,i),this._broadcastPromise=o("WorkerTileHandler",{client:this,schedule:t.schedule,signal:t.signal}).then((s=>{if(this._layer&&(this._connection?.close(),this._connection=s,this._layer&&!this._connection.closed)){const i=s.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,sourceDataMaxLOD:this._sourceDataMaxLOD},t);Promise.all(i).catch((t=>a(t)))}}))}_requestSprite(t){this._spriteSourceAbortController?.abort();const s=new AbortController;this._spriteSourceAbortController=s;const i=t?.signal;this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,i&&(this._inputSignalEventListener=Pt(s),i.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:e}=s,n={...t,signal:e};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,n),this._spriteSourcePromise.then((t=>{c(e),this._spriteMosaic=new Dt(1024,1024,250),this._spriteMosaic.setSpriteSource(t)}))}async updateStyle(t){const s=[];for(const i of t)i.type===Y.SPRITES_CHANGED?s.push({type:Y.SPRITES_CHANGED,data:{spriteSource:null}}):s.push(i);return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",s)),this._broadcastPromise}setSpriteSource(t){const s=new Dt(1024,1024,250);return s.setSpriteSource(t),this._spriteMosaic=s,this._spriteSourcePromise=Promise.resolve(t),this._spriteSourceAbortController=null,s}async setStyle(t,s,i){await this._broadcastPromise,this._styleRepository=t,this._sourceDataMaxLOD=i,this._requestSprite();const e=new Tt(this._layer.currentStyleInfo.glyphsUrl?r(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new vt(1024,1024,e),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:s,sourceDataMaxLOD:this._sourceDataMaxLOD})),this._broadcastPromise}async fetchTileData(t,s){const i=await this._getRefKeys(t,s);return this._getSourcesData(Object.keys(this._layer.sourceNameToSource),i,s)}async fetchTilePBFs(t){const s=Object.keys(this._layer.sourceNameToSource),i={},e=await this._getRefKeys(t,i),n=[],h=[];for(let t=0;t<e.length;t++)if(null==e[t].value||null==s[t])h.push(null);else{const r=e[t].value,o=this._getTilePayload(r,s[t],i);o.then((t=>{n.push({...t,key:r})})),h.push(o)}return Promise.all(h).then((()=>n))}async parseTileData(t,s){const i=t&&t.data;if(!i)return null;const{sourceName2DataAndRefKey:e,transferList:n}=i;return 0===Object.keys(e).length?null:this._broadcastPromise.then((()=>this._connection.invoke("createTileAndParse",{key:t.key.id,sourceName2DataAndRefKey:e,styleLayerUIDs:t.styleLayerUIDs},{...s,transferList:n})))}async getSprites(t){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(t)}getGlyphs(t){return this._glyphMosaic.getGlyphItems(t.font,t.codePoints)}async _getTilePayload(t,s,i){const e=l.pool.acquire(t.id),n=this._layer.sourceNameToSource[s],{level:h,row:r,col:o}=e;l.pool.release(e);try{return{protobuff:await n.requestTile(h,r,o,i),sourceName:s}}catch(t){if(u(t))throw t;return{protobuff:null,sourceName:s}}}async _getRefKeys(t,s){const i=this._layer.sourceNameToSource,e=new Array;for(const n in i){const h=i[n].getRefKey(t,s);e.push(h)}return f(e)}_getSourcesData(t,s,i){const e=[];for(let n=0;n<s.length;n++)if(null==s[n].value||null==t[n])e.push(null);else{const h=s[n].value,r=this._getTilePayload(h,t[n],i);e.push(r)}return f(e).then((t=>{const i={},e=[];for(let n=0;n<t.length;n++){const h=t[n].value;if(h&&(h.protobuff&&h.protobuff.byteLength>0)){const t=s[n].value.id;i[h.sourceName]={refKey:t,protobuff:h.protobuff},e.push(h.protobuff)}}return{sourceName2DataAndRefKey:i,transferList:e}}))}}function Pt(t){return()=>t.abort()}const jt=512,Ut=1e-6,Rt=(t,s)=>t+1/(1<<2*s);class Lt{constructor(t,s){this._tiles=new Map,this._tileCache=new y(40,(t=>t.dispose())),this._viewSize=[0,0],this._visibleTiles=new Map,this.acquireTile=t.acquireTile,this.releaseTile=t.releaseTile,this.tileInfoView=t.tileInfoView,this._container=s}destroy(){for(const t of this._tiles.values())t.dispose();this._tiles=null,this._tileCache.clear(),this._tileCache=null}update(t){this._updateCacheSize(t);const s=this.tileInfoView,i=s.getTileCoverage(t.state,0,!0,"smallest");if(!i)return!0;const{spans:e,lodInfo:n}=i,{level:h}=n,r=this._tiles,o=new Set,a=new Set;for(const{row:t,colFrom:s,colTo:i}of e)for(let e=s;e<=i;e++){const s=l.getId(h,t,n.normalizeCol(e),n.getWorldForColumn(e)),i=this._getOrAcquireTile(s);o.add(s),i.processed()?this._addToContainer(i):a.add(new l(s))}for(const[t,s]of r)s.isCoverage=o.has(t);for(const t of a)this._findPlaceholdersForMissingTiles(t,o);let c=!1;for(const[t,e]of r)e.neededForCoverage=o.has(t),e.neededForCoverage||e.isHoldingForFade&&s.intersects(i,e.key)&&o.add(t),e.isFading&&(c=!0);for(const t of this._tiles.keys())o.has(t)||this._releaseTile(t);return d.pool.release(i),!c}clear(){this._tiles.clear(),this._tileCache.clear(),this._visibleTiles.clear()}clearCache(){this._tileCache.clear()}getIntersectingTiles(t,s,i,e,n){const h=[0,0],r=[0,0];e.toMap(h,t-i,s+i),e.toMap(r,t+i,s-i);const o=Math.min(h[0],r[0]),a=Math.min(h[1],r[1]),c=Math.max(h[0],r[0]),l=Math.max(h[1],r[1]),u=p(o,a,c,l),f=m(),y=[];for(const t of this._visibleTiles.values())this.tileInfoView.getTileBounds(f,t.key),w(u,f)&&y.push(t);if(null!=n&&n.length>0){const t=new Set(y.map((t=>t.id))),s=n.filter((s=>!t.has(s.tileKey.id))).map((t=>this._visibleTiles.get(t.tileKey.id))).filter((t=>void 0!==t));y.push(...s)}return y}_findPlaceholdersForMissingTiles(t,s){const i=[];for(const e of this._tiles.values())this._addPlaceholderChild(i,e,t,s);const e=i.reduce(Rt,0);Math.abs(1-e)<Ut||this._addPlaceholderParent(t.id,s)}_addPlaceholderChild(t,s,i,e){s.key.level<=i.level||!s.hasData()||Ot(i,s.key)&&(this._addToContainer(s),e.add(s.id),t.push(s.key.level-i.level))}_addPlaceholderParent(t,s){const i=this._tiles;let e=t;for(;;){if(e=Ct(e),!e||s.has(e))return;const t=i.get(e);if(t?.hasData())return this._addToContainer(t),void s.add(t.id)}}_getOrAcquireTile(t){let s=this._tiles.get(t);return s||(s=this._tileCache.pop(t),s||(s=this.acquireTile(new l(t))),this._tiles.set(t,s),s)}_releaseTile(t){const s=this._tiles.get(t);this.releaseTile(s),this._removeFromContainer(s),this._tiles.delete(t),s.hasData()?this._tileCache.put(t,s,1):s.dispose()}_addToContainer(t){let s;const i=[],e=this._container;if(e.contains(t))return;const n=this._visibleTiles;for(const e of n.values())this._canConnectDirectly(t,e)&&i.push(e),null==s&&this._canConnectDirectly(e,t)&&(s=e);if(null!=s){for(const e of i)s.childrenTiles.delete(e),t.childrenTiles.add(e),e.parentTile=t;s.childrenTiles.add(t),t.parentTile=s}else for(const s of i)t.childrenTiles.add(s),s.parentTile=t;n.set(t.id,t),e.addChild(t)}_removeFromContainer(t){if(this._visibleTiles.delete(t.id),this._container.removeChild(t),null!=t.parentTile){t.parentTile.childrenTiles.delete(t);for(const s of t.childrenTiles)null!=t.parentTile&&t.parentTile.childrenTiles.add(s)}for(const s of t.childrenTiles)s.parentTile=t.parentTile;t.parentTile=null,t.childrenTiles.clear()}_canConnectDirectly(t,s){const i=t.key;let{level:e,row:n,col:h,world:r}=s.key;const o=this._visibleTiles;for(;e>0;){if(e--,n>>=1,h>>=1,i.level===e&&i.row===n&&i.col===h&&i.world===r)return!0;if(o.has(`${e}/${n}/${h}/${r}`))return!1}return!1}_updateCacheSize(t){const s=t.state.size;if(s[0]===this._viewSize[0]&&s[1]===this._viewSize[1])return;const i=Math.ceil(s[0]/jt)+1,e=Math.ceil(s[1]/jt)+1;this._viewSize[0]=s[0],this._viewSize[1]=s[1],this._tileCache.maxSize=5*i*e}}function Ct(t){const[s,i,e,n]=t.split("/"),h=parseInt(s,10);return 0===h?null:`${h-1}/${parseInt(i,10)>>1}/${parseInt(e,10)>>1}/${parseInt(n,10)}`}function Ot(t,s){const i=s.level-t.level;return t.row===s.row>>i&&t.col===s.col>>i&&t.world===s.world}class Ft{constructor(t,s){this.sourceTile=s,this.xTile=0,this.yTile=0,this.hash=0,this.priority=1,this.featureIndex=0,this.colliders=[],this.textVertexRanges=[],this.iconVertexRanges=[],this.tile=t}}class qt{constructor(){this.tileSymbols=[],this.parts=[{startTime:0,startOpacity:0,targetOpacity:0,show:!1},{startTime:0,startOpacity:0,targetOpacity:0,show:!1}],this.show=!1}}function zt(t,s,i,e,n,h){const r=i-n;if(r>=0)return(s>>r)+(e-(h<<r))*(t>>r);const o=-r;return s-(h-(e<<o))*(t>>o)<<o}class Vt{constructor(t,s,i){this._rows=Math.ceil(s/i),this._columns=Math.ceil(t/i),this._cellSize=i,this.cells=new Array(this._rows);for(let t=0;t<this._rows;t++){this.cells[t]=new Array(this._columns);for(let s=0;s<this._columns;s++)this.cells[t][s]=[]}}getCell(t,s){const i=Math.min(Math.max(Math.floor(s/this._cellSize),0),this._rows-1),e=Math.min(Math.max(Math.floor(t/this._cellSize),0),this._columns-1);return this.cells[i]&&this.cells[i][e]||null}getCellSpan(t,s,i,e){return[Math.min(Math.max(Math.floor(t/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(s/this._cellSize),0),this.rows-1),Math.min(Math.max(Math.floor(i/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(e/this._cellSize),0),this.rows-1)]}get cellSize(){return this._cellSize}get columns(){return this._columns}get rows(){return this._rows}}function Bt(t,s,i,e,n,h,r){const o=s[e++];for(let a=0;a<o;a++){const o=new Ft(h,r);o.xTile=s[e++],o.yTile=s[e++],o.hash=s[e++],o.priority=s[e++],o.featureIndex=s[e++];const a=s[e++];for(let t=0;t<a;t++){const t=s[e++],n=s[e++],h=s[e++],r=s[e++],a=!!s[e++],c=s[e++],l=i[e++],u=i[e++],f=s[e++],y=s[e++];o.colliders.push({xTile:t,yTile:n,dxPixels:h,dyPixels:r,hard:a,partIndex:c,width:f,height:y,minLod:l,maxLod:u})}const c=t[e++];for(let s=0;s<c;s++)o.textVertexRanges.push([t[e++],t[e++]]);const l=t[e++];for(let s=0;s<l;s++)o.iconVertexRanges.push([t[e++],t[e++]]);n.push(o)}return e}function Kt(t,s,i){for(const[e,n]of t.symbols)Nt(t,s,i,n,e)}function Nt(t,s,i,e,n){const h=t.layerData.get(n);if(h.type===G.SYMBOL){for(const s of e){const e=s.unique;let n;if(s.selectedForRendering){const s=e.parts[0],h=s.startOpacity,r=s.targetOpacity;t.allSymbolsFadingOut=t.allSymbolsFadingOut&&0===r;const o=i?Math.floor(127*h)|r<<7:r?255:0;n=o<<24|o<<16|o<<8|o}else n=0;for(const[t,i]of s.iconVertexRanges)for(let s=t;s<t+i;s+=4)h.iconOpacity[s/4]=n;if(s.selectedForRendering){const s=e.parts[1],h=s.startOpacity,r=s.targetOpacity;t.allSymbolsFadingOut=t.allSymbolsFadingOut&&0===r;const o=i?Math.floor(127*h)|r<<7:r?255:0;n=o<<24|o<<16|o<<8|o}else n=0;for(const[t,i]of s.textVertexRanges)for(let s=t;s<t+i;s+=4)h.textOpacity[s/4]=n}h.lastOpacityUpdate=s,h.opacityChanged=!0}}function $t(t,s,i,e){const n=t.colliders;let h,r,o,a;for(const c of n){if(t.unique.show&&t.unique.parts[c.partIndex].show&&(h=c.xScreen-e[0]+c.dxScreen,r=c.yScreen-e[1]+c.dyScreen,o=h+c.width,a=r+c.height,Z(i,s.x,s.y,h,r,o,a)))return!0}return!1}class Ht{constructor(t,s){this.layerUIDs=[],this.isDestroyed=!1,this._data=t;let i=1;const e=new Uint32Array(t);this.layerUIDs=[];const n=e[i++];for(let t=0;t<n;t++)this.layerUIDs[t]=e[i++];this.bufferDataOffset=i,s&&(this.layer=s.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return null==this._data}get offset(){return this.bufferDataOffset}get data(){return this._data}destroy(){this.isDestroyed||(this.doDestroy(),this._data=null,this.isDestroyed=!0)}prepareForRendering(t){null!=this._data&&(this.doPrepareForRendering(t,this._data,this.bufferDataOffset),this._data=null)}}class Xt extends Ht{constructor(t,s){super(t,s),this.type=G.LINE,this.lineIndexStart=0,this.lineIndexCount=0;const i=new Uint32Array(t);let e=this.bufferDataOffset;this.lineIndexStart=i[e++],this.lineIndexCount=i[e++];const n=i[e++];if(n>0){this.patternMap=new Map;for(let t=0;t<n;t++){const t=i[e++],s=i[e++],n=i[e++];this.patternMap.set(t,[s,n])}}this.bufferDataOffset=e}get usedMemory(){return(this.data?.byteLength??0)+(this.vao?.usedMemory??0)}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){this.vao=g(this.vao)}doPrepareForRendering(t,s,i){const e=new Uint32Array(s),n=new Int32Array(e.buffer),h=e[i++],r=st.createVertex(t,b.STATIC_DRAW,new Int32Array(n.buffer,4*i,h));i+=h;const o=e[i++],a=st.createIndex(t,b.STATIC_DRAW,new Uint32Array(e.buffer,4*i,o));i+=o;const c=this.layer.lineMaterial;this.vao=new it(t,c.getAttributeLocations(),c.getLayoutInfo(),new Map([["geometry",r]]),a)}}class Wt extends Ht{constructor(t,s){super(t,s),this.type=G.FILL,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const i=new Uint32Array(t);let e=this.bufferDataOffset;this.fillIndexStart=i[e++],this.fillIndexCount=i[e++],this.outlineIndexStart=i[e++],this.outlineIndexCount=i[e++];const n=i[e++];if(n>0){this.patternMap=new Map;for(let t=0;t<n;t++){const t=i[e++],s=i[e++],n=i[e++];this.patternMap.set(t,[s,n])}}this.bufferDataOffset=e}get usedMemory(){return(this.data?.byteLength??0)+(this.fillVAO?.usedMemory??0)+(this.outlineVAO?.usedMemory??0)}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){this.fillVAO=g(this.fillVAO),this.outlineVAO=g(this.outlineVAO)}doPrepareForRendering(t,s,i){const e=new Uint32Array(s),n=new Int32Array(e.buffer),h=e[i++],r=st.createVertex(t,b.STATIC_DRAW,new Int32Array(n.buffer,4*i,h));i+=h;const o=e[i++],a=st.createIndex(t,b.STATIC_DRAW,new Uint32Array(e.buffer,4*i,o));i+=o;const c=e[i++],l=st.createVertex(t,b.STATIC_DRAW,new Int32Array(n.buffer,4*i,c));i+=c;const u=e[i++],f=st.createIndex(t,b.STATIC_DRAW,new Uint32Array(e.buffer,4*i,u));i+=u;const y=this.layer,d=y.fillMaterial,p=y.outlineMaterial;this.fillVAO=new it(t,d.getAttributeLocations(),d.getLayoutInfo(),new Map([["geometry",r]]),a),this.outlineVAO=new it(t,p.getAttributeLocations(),p.getLayoutInfo(),new Map([["geometry",l]]),f)}}class Yt extends Ht{constructor(t,s,i){super(t,s),this.type=G.SYMBOL,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const e=new Uint32Array(t),n=new Int32Array(t),h=new Float32Array(t);let r=this.bufferDataOffset;this.isIconSDF=!!e[r++];const o=e[r++],a=e[r++],c=e[r++],u=new l(o,a,c,0),f=e[r++];for(let t=0;t<f;t++){const t=e[r++],s=e[r++],i=e[r++];this.iconPerPageElementsMap.set(t,[s,i])}const y=e[r++];for(let t=0;t<y;t++){const t=e[r++],s=e[r++],i=e[r++];this.glyphPerPageElementsMap.set(t,[s,i])}const d=e[r++],p=e[r++];this.iconOpacity=new Int32Array(d),this.textOpacity=new Int32Array(p),r=Bt(e,n,h,r,this.symbols,i,u),this.bufferDataOffset=r}get usedMemory(){return(this.data?.byteLength??0)+(this.iconVAO?.usedMemory??0)+(this.textVAO?.usedMemory??0)+M(this.iconOpacity)+M(this.textOpacity)}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let t=0;for(const s of this.iconPerPageElementsMap.values())t+=s[1];for(const s of this.glyphPerPageElementsMap.values())t+=s[1];return t/3}doDestroy(){this.iconVAO=g(this.iconVAO),this.textVAO=g(this.textVAO)}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const t=this.iconOpacity,s=this.iconVAO.vertexBuffers.get("opacity");t.length>0&&t.byteLength===s.usedMemory&&s.setSubData(t,0,0,t.length);const i=this.textOpacity,e=this.textVAO.vertexBuffers.get("opacity");i.length>0&&i.byteLength===e.usedMemory&&e.setSubData(i,0,0,i.length)}doPrepareForRendering(t,s,i){const e=new Uint32Array(s),n=new Int32Array(e.buffer),h=e[i++],r=st.createVertex(t,b.STATIC_DRAW,new Int32Array(n.buffer,4*i,h));i+=h;const o=e[i++],a=st.createIndex(t,b.STATIC_DRAW,new Uint32Array(e.buffer,4*i,o));i+=o;const c=e[i++],l=st.createVertex(t,b.STATIC_DRAW,new Int32Array(n.buffer,4*i,c));i+=c;const u=e[i++],f=st.createIndex(t,b.STATIC_DRAW,new Uint32Array(e.buffer,4*i,u));i+=u;const y=st.createVertex(t,b.STATIC_DRAW,this.iconOpacity.buffer),d=st.createVertex(t,b.STATIC_DRAW,this.textOpacity.buffer),p=this.layer,w=p.iconMaterial,m=p.textMaterial;this.iconVAO=new it(t,w.getAttributeLocations(),w.getLayoutInfo(),new Map([["geometry",r],["opacity",y]]),a),this.textVAO=new it(t,m.getAttributeLocations(),m.getLayoutInfo(),new Map([["geometry",l],["opacity",d]]),f)}}class Gt extends Ht{constructor(t,s){super(t,s),this.type=G.CIRCLE,this.circleIndexStart=0,this.circleIndexCount=0;const i=new Uint32Array(t);let e=this.bufferDataOffset;this.circleIndexStart=i[e++],this.circleIndexCount=i[e++],this.bufferDataOffset=e}get usedMemory(){return(this.data?.byteLength??0)+(this.vao?.usedMemory??0)}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){this.vao=g(this.vao)}doPrepareForRendering(t,s,i){const e=new Uint32Array(s),n=new Int32Array(e.buffer),h=e[i++],r=st.createVertex(t,b.STATIC_DRAW,new Int32Array(n.buffer,4*i,h));i+=h;const o=e[i++],a=st.createIndex(t,b.STATIC_DRAW,new Uint32Array(e.buffer,4*i,o));i+=o;const c=this.layer.circleMaterial;this.vao=new it(t,c.getAttributeLocations(),c.getLayoutInfo(),new Map([["geometry",r]]),a)}}class Qt extends rt{constructor(t,s,i,e,n,h,r,o=null){super(t,s,i,e,n,h,4096,4096),this.styleRepository=r,this._memCache=o,this.type="vector-tile",this._referenced=1,this._hasSymbolBuckets=!1,this._usedMemory=256,this.layerData=new Map,this.status="loading",this.allSymbolsFadingOut=!1,this.lastOpacityUpdate=0,this.symbols=new Map,this.isCoverage=!1,this.neededForCoverage=!1,this.decluttered=!1,this.parentTile=null,this.childrenTiles=new Set,this.featureIndex=null,this.triangleCount=0,this._processed=!1,this.id=t.id}get hasSymbolBuckets(){return this._hasSymbolBuckets}get isFading(){return this._hasSymbolBuckets&&performance.now()-this.lastOpacityUpdate<et}get isHoldingForFade(){return this._hasSymbolBuckets&&(!this.allSymbolsFadingOut||performance.now()-this.lastOpacityUpdate<et)}get wasRequested(){return"errored"===this.status||"loaded"===this.status||"reloading"===this.status}setData(t){this.changeDataImpl(t),this.requestRender(),this.ready(),this._processed=!0}deleteLayerData(t){let s=!1;for(const i of t){const t=this.layerData.get(i);t&&(this._usedMemory-=t.usedMemory,t.type===G.SYMBOL&&this.symbols.delete(i)&&(s=!0),t.destroy(),this.layerData.delete(i))}this._memCache?.updateSize(this.key.id,this,this._usedMemory),s&&(this.featureIndex?.clear(),this.emit("symbols-changed")),this.requestRender()}processed(){return this._processed}hasData(){return this.layerData.size>0}hasFeatures(){const t=this.layerData.values();for(const s of t)if(s.hasData())return!0;return!1}dispose(){"unloaded"!==this.status&&(Qt._destroyRenderBuckets(this.layerData),this.layerData.clear(),this.featureIndex=null,this._usedMemory=0,this.destroy(),this.status="unloaded")}release(){0==--this._referenced&&(this.dispose(),this.stage=null)}retain(){++this._referenced}get usedMemory(){return this._usedMemory}get usedMemoryPerReference(){return this._usedMemory/(this._referenced||1)}changeDataImpl(t){this.featureIndex?.clear();let s=!1;if(t){const{bucketsWithData:i,emptyBuckets:e}=t,n=this._createRenderBuckets(i);if(e&&e.byteLength>0){const t=new Uint32Array(e);for(const s of t)this._deleteLayerData(s)}for(const[t,i]of n)this._deleteLayerData(t),i.type===G.SYMBOL&&(this.symbols.set(t,i.symbols),s=!0),this._usedMemory+=i.usedMemory,this.layerData.set(t,i);this._memCache?.updateSize(this.key.id,this,this.usedMemory)}this._hasSymbolBuckets=!1;for(const t of this.layerData.values())t.type===G.SYMBOL&&(this._hasSymbolBuckets=!0);s&&this.emit("symbols-changed")}attachWithContext(t){this.stage={context:t,trashDisplayObject(t){t.processDetach()},untrashDisplayObject:()=>!1}}setTransform(t){super.setTransform(t);const s=this.resolution/(t.resolution*t.pixelRatio),i=this.width/this.rangeX*s,e=this.height/this.rangeY*s,n=[0,0];t.toScreen(n,[this.x,this.y]);const h=this.transforms.tileUnitsToPixels;A(h),v(h,h,n),S(h,h,Math.PI*t.rotation/180),_(h,h,[i,e,1])}_createTransforms(){return{displayViewScreenMat3:T(),tileMat3:T(),tileUnitsToPixels:T()}}static _destroyRenderBuckets(t){if(!t)return;const s=new Set;for(const i of t.values())s.has(i)||(i.destroy(),s.add(i));t.clear()}_createRenderBuckets(t){const s=new Map,i=new Map;for(const e of t){const t=this._deserializeBucket(e,i);for(const i of t.layerUIDs)s.set(i,t)}return s}_deserializeBucket(t,s){let i=s.get(t);if(i)return i;switch(new Uint32Array(t)[0]){case G.FILL:i=new Wt(t,this.styleRepository);break;case G.LINE:i=new Xt(t,this.styleRepository);break;case G.SYMBOL:i=new Yt(t,this.styleRepository,this);break;case G.CIRCLE:i=new Gt(t,this.styleRepository)}return s.set(t,i),i}_deleteLayerData(t){if(!this.layerData.has(t))return;const s=this.layerData.get(t);this._usedMemory-=s.usedMemory,s.destroy(),this.layerData.delete(t)}}function Et(t,s,i,e,n,h){const{iconRotationAlignment:r,textRotationAlignment:o,iconTranslate:a,iconTranslateAnchor:c,textTranslate:l,textTranslateAnchor:u}=e;let f=0;for(const e of t.colliders){const[t,y]=0===e.partIndex?a:l,d=0===e.partIndex?c:u,p=e.minLod<=h&&h<=e.maxLod;f+=p?0:1,e.enabled=p,e.xScreen=e.xTile*n[0]+e.yTile*n[3]+n[6],e.yScreen=e.xTile*n[1]+e.yTile*n[4]+n[7],d===at.MAP?(e.xScreen+=i*t-s*y,e.yScreen+=s*t+i*y):(e.xScreen+=t,e.yScreen+=y),ct.VIEWPORT===(0===e.partIndex?r:o)?(e.dxScreen=e.dxPixels,e.dyScreen=e.dyPixels):(e.dxScreen=i*(e.dxPixels+e.width/2)-s*(e.dyPixels+e.height/2)-e.width/2,e.dyScreen=s*(e.dxPixels+e.width/2)+i*(e.dyPixels+e.height/2)-e.height/2)}t.colliders.length>0&&f===t.colliders.length&&(t.unique.show=!1)}class Jt{constructor(t,s,i,e,n,h){this._symbols=t,this._styleRepository=e,this._zoom=n,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new Vt(s,i,nt),this._si=Math.sin(Math.PI*h/180),this._co=Math.cos(Math.PI*h/180);for(const s of t)for(const t of s.symbols)this._allNeededMatrices.has(t.tile)||this._allNeededMatrices.set(t.tile,I(t.tile.transforms.tileUnitsToPixels))}work(t){const s=this._gridIndex;function i(t){const i=t.xScreen+t.dxScreen,e=t.yScreen+t.dyScreen,n=i+t.width,h=e+t.height,[r,o,a,c]=s.getCellSpan(i,e,n,h);for(let t=o;t<=c;t++)for(let o=r;o<=a;o++){const r=s.cells[t][o];for(const t of r){const s=t.xScreen+t.dxScreen,r=t.yScreen+t.dyScreen,o=s+t.width,a=r+t.height;if(!(n<s||i>o||h<r||e>a))return!0}}return!1}const e=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const s=this._symbols[this._currentLayerCursor],n=this._getProperties(s.styleLayerUID);for(;this._currentSymbolCursor<s.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-e>t)return!1;const h=s.symbols[this._currentSymbolCursor];if(!h.unique.show)continue;Et(h,this._si,this._co,n,this._allNeededMatrices.get(h.tile),this._zoom);const r=h.unique;if(!r.show)continue;const{iconAllowOverlap:o,iconIgnorePlacement:a,textAllowOverlap:c,textIgnorePlacement:l}=n;for(const t of h.colliders){if(!t.enabled)continue;const s=r.parts[t.partIndex];if(!s.show)continue;!(t.partIndex?c:o)&&i(t)&&(t.hard?r.show=!1:s.show=!1)}if(r.show)for(const t of h.colliders){if(!t.enabled)continue;if(t.partIndex?l:a)continue;if(!r.parts[t.partIndex].show)continue;const s=t.xScreen+t.dxScreen,i=t.yScreen+t.dyScreen,e=s+t.width,n=i+t.height,[h,o,c,u]=this._gridIndex.getCellSpan(s,i,e,n);for(let s=o;s<=u;s++)for(let i=h;i<=c;i++){this._gridIndex.cells[s][i].push(t)}}}}return!0}_getProperties(t){const s=this._styleProps.get(t);if(s)return s;const i=this._zoom,e=this._styleRepository.getStyleLayerByUID(t),n=e.getLayoutValue("symbol-placement",i)!==ot.POINT;let h=e.getLayoutValue("icon-rotation-alignment",i);h===ct.AUTO&&(h=n?ct.MAP:ct.VIEWPORT);let r=e.getLayoutValue("text-rotation-alignment",i);r===ct.AUTO&&(r=n?ct.MAP:ct.VIEWPORT);const o=e.getPaintValue("icon-translate",i),a=e.getPaintValue("icon-translate-anchor",i),c=e.getPaintValue("text-translate",i),l=e.getPaintValue("text-translate-anchor",i),u={iconAllowOverlap:e.getLayoutValue("icon-allow-overlap",i),iconIgnorePlacement:e.getLayoutValue("icon-ignore-placement",i),textAllowOverlap:e.getLayoutValue("text-allow-overlap",i),textIgnorePlacement:e.getLayoutValue("text-ignore-placement",i),iconRotationAlignment:h,textRotationAlignment:r,iconTranslateAnchor:a,iconTranslate:o,textTranslateAnchor:l,textTranslate:c};return this._styleProps.set(t,u),u}}function Zt(t,s){if(t.priority-s.priority)return t.priority-s.priority;const i=t.tile.key,e=s.tile.key;return i.world-e.world?i.world-e.world:i.level-e.level?i.level-e.level:i.row-e.row?i.row-e.row:i.col-e.col?i.col-e.col:t.xTile-s.xTile?t.xTile-s.xTile:t.yTile-s.yTile}class ts{get running(){return this._running}constructor(t,s,i,e,n,h){this._visibleTiles=t,this._symbolRepository=s,this._createCollisionJob=i,this._assignTileSymbolsOpacity=e,this._symbolLayerSorter=n,this._isLayerVisible=h,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}setScreenSize(t,s){this._screenWidth===t&&this._screenHeight===s||this.restart(),this._screenWidth=t,this._screenHeight=s}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(t){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const s=performance.now();if(!this._selectionJob.work(t))return!1;if(this._selectionJobCompleted=!0,0===(t=Math.max(0,t-(performance.now()-s))))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const s=performance.now();if(!this._collisionJob.work(t))return!1;if(this._collisionJobCompleted=!0,0===(t=Math.max(0,t-(performance.now()-s))))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const s=performance.now();if(!this._opacityJob.work(t))return!1;if(this._opacityJobCompleted=!0,0===(t=Math.max(0,t-(performance.now()-s))))return!1}return this._running=!1,!0}_createSelectionJob(){const t=this._symbolRepository.uniqueSymbols;for(let s=0;s<t.length;s++){const i=t[s];for(let t=0;t<i.uniqueSymbols.length;t++){const s=i.uniqueSymbols[t];for(const t of s.tileSymbols)t.selectedForRendering=!1}}const s=[];let i=0,e=0;const n=this._isLayerVisible;function h(h){let r;const o=performance.now();for(;e<t.length;e++,i=0){const a=t[e],c=a.styleLayerUID;if(!n(c)){s[e]||(s[e]={styleLayerUID:c,symbols:[]});continue}s[e]=s[e]||{styleLayerUID:c,symbols:[]};const l=s[e];for(;i<a.uniqueSymbols.length;i++){if(r=a.uniqueSymbols[i],i%100==99&&performance.now()-o>h)return!1;let t=null,s=!1,e=!1;for(const i of r.tileSymbols)if(!e||!s){const n=i.tile;(!t||n.isCoverage||n.neededForCoverage&&!s)&&(t=i,(n.neededForCoverage||n.isCoverage)&&(e=!0),n.isCoverage&&(s=!0))}if(t.selectedForRendering=!0,e){l.symbols.push(t),r.show=!0;for(const t of r.parts)t.show=!0}else r.show=!1}}for(const t of s)t.symbols.sort(Zt);return!0}const r=this._symbolLayerSorter;return{work:h,get sortedSymbols(){return s.sort(r)}}}_createOpacityJob(){const t=this._assignTileSymbolsOpacity,s=this._visibleTiles;let i=0;function e(s,i){for(const t of s.symbols.values())ss(t,i);t(s,i);for(const t of s.childrenTiles)e(t,i)}return{work(t){const n=performance.now();for(;i<s.length;i++){if(performance.now()-n>t)return!1;const h=s[i];if(null!=h.parentTile)continue;e(h,performance.now())}return!0}}}}function ss(t,s){for(const i of t){const t=i.unique;for(const i of t.parts){const e=i.targetOpacity>.5?1:-1;i.startOpacity+=e*((s-i.startTime)/et),i.startOpacity=Math.min(Math.max(i.startOpacity,0),1),i.startTime=s,i.targetOpacity=t.show&&i.show?1:0}}}const is=32,es=8,ns=64,hs=20;class rs{constructor(t,s,i){this.tileCoordRange=t,this._visibleTiles=s,this._createUnique=i,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return null==this._uniqueSymbolLayerArray&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}get uniqueSymbolsReferences(){return this._uniqueSymbolsReferences}add(t,s){this._uniqueSymbolLayerArray=null;let i=this._tiles.get(t.id);i||(i={symbols:new Map},this._tiles.set(t.id,i));const e=new Map;if(s)for(const t of s)i.symbols.has(t)&&(e.set(t,i.symbols.get(t)),i.symbols.delete(t));else for(const[s,n]of t.layerData)i.symbols.has(s)&&(e.set(s,i.symbols.get(s)),i.symbols.delete(s));this._removeSymbols(e);const n=t.symbols,h=new Map;for(const[t,s]of n){let e=s.length;if(e>=is){let n=this.tileCoordRange;do{n/=2,e/=4}while(e>es&&n>ns);const r=new Vt(this.tileCoordRange,this.tileCoordRange,n);h.set(t,{flat:s,index:r}),i.symbols.set(t,{flat:s,index:r});for(const t of s)r.getCell(t.xTile,t.yTile).push(t)}else h.set(t,{flat:s}),i.symbols.set(t,{flat:s})}this._addSymbols(t.key,n)}deleteStyleLayers(t){this._uniqueSymbolLayerArray=null;for(const[s,i]of this._tiles){const e=new Map;for(const s of t)i.symbols.has(s)&&(e.set(s,i.symbols.get(s)),i.symbols.delete(s));this._removeSymbols(e),0===i.symbols.size&&this._tiles.delete(s)}}removeTile(t){this._uniqueSymbolLayerArray=null;const s=this._tiles.get(t.id);if(!s)return;const i=new Map;for(const[e,n]of t.symbols)s.symbols.has(e)&&(i.set(e,s.symbols.get(e)),s.symbols.delete(e));this._removeSymbols(i),0===s.symbols.size&&this._tiles.delete(t.id)}querySymbols(t,s,i,e){const n=[],h=this.uniqueSymbols;for(const e of h){const h=e.styleLayerUID,r=e.uniqueSymbols;for(const e of r){const r=e.tileSymbols.find((t=>t.selectedForRendering));r&&$t(r,t,s*(window.devicePixelRatio||1),i)&&n.push({vtlSymbol:r,styleLayerUID:h,tileKey:r.tile.key})}}return n}_removeSymbols(t){for(const[s,{flat:i}]of t)for(const t of i){const i=t.unique,e=i.tileSymbols,n=e.length-1;for(let s=0;s<n;s++)if(e[s]===t){e[s]=e[n];break}if(e.length=n,0===n){const t=this._uniqueSymbolsReferences.get(s);t.delete(i),0===t.size&&this._uniqueSymbolsReferences.delete(s)}t.unique=null}}_addSymbols(t,s){if(0===s.size)return;const i=this._visibleTiles;for(const e of i)e.parentTile||e.key.world!==t.world||e.key.level===t.level&&!e.key.equals(t)||this._matchSymbols(e,t,s);for(const[t,i]of s)for(const s of i)if(null==s.unique){const i=this._createUnique();s.unique=i,i.tileSymbols.push(s);let e=this._uniqueSymbolsReferences.get(t);e||(e=new Set,this._uniqueSymbolsReferences.set(t,e)),e.add(i)}}_matchSymbols(t,s,i){if(t.key.level>s.level){const i=t.key.level-s.level;if(t.key.row>>i!==s.row||t.key.col>>i!==s.col)return}if(s.level>t.key.level){const i=s.level-t.key.level;if(s.row>>i!==t.key.row||s.col>>i!==t.key.col)return}if(s.equals(t.key)){for(const e of t.childrenTiles)this._matchSymbols(e,s,i);return}const e=new Map;for(const[n,h]of i){const i=[];for(const e of h){const n=zt(this.tileCoordRange,e.xTile,s.level,s.col,t.key.level,t.key.col),h=zt(this.tileCoordRange,e.yTile,s.level,s.row,t.key.level,t.key.row);n>=0&&n<this.tileCoordRange&&h>=0&&h<this.tileCoordRange&&i.push({symbol:e,xTransformed:n,yTransformed:h})}const r=[],o=(t.key.level<s.level?1:1<<t.key.level-s.level)+hs,a=this._tiles.get(t.id).symbols.get(n);if(a){const t=a.flat;for(const s of i){let i,e=!1;const n=s.xTransformed,h=s.yTransformed;i=null!=a.index?a.index.getCell(n,h):t;const c=s.symbol,l=c.hash;for(const t of i)if(l===t.hash&&Math.abs(n-t.xTile)<=o&&Math.abs(h-t.yTile)<=o){const s=t.unique;c.unique=s,s.tileSymbols.push(c),e=!0;break}e||r.push(c)}}r.length>0&&e.set(n,r)}for(const i of t.childrenTiles)this._matchSymbols(i,s,e)}_createUniqueSymbolLayerArray(){const t=this._uniqueSymbolsReferences,s=new Array(t.size);let i,e=0;for(const[n,h]of t){const t=new Array(h.size);i=0;for(const s of h)t[i++]=s;s[e]={styleLayerUID:n,uniqueSymbols:t},e++}return s}}const os=.5,as=1e-6;class cs{constructor(t,s){this.styleRepository=t,this._tileToHandle=new Map,this._viewState={scale:0,rotation:0,center:[0,0],size:[0,0]},this._declutterViewState={scale:0,rotation:0,center:[0,0],size:[0,0]},this._offsetFromScreenCenter=[0,0],this._completed=!1,this._fading=x(!1),this._symbolRepository=new rs(4096,s,(()=>new qt)),this._symbolDeclutterer=new ts(s,this._symbolRepository,((t,s,i)=>this._createCollisionJob(t,s,i)),((t,s)=>{t.allSymbolsFadingOut=!0,t.lastOpacityUpdate=s,Kt(t,s,!0),t.decluttered=!0,t.requestRender()}),((t,s)=>this.styleRepository.getStyleLayerByUID(t.styleLayerUID).z-this.styleRepository.getStyleLayerByUID(s.styleLayerUID).z),(t=>{const s=this.styleRepository.getStyleLayerByUID(t);if(this._zoom+as<s.minzoom||this._zoom-as>=s.maxzoom)return!1;const i=s.getLayoutProperty("visibility");return!i||i.getValue()!==lt.NONE}))}get symbolRepository(){return this._symbolRepository}_createCollisionJob(t,s,i){return this.updateDecluttererViewState(),new Jt(t,s,i,this.styleRepository,this._zoom,this._viewState.rotation)}get fading(){return this._fading.value}get decluttererOffset(){return this._offsetFromScreenCenter}addTile(t){t.decluttered=!1,this._tileToHandle.set(t,t.on("symbols-changed",(()=>{this._symbolRepository.add(t),this.restartDeclutter()}))),this._symbolRepository.add(t),this.restartDeclutter()}removeTile(t){const s=this._tileToHandle.get(t);s&&(this._symbolRepository.removeTile(t),this.restartDeclutter(),s.remove(),this._tileToHandle.delete(t))}update(t,s){this._zoom=t,this._viewState={scale:s.scale,rotation:s.rotation,center:[s.center[0],s.center[1]],size:[s.size[0],s.size[1]]};const i=[0,0];s.toScreen(i,s.center);const e=[0,0];return s.toScreen(e,this._declutterViewState.center),this._offsetFromScreenCenter[0]=i[0]-e[0],this._offsetFromScreenCenter[1]=i[1]-e[1],this._continueDeclutter(),this._completed}restartDeclutter(){this._completed=!1,this._symbolDeclutterer.restart(),this._notifyUnstable()}clear(){this._completed=!1,this._symbolRepository=null,this._symbolDeclutterer.restart(),this._tileToHandle.forEach((t=>t.remove())),this._tileToHandle.clear()}get stale(){return this._zoom!==this._declutterZoom||this._viewState.size[0]!==this._declutterViewState.size[0]||this._viewState.size[1]!==this._declutterViewState.size[1]||this._viewState.scale!==this._declutterViewState.scale||this._viewState.rotation!==this._declutterViewState.rotation}deleteStyleLayers(t){this._symbolRepository.deleteStyleLayers(t)}_continueDeclutter(){this._completed&&!this.stale||(this._symbolDeclutterer.running||(this.updateDecluttererViewState(),this._symbolDeclutterer.restart()),this._symbolDeclutterer.setScreenSize(this._viewState.size[0],this._viewState.size[1]),this._completed=this._symbolDeclutterer.continue(ht),this._completed&&this._scheduleNotifyStable())}_scheduleNotifyStable(){null!=this._stableNotificationHandle&&clearTimeout(this._stableNotificationHandle),this._stableNotificationHandle=setTimeout((()=>{this._stableNotificationHandle=null,this._fading.value=!1}),(1+os)*et)}_notifyUnstable(){null!=this._stableNotificationHandle&&(clearTimeout(this._stableNotificationHandle),this._stableNotificationHandle=null),this._fading.value=!0}updateDecluttererViewState(){this._declutterZoom=this._zoom,this._declutterViewState.center[0]=this._viewState.center[0],this._declutterViewState.center[1]=this._viewState.center[1],this._declutterViewState.rotation=this._viewState.rotation,this._declutterViewState.scale=this._viewState.scale,this._declutterViewState.size[0]=this._viewState.size[0],this._declutterViewState.size[1]=this._viewState.size[1],this._offsetFromScreenCenter[0]=0,this._offsetFromScreenCenter[1]=0}}class ls extends rt{_createTransforms(){return{displayViewScreenMat3:T(),tileMat3:T()}}}const us=1e-6;function fs(t,s){if(t){const i=t.getLayoutProperty("visibility");if(!i||i.getValue()!==lt.NONE&&(void 0===t.minzoom||t.minzoom<s+us)&&(void 0===t.maxzoom||t.maxzoom>=s-us))return!0}return!1}class ys extends ft{constructor(t){super(t),this._backgroundTiles=[],this._computeDisplayInfoView(t)}destroy(){this.removeAllChildren(),this._spriteMosaic?.dispose(),this._spriteMosaic=null,this._glyphMosaic?.dispose(),this._glyphMosaic=null,null!=this._symbolFader&&(this._symbolFader.clear(),this._symbolFader=null),this._styleRepository=null,this._backgroundTiles=[]}get fading(){return this._symbolFader?.fading??!1}get symbolFader(){return this._symbolFader}get symbolRepository(){return this._symbolFader?.symbolRepository}setStyleResources(t,s,i,e){this._spriteMosaic=t,this._glyphMosaic=s,this._styleRepository=i,this.tileInfoView=e,this._computeDisplayInfoView(e),null==this._symbolFader&&(this._symbolFader=new cs(this._styleRepository,this.children)),this._symbolFader.styleRepository=i}setSpriteMosaic(t){this._spriteMosaic?.dispose(),this._spriteMosaic=t}deleteStyleLayers(t){null!=this._symbolFader&&this._symbolFader.deleteStyleLayers(t)}createRenderParams(t){return{...super.createRenderParams(t),renderPass:null,styleLayer:null,styleLayerUID:-1,glyphMosaic:this._glyphMosaic,spriteMosaic:this._spriteMosaic,hasClipping:!!this._clippingInfos}}doRender(t){!this.visible||t.drawPhase!==D.MAP&&t.drawPhase!==D.DEBUG||void 0===this._spriteMosaic||super.doRender(t)}addChild(t){return super.addChild(t),null!=this._symbolFader?this._symbolFader.addTile(t):t.decluttered=!0,this.requestRender(),t}removeChild(t){return null!=this._symbolFader&&this._symbolFader.removeTile(t),this.requestRender(),super.removeChild(t)}renderChildren(t){const{drawPhase:s}=t;s!==D.DEBUG?this._doRender(t):super.renderChildren(t)}removeAllChildren(){for(let t=0;t<this.children.length;t++){const s=this.children[t];null!=this._symbolFader&&this._symbolFader.removeTile(s),s.dispose()}super.removeAllChildren()}getStencilTarget(){return this.children.filter((t=>t.neededForCoverage&&t.hasData()))}restartDeclutter(){null!=this._symbolFader&&this._symbolFader.restartDeclutter()}_doRender(t){const{context:s,state:i}=t,e=this._styleRepository;if(!e)return;const n=e.layers,h=this._displayInfo.scaleToZoom(i.scale);e.backgroundBucketIds.length>0&&(t.renderPass="background",this._renderBackgroundLayers(t,e.backgroundBucketIds,h)),super.renderChildren(t),t.drawPhase===D.MAP&&this._fade(h,i);const r=this.children.filter((t=>t.visible&&t.hasData()));if(!r||0===r.length)return s.bindVAO(),s.setStencilTestEnabled(!0),void s.setBlendingEnabled(!0);for(const t of r)t.triangleCount=0;s.setStencilWriteMask(0),s.setColorMask(!0,!0,!0,!0),s.setStencilOp(k.KEEP,k.KEEP,k.REPLACE),s.setStencilTestEnabled(!0),s.setBlendingEnabled(!1),s.setDepthTestEnabled(!0),s.setDepthWriteEnabled(!0),s.setDepthFunction(P.LEQUAL),s.setClearDepth(1),s.clear(s.gl.DEPTH_BUFFER_BIT),t.renderPass="opaque";for(let s=n.length-1;s>=0;s--)this._renderStyleLayer(n[s],t,r);s.setDepthWriteEnabled(!1),s.setBlendingEnabled(!0),s.setBlendFunctionSeparate(j.ONE,j.ONE_MINUS_SRC_ALPHA,j.ONE,j.ONE_MINUS_SRC_ALPHA),t.renderPass="translucent";for(let s=0;s<n.length;s++)this._renderStyleLayer(n[s],t,r);s.bindVAO(),s.setStencilTestEnabled(!0),s.setBlendingEnabled(!0);for(const t of r)t.debugInfo.display.triangleCount=t.triangleCount}_fade(t,s){null!=this._symbolFader&&(this._symbolFader.update(t,s)||this.requestRender())}_renderStyleLayer(t,s,i){const{displayLevel:e,painter:n,renderPass:h}=s;if(void 0===t)return;const r=t.getLayoutProperty("visibility");if(r&&r.getValue()===lt.NONE)return;let o;switch(t.type){case ut.BACKGROUND:return;case ut.FILL:if("opaque"!==h&&"translucent"!==s.renderPass)return;o="vtlFill";break;case ut.LINE:if("translucent"!==h)return;o="vtlLine";break;case ut.CIRCLE:if("translucent"!==h)return;o="vtlCircle";break;case ut.SYMBOL:if("translucent"!==h)return;o="vtlSymbol"}if(i=t.type===ut.SYMBOL?i.filter((t=>t.decluttered)):i.filter((t=>t.neededForCoverage)),"vtlSymbol"!==o&&(0===i.length||void 0!==t.minzoom&&t.minzoom>=e+us||void 0!==t.maxzoom&&t.maxzoom<e-us))return;const a=t.uid;s.styleLayerUID=a,s.styleLayer=t;for(const t of i)if(t.layerData.has(a)){n.renderObjects(s,i,o);break}}_renderBackgroundLayers(t,s,i){const{context:e,painter:n,state:h}=t,r=this._styleRepository;let o=!1;for(const t of s){if(r.getLayerById(t).type===ut.BACKGROUND&&fs(r.getLayerById(t),i)){o=!0;break}}if(!o)return;const a=this.tileInfoView,c=a.getTileCoverage(t.state,0,!0,"smallest"),{spans:u,lodInfo:f}=c,{level:y}=f,p=m(),w=[];if(this._renderPasses){const s=this._renderPasses[0];null!=this._clippingInfos&&(s.brushes[0].prepareState(t),s.brushes[0].drawMany(t,this._clippingInfos))}const g=this._backgroundTiles;let b,M=0;for(const{row:t,colFrom:s,colTo:i}of u)for(let e=s;e<=i;e++){if(M<g.length)b=g[M],b.key.set(y,t,f.normalizeCol(e),f.getWorldForColumn(e)),a.getTileBounds(p,b.key,!1),b.x=p[0],b.y=p[3],b.resolution=a.getTileResolution(y);else{const s=new l(y,t,f.normalizeCol(e),f.getWorldForColumn(e)),i=a.getTileBounds(m(),s),n=a.getTileResolution(y);b=new ls(s,n,i[0],i[3],512,512,4096,4096),g.push(b)}b.setTransform(h),w.push(b),M++}e.setStencilWriteMask(0),e.setColorMask(!0,!0,!0,!0),e.setStencilOp(k.KEEP,k.KEEP,k.REPLACE),e.setStencilFunction(P.EQUAL,0,255),e.setStencilTestEnabled(!0);for(const e of s){const s=r.getLayerById(e);s.type===ut.BACKGROUND&&fs(s,i)&&(t.styleLayerUID=s.uid,t.styleLayer=s,n.renderObjects(t,w,"vtlBackground"))}d.pool.release(c)}_computeDisplayInfoView(t){let s=t.tileInfo.lods[0].scale;const i=Math.max(25,t.tileInfo.lods.length),e=[];for(let t=0;t<=i;t++)e.push(s),s/=2;this._displayInfo=U.create({scales:e,size:512,spatialReference:t.spatialReference,numLODs:i})}}const ds=8,ps=512,ws=4096,ms=(t,s)=>{const i=t.vtlSymbol.sourceTile,e=s.vtlSymbol.sourceTile;return i.level!==e.level?i.level-e.level:i.row!==e.row?i.row-e.row:i.col!==e.col?i.col-e.col:t.styleLayerUID-s.styleLayerUID};class gs{constructor(t,s,i,e,n){this.tileKey=t,this._tileLayerData=s,this._styleRepository=i,this._tileHandler=e,this._parentLayer=n,this._index=null,this._tileKeyToPBF=new Map}static create(t,s,i,e,n){return new gs(t,s,i,e,n)}clear(){this._index?.clear(),this._tileKeyToPBF.clear()}async queryAttributes(t,s,i,e,n){if(0===this._tileLayerData.size||!this._styleRepository||!this._tileHandler)return[];null===this._index&&(this._index=new yt(100,bs),await this._indexLayers());const h=[];return this._queryIndex(h,t,s,i,this.tileKey.level,e),n&&n?.length>0&&await this._getSymbolsAttributes(h,n),h}async _indexLayers(){const t=this.tileKey,s=this._styleRepository.layers,i=await this._getTilePayload(t);for(const[e,n]of this._tileLayerData){const h=s[e],r=i.find((t=>t.sourceName===h.source));if(!r)continue;const{protobuff:o,key:a}=r;if(n.type!==G.SYMBOL){const s=1<<t.level-a.level,i=t.row-a.row*s,e=t.col-a.col*s;this._indexLayer(h,o,t.level,s,i,e)}}}_indexLayer(t,s,i,e,n,h){const r=t.sourceLayer,o=t.getFeatureFilter(),a=i,c=i+1,l=tt(a),u=new E(new Uint8Array(s),new DataView(s));for(;u.next();)switch(u.tag()){case 3:{const s=u.getMessage(),f=new dt(s);if(s.release(),f.name!==r)continue;const y=f.getData(),d=f.extent/e,p=d*h-l,w=d*n-l,m=p+d+2*l,g=w+d+2*l,b=d/ps,M=ws/d,A=d*h,v=d*n;for(;y.nextTag(2);){const s=y.getMessage(),e=new pt(s,f);if(s.release(),o&&!o.filter(e,i))continue;const n=e.values||{},h=n._minzoom,r=n._maxzoom;if(h&&h>=10*c||r&&r<=10*a)continue;const l=t.getFeatureInflatedBounds(e,a,f.extent,b);null==l||l[0]>m||l[1]>g||l[2]<p||l[3]<w||(l[0]=(l[0]-A)*M,l[1]=(l[1]-v)*M,l[2]=(l[2]-A)*M,l[3]=(l[3]-v)*M,this._index.insert(new wt(t,e,l,M,A,v)))}break}default:u.skip()}}async _getSymbolsAttributes(t,s){if(!s||0===s.length)return t;const i=[];s.sort(ms);let e=s[0].styleLayerUID,n=0;for(let t=0;t<s.length;t++)e!==s[t].styleLayerUID&&(i.push({from:n,to:t,styleLayerUID:e,sourceTileKey:s[t].vtlSymbol.sourceTile}),n=t,e=s[t].styleLayerUID);i.push({from:n,to:s.length,styleLayerUID:e,sourceTileKey:s[s.length-1].vtlSymbol.sourceTile});const h=this._styleRepository.layers;let r,o=null;for(const n of i){const i=await this._getTilePayload(n.sourceTileKey);r=h[n.styleLayerUID],o=!!r&&i.find((t=>t.sourceName===r.source)),o&&this._addSymbolsAttributes(t,s.slice(n.from,n.to).map((t=>t.vtlSymbol)),e,o)}return t}_addSymbolsAttributes(t,s,i,e){const n=this._styleRepository.layers,h=e.key,r=this.tileKey,o=1<<r.level-h.level,a=r.row-h.row*o,c=r.col-h.col*o;this._getSymbolAttributes(e.protobuff,s,i,o,a,c).forEach((s=>{const{attributes:e,tilePoint:h}=s;t.push({layerId:n[i].id,layerIndex:i,graphic:new R({attributes:e,origin:{type:"vector-tile",layerId:n[i].id,layerIndex:i,layer:this._parentLayer}}),tilePoint:h})}))}_getSymbolAttributes(t,s,i,e,n,h){const r=[],o=this._styleRepository.layers;let a=0;s.sort(((t,s)=>t.featureIndex-s.featureIndex));const c=new E(new Uint8Array(t),new DataView(t));for(;c.next();)switch(c.tag()){case 3:{const t=c.getMessage(),l=new dt(t);if(t.release(),l.name!==o[i].sourceLayer)continue;const u=l.getData(),f=l.extent/e,y=ws/f,d=f*h,p=f*n;let w=0;for(;u.nextTag(2);){const t=u.getMessage();if(w++===s[a].featureIndex){const s=new pt(t,l),i=s.values,e=s.getGeometry(),n=null!=e?[y*(e[0][0].x-d),y*(e[0][0].y-p)]:null;r.push({attributes:i,tilePoint:n}),a++}if(t.release(),a===s.length)return r}break}default:c.skip()}return r}_queryIndex(t,s,i,e,n,h){const r=ds*e*(window.devicePixelRatio||1);return this._index?.search({minX:s-r,minY:i-r,maxX:s+r,maxY:i+r},(r=>{const{layer:o,feature:a}=r;o.isIntersectingFeature(s,i,e,a,n,h,r)&&t.push({layerId:o.id,layerIndex:o.uid,tilePoint:null,graphic:new R({attributes:a.values,origin:{type:"vector-tile",layerId:r.layer.id,layerIndex:r.layer.uid,layer:this._parentLayer}})})})),t}async _getTilePayload(t){return L(this._tileKeyToPBF,t.id,(()=>this._tileHandler.fetchTilePBFs(t))).then((t=>t))}}const bs=t=>({minX:t.bounds[0],minY:t.bounds[1],maxX:t.bounds[2],maxY:t.bounds[3]});class Ms extends C{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(t){const s=l.pool.acquire(t),i=0===s.level?null:l.getId(s.level-1,s.row>>1,s.col>>1,s.world);return l.pool.release(s),i}getTileCoverage(t,s,i=!0,e){const n=super.getTileCoverage(t,s,i,e);if(!n)return n;const h=1<<n.lodInfo.level;return n.spans=n.spans.filter((t=>t.row>=0&&t.row<h)),n}scaleToLevel(t){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[t])return this._levelByScale[t];{const s=this._fullCacheLodInfos;if(t>s[0].scale)return s[0].level;let i,e;for(let n=0;n<s.length-1;n++)if(e=s[n+1],t>e.scale)return i=s[n],i.level+(i.scale-t)/(i.scale-e.scale);return s[s.length-1].level}}_initializeFullCacheLODs(t){let s;if(0===t[0].level)s=t.map((t=>({level:t.level,resolution:t.resolution,scale:t.scale})));else{const t=this.tileInfo.size[0],i=this.tileInfo.spatialReference;s=U.create({size:t,spatialReference:i}).lods.map((t=>({level:t.level,resolution:t.resolution,scale:t.scale})))}for(let t=0;t<s.length;t++)this._levelByScale[s[t].scale]=s[t].level;this._fullCacheLodInfos=s}}const As=2,vs=8,Ss=512;let _s=class extends(Mt(gt(bt))){constructor(){super(...arguments),this._styleChanges=[],this._fetchQueue=null,this._parseQueue=null,this._tileHandlerPromise=null,this._isTileHandlerReady=!1,this._styeChanged=!1,this._spriteSourceChanged=!1}get fading(){return this._vectorTileContainer?.fading??!1}get hasVisibleFeatures(){const t=this._vectorTileContainer.children;for(const s of t)if(s.hasFeatures())return!0;return!1}get spriteSourceChanged(){return this._spriteSourceChanged}get styleChanged(){return this._styeChanged}async hitTest(t,s){const i=this._tileHandlerPromise,e=this._vectorTileContainer?.symbolFader;if(!i||!this._isTileHandlerReady||!e)return;await i;let n=null;const h=this._vectorTileContainer?.symbolRepository;h&&(n=h.querySymbols(s,As,e.decluttererOffset,{}));const r=this.view.state,o=this._tileManager.getIntersectingTiles(s.x,s.y,As,r,n);if((!o||0===o.length)&&0===n?.length)return null;t=t.clone().normalize();const a=[],c=[];for(const s of o)a.push(this._queryTile(c,t,As,this.view.state.rotation,s,n?.filter((t=>t.tileKey.id===s.id))));return await Promise.all(a),c}update(t){if(this._tileHandlerPromise&&this._isTileHandlerReady)return t.pixelRatio!==this._tileHandler.devicePixelRatio?(this._start(),void(this._tileHandler.devicePixelRatio=t.pixelRatio)):void(this._styleChanges.length>0?this._tileHandlerPromise=this._applyStyleChanges():(this._pauseQueues(),this._fetchQueue.state=t.state,this._parseQueue.state=t.state,this._tileManager.update(t)||this.requestUpdate(),this._resumeQueues()))}attach(){const{style:t}=this.layer.currentStyleInfo;this._styleRepository=new mt(t),this._tileInfoView=new Ms(this.layer.tileInfo,this.layer.fullExtent),this._vectorTileContainer=new ys(this._tileInfoView),this._tileHandler=new kt(this.layer,this._styleRepository,window.devicePixelRatio||1,this.layer.tileInfo.lods.length-1),this.container.addChild(this._vectorTileContainer),this._start(),this.addAttachHandles([this.layer.on("paint-change",(t=>{if(this._styeChanged=!0,t.isDataDriven)this._styleChanges.push({type:Y.PAINTER_CHANGED,data:t}),this.requestUpdate();else{const s=this._styleRepository,i=s.getLayerById(t.layer);if(!i)return;const e=i.type===ut.SYMBOL;s.setPaintProperties(t.layer,t.paint),e&&this._vectorTileContainer?.restartDeclutter(),this._vectorTileContainer?.requestRender()}})),this.layer.on("layout-change",(t=>{const s=this._styleRepository,i=s.getLayerById(t.layer);if(!i)return;this._styeChanged=!0;const e=O(i.layout,t.layout);if(null!=e){if(F(e,"visibility")&&1===Ts(e))return s.setLayoutProperties(t.layer,t.layout),i.type===ut.SYMBOL&&this._vectorTileContainer?.restartDeclutter(),void this._vectorTileContainer?.requestRender();this._styleChanges.push({type:Y.LAYOUT_CHANGED,data:t}),this.requestUpdate()}})),this.layer.on("style-layer-visibility-change",(t=>{const s=this._styleRepository,i=s.getLayerById(t.layer);i&&(this._styeChanged=!0,s.setStyleLayerVisibility(t.layer,t.visibility),i.type===ut.SYMBOL&&this._vectorTileContainer?.restartDeclutter(),this._vectorTileContainer?.requestRender())})),this.layer.on("style-layer-change",(t=>{this._styleChanges.push({type:Y.LAYER_CHANGED,data:t}),this._styeChanged=!0,this.requestUpdate()})),this.layer.on("delete-style-layer",(t=>{this._styleChanges.push({type:Y.LAYER_REMOVED,data:t}),this._styeChanged=!0,this.requestUpdate()})),this.layer.on("load-style",(()=>this._loadStyle())),this.layer.on("spriteSource-change",(t=>{this._spriteSourceChanged=!0,this._styleChanges.push({type:Y.SPRITES_CHANGED,data:t});const s=this._styleRepository.layers;for(const t of s)switch(t.type){case ut.SYMBOL:t.getLayoutProperty("icon-image")&&this._styleChanges.push({type:Y.LAYOUT_CHANGED,data:{layer:t.id,layout:t.layout}});break;case ut.LINE:t.getPaintProperty("line-pattern")&&this._styleChanges.push({type:Y.PAINTER_CHANGED,data:{layer:t.id,paint:t.paint,isDataDriven:t.isPainterDataDriven()}});break;case ut.FILL:t.getLayoutProperty("fill-pattern")&&this._styleChanges.push({type:Y.PAINTER_CHANGED,data:{layer:t.id,paint:t.paint,isDataDriven:t.isPainterDataDriven()}})}this.requestUpdate()}))])}detach(){this._stop(),this.container.removeAllChildren(),this._vectorTileContainer=q(this._vectorTileContainer),this._tileHandler=q(this._tileHandler)}viewChange(){this.requestUpdate()}moveEnd(){this.requestUpdate()}supportsSpatialReference(t){return z(this.layer.tileInfo?.spatialReference,t)}canResume(){let t=super.canResume();const{currentStyleInfo:s}=this.layer;if(t&&s?.layerDefinition){const i=this.view.scale,{minScale:e,maxScale:n}=s.layerDefinition;s?.layerDefinition&&(e&&e<i&&(t=!1),n&&n>i&&(t=!1))}return t}isUpdating(){return this.fading}acquireTile(t){const s=this._createVectorTile(t);return this._updatingHandles.addPromise(this._fetchQueue.push(s.key).then((t=>this._parseQueue.push({key:s.key,data:t}))).then((t=>{s.once("attach",(()=>this.requestUpdate())),s.setData(t),this.requestUpdate()})).catch((t=>{u(t)||V.getLogger(this).error(t)}))),s}releaseTile(t){const s=t.key.id;this._fetchQueue.abort(s),this._parseQueue.abort(s),this.requestUpdate()}async doRefresh(){if(!this.attached)return;if(this.suspended)return this._tileManager.clear(),void this.requestUpdate();this._isTileHandlerReady=!1,this._pauseQueues(),this._clearQueues(),this._tileManager.clearCache(),this._resumeQueues();const t=this._vectorTileContainer.children,s=[];try{for(const i of t){const t=this._updatingHandles.addPromise(this._fetchQueue.push(i.key).then((t=>this._parseQueue.push({key:i.key,data:t}))).then((t=>i.setData(t))).finally((()=>i.featureIndex=null)));s.push(t)}await Promise.all(s)}catch(t){V.getLogger(this).error("error refreshing vector-tiles layer-view",t),this._resumeQueues(),this._isTileHandlerReady=!0}this._isTileHandlerReady=!0,this.requestUpdate()}_start(){if(this._stop(),this._tileManager=new Lt({acquireTile:t=>this.acquireTile(t),releaseTile:t=>this.releaseTile(t),tileInfoView:this._tileInfoView},this._vectorTileContainer),!this.layer.currentStyleInfo)return;const t=new AbortController,s=this._tileHandler.start({signal:t.signal}).then((()=>{this._fetchQueue=new B({tileInfoView:this._tileInfoView,process:(t,s)=>this._getTileData(t,s),concurrency:15,scheduler:this.scheduler,priority:K.MAPVIEW_FETCH_QUEUE}),this._parseQueue=new B({tileInfoView:this._tileInfoView,process:(t,s)=>this._parseTileData(t,s),concurrency:8,scheduler:this.scheduler,priority:K.MAPVIEW_VECTOR_TILE_PARSING_QUEUE}),this.requestUpdate(),this._isTileHandlerReady=!0}));this._tileHandler.spriteMosaic.then((t=>{this._vectorTileContainer.setStyleResources(t,this._tileHandler.glyphMosaic,this._styleRepository,this._tileInfoView),this.requestUpdate()})),this._tileHandlerAbortController=t,this._tileHandlerPromise=s}_stop(){if(!this._tileHandlerAbortController||!this._vectorTileContainer)return;const t=this._tileHandlerAbortController;t&&t.abort(),this._tileHandlerPromise=null,this._isTileHandlerReady=!1,this._fetchQueue=q(this._fetchQueue),this._parseQueue=q(this._parseQueue),this._tileManager=q(this._tileManager),this._vectorTileContainer.removeAllChildren()}async _getTileData(t,s){return this._tileHandler.fetchTileData(t,s)}async _parseTileData(t,s){return this._tileHandler.parseTileData(t,s)}async _applyStyleChanges(){this._isTileHandlerReady=!1,this._pauseQueues(),this._clearQueues(),this._tileManager.clearCache();const t=this._styleChanges;try{await this._tileHandler.updateStyle(t)}catch(t){V.getLogger(this).error("error applying vector-tiles style update",t.message),this._resumeQueues(),this._isTileHandlerReady=!0}const s=this._styleRepository,i=new Set;t.forEach((t=>{if(t.type!==Y.LAYER_REMOVED)return;const e=t.data,n=s.getLayerById(e.layer);n&&i.add(n.uid)}));const e=new Set;t.forEach((t=>{let i;switch(t.type){case Y.PAINTER_CHANGED:s.setPaintProperties(t.data.layer,t.data.paint),i=t.data.layer;break;case Y.LAYOUT_CHANGED:s.setLayoutProperties(t.data.layer,t.data.layout),i=t.data.layer;break;case Y.LAYER_REMOVED:return void s.deleteStyleLayer(t.data.layer);case Y.LAYER_CHANGED:s.setStyleLayer(t.data.layer,t.data.index),i=t.data.layer.id;break;case Y.SPRITES_CHANGED:this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(t.data.spriteSource))}if(i){const t=s.getLayerById(i);t&&e.add(t.uid)}}));const n=this._vectorTileContainer.children;if(i.size>0){const t=Array.from(i);this._vectorTileContainer.deleteStyleLayers(t);for(const s of n)s.deleteLayerData(t)}if(this._resumeQueues(),e.size>0){const t=Array.from(e),s=[];for(const i of n){const e=this._updatingHandles.addPromise(this._fetchQueue.push(i.key).then((s=>this._parseQueue.push({key:i.key,data:s,styleLayerUIDs:t}))).then((t=>i.setData(t))).finally((()=>i.featureIndex=null)));s.push(e)}await Promise.all(s)}this._styleChanges=[],this._isTileHandlerReady=!0,this.requestUpdate()}async _loadStyle(){const{style:t}=this.layer.currentStyleInfo,s=N(t);this._isTileHandlerReady=!1,this._pauseQueues(),this._clearQueues(),this._styleRepository=new mt(s),this._vectorTileContainer.destroy(),this._tileManager.clear(),this._tileHandlerAbortController.abort(),this._tileHandlerAbortController=new AbortController;const{signal:i}=this._tileHandlerAbortController;try{this._tileHandlerPromise=this._tileHandler.setStyle(this._styleRepository,s,this.layer.tileInfo.lods.length-1),await this._tileHandlerPromise}catch(t){if(!u(t))throw t}if(i.aborted)return this._resumeQueues(),this._isTileHandlerReady=!0,this._styeChanged=!1,this._spriteSourceChanged=!1,void this.requestUpdate();const e=await this._tileHandler.spriteMosaic,n=this._vectorTileContainer;this._tileInfoView=new Ms(this.layer.tileInfo,this.layer.fullExtent),n.setStyleResources(e,this._tileHandler.glyphMosaic,this._styleRepository,this._tileInfoView),this._tileManager=new Lt({acquireTile:t=>this.acquireTile(t),releaseTile:t=>this.releaseTile(t),tileInfoView:this._tileInfoView},this._vectorTileContainer),this._resumeQueues(),this._isTileHandlerReady=!0,this.requestUpdate(),this._styeChanged=!1,this._spriteSourceChanged=!1}_createVectorTile(t){const s=this._tileInfoView.getTileBounds(m(),t),i=this._tileInfoView.getTileResolution(t.level);return new Qt(t,i,s[0],s[3],512,512,this._styleRepository)}async _queryTile(t,s,i,e,n,h){if(0===n.layerData.size)return;const r=this._ensureTileIndex(n),o=this._tileInfoView.getTileBounds(m(),n.key,!0),a=vs*Ss*((s.x-o[0])/(o[2]-o[0])),c=vs*Ss*(1-(s.y-o[1])/(o[3]-o[1])),l=await r.queryAttributes(a,c,i,e,h);for(const i of l)i.graphic.geometry=this._tileToMapPoint(i.tilePoint,n.transforms.tileUnitsToPixels),t.push({type:"graphic",layer:this.layer,graphic:i.graphic,mapPoint:s.clone()});t.sort(((t,s)=>s.graphic.origin.layerIndex-t.graphic.origin.layerIndex))}_tileToMapPoint(t,s){if(!t)return null;const i=t[0]*s[0]+t[1]*s[3]+s[6],e=t[0]*s[1]+t[1]*s[4]+s[7],n=this.view.state,h=[0,0];return n.toMap(h,[i,e]),new $({x:h[0],y:h[1],spatialReference:n.spatialReference})}_ensureTileIndex(t){let s=t.featureIndex;return s||(s=gs.create(t.key,t.layerData,this._styleRepository,this._tileHandler,this.layer),t.featureIndex=s),s}_pauseQueues(){this._fetchQueue.pause(),this._parseQueue.pause()}_resumeQueues(){this._fetchQueue.resume(),this._parseQueue.resume()}_clearQueues(){this._fetchQueue.clear(),this._parseQueue.clear()}};function Ts(t){if(null==t)return 0;switch(t.type){case"partial":return Object.keys(t.diff).length;case"complete":return Math.max(Object.keys(t.oldValue).length,Object.keys(t.newValue).length);case"collection":return Object.keys(t.added).length+Object.keys(t.changed).length+Object.keys(t.removed).length}}H([X()],_s.prototype,"_isTileHandlerReady",void 0),_s=H([W("esri.views.2d.layers.VectorTileLayerView2D")],_s);const Is=_s;export default Is;
//# sourceMappingURL=p-a8fb1766.js.map