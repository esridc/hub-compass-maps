import{cB as t,av as r,jQ as e}from"./p-028496e2.js";import{u as s,f as n,W as a,E as i,a as o,D as l,R as c,b as u,s as m}from"./p-4995a65a.js";import{m as p,S as f,L as d,h}from"./p-5732c3d0.js";import{R as y,i as x}from"./p-a863e0be.js";import{M as P,T as j,e as w}from"./p-1fb2423d.js";import"./p-3b51db5e.js";class b{convertVectorFieldData(t){const r=s.fromJSON(t.pixelBlock),e=n(r,t.type);return Promise.resolve(null!=e?e.toJSON():null)}computeStatisticsHistograms(t){const r=s.fromJSON(t.pixelBlock),e=p(r);return Promise.resolve(e)}async decode(t){const r=await f(t.data,t.options);return r&&r.toJSON()}symbolize(r){r.pixelBlock=s.fromJSON(r.pixelBlock),r.extent=r.extent?t.fromJSON(r.extent):null;const e=this.symbolizer.symbolize(r);return Promise.resolve(null!=e?e.toJSON():null)}async updateSymbolizer(t){this.symbolizer=d.fromJSON(t.symbolizerJSON),t.histograms&&"rasterStretch"===this.symbolizer?.rendererJSON.type&&(this.symbolizer.rendererJSON.histograms=t.histograms)}async updateRasterFunction(t){this.rasterFunction=y(t.rasterFunctionJSON)}async process(e){const n=this.rasterFunction.process({extent:t.fromJSON(e.extent),primaryPixelBlocks:e.primaryPixelBlocks.map((t=>null!=t?s.fromJSON(t):null)),primaryPixelSizes:e.primaryPixelSizes?.map((t=>null!=t?r.fromJSON(t):null)),primaryRasterIds:e.primaryRasterIds});return null!=n?n.toJSON():null}stretch(t){const r=this.symbolizer.simpleStretch(s.fromJSON(t.srcPixelBlock),t.stretchParams);return Promise.resolve(r?.toJSON())}estimateStatisticsHistograms(t){const r=h(s.fromJSON(t.srcPixelBlock));return Promise.resolve(r)}split(t){const r=a(s.fromJSON(t.srcPixelBlock),t.tileSize,t.maximumPyramidLevel??0,!1===t.useBilinear);return r&&r.forEach(((t,e)=>{r.set(e,t?.toJSON())})),Promise.resolve(r)}clipTile(t){const r=s.fromJSON(t.pixelBlock),e=i({...t,pixelBlock:r});return Promise.resolve(e?.toJSON())}async mosaicAndTransform(t){const r=t.srcPixelBlocks.map((t=>t?new s(t):null)),e=o(r,t.srcMosaicSize,{blockWidths:t.blockWidths,alignmentInfo:t.alignmentInfo,clipOffset:t.clipOffset,clipSize:t.clipSize});let n,a=e;return t.coefs&&(a=l(e,t.destDimension,t.coefs,t.sampleSpacing,t.interpolation)),t.projectDirections&&t.gcsGrid&&(n=c(t.destDimension,t.gcsGrid),a=u(a,t.isUV?"vector-uv":"vector-magdir",n)),{pixelBlock:a?.toJSON(),localNorthDirections:n}}async createFlowMesh(t,r){const e={data:new Float32Array(t.flowData.buffer),mask:new Uint8Array(t.flowData.maskBuffer),width:t.flowData.width,height:t.flowData.height},{vertexData:s,indexData:n}=await m(t.meshType,t.simulationSettings,e,r.signal);return{result:{vertexBuffer:s.buffer,indexBuffer:n.buffer},transferList:[s.buffer,n.buffer]}}async getProjectionOffsetGrid(r){const s=t.fromJSON(r.projectedExtent),n=t.fromJSON(r.srcBufferExtent);let a=null;r.datumTransformationSteps&&(a=new e({steps:r.datumTransformationSteps})),(r.includeGCSGrid||P(s.spatialReference,n.spatialReference,a))&&await j();const i=r.rasterTransform?x(r.rasterTransform):null;return w({...r,projectedExtent:s,srcBufferExtent:n,datumTransformation:a,rasterTransform:i})}}export default b;
//# sourceMappingURL=p-ff457548.js.map