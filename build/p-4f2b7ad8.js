import{eC as t,eD as s,eE as i,aH as e,eF as r,eG as n,bl as h,x as o,eH as a,eI as c,eJ as u,cL as l,eK as d,eL as p,dI as f,dJ as m,dK as w,bG as y,ac as g,eM as b,w as I,F as _,eN as x,eh as M,a3 as G,b0 as S,eO as v,a$ as T,eP as j,eQ as A,cA as C,aa as E,r as P,p as V,q as $}from"./p-aad64c9f.js";import{l as R,r as U,Z as F,u as k,W as D,e as z}from"./p-559f4b2d.js";import{c as L}from"./p-682c165c.js";import{M as O,p as X,b as q,n as N,s as H,a as Y}from"./p-fa2632fc.js";import{I as W,y as J,v as K,S as Q,V as Z,u as B,m as tt,x as st,n as it,c as et,d as rt}from"./p-591e796f.js";import{o as nt,h as ht,a as ot}from"./p-875cbb57.js";import{s as at}from"./p-aff89b86.js";import{a as ct}from"./p-2250105d.js";import{x as ut,j as lt}from"./p-e3657bc3.js";import{N as dt}from"./p-2d2f231a.js";async function pt(t,s,i){const e=[],r={scaleInfo:it(t),scaleExpression:null};for(const t of s)switch(t.type){case"marker":if(t.animationParams){e.push(...B(i.instances.animatedMarker,t,st,r));break}e.push(...tt(i.instances.marker,t,st,r));break;case"fill":null==t.spriteRasterizationParam?e.push(...Q(i.instances.fill,t,r)):e.push(...Z(i.instances.complexFill,t,!1,r));break;case"line":t.spriteRasterizationParam?e.push(...J(i.instances.texturedLine,t,!1,r)):e.push(...K(i.instances.line,t,!1,r));break;case"text":e.push(...W(i.instances.text,t,st,r))}return e}class ft extends O{static from(t,s,i){return new ft(t,s,i)}constructor(t,s,i){super(i),this._items=t,this._tile=s,this._index=-1,this._cachedGeometry=null;const e=s.lod;e.wrap&&(this._wrappingInfo={worldSizeX:e.worldSize[0]})}get _current(){return this._items[this._index]}getItem(){return this._current}getZOrder(){return this._current.zOrder}getMeshWriters(){return this._current.symbolResource?.symbolInfo.meshWriters??[]}hasField(t){return null!=this._current.attributes[t]}field(t){return this.readAttribute(t)}get geometryType(){const t=e(this._current.geometry);return"esriGeometryPoint"===t?"esriGeometryMultipoint":t}getCursor(){return this.copy()}copy(){const t=new ft(this._items,this._tile,this.metadata);return this.copyInto(t),t}copyInto(t){super.copyInto(t),t._cachedGeometry=this._cachedGeometry,t._index=this._index}get fields(){throw new Error("Fields reading not supported to graphics.")}get hasFeatures(){return!!this._items.length}get hasNext(){return this._index+1<this._items.length}get exceededTransferLimit(){throw new Error("InternalError: exceededTransferLimit not implemented for graphics.")}get hasZ(){return!1}get hasM(){return!1}getInTransform(){return this._tile.transform}getSize(){return this._items.length}getAttributeHash(){let t="";for(const s in this._current.attributes)t+=this._current.attributes[s];return t}getObjectId(){return this._items[this._index].objectId}getDisplayId(){return this._current.displayId}setDisplayId(t){throw new Error("InternalError: Setting displayId not supported for graphics.")}setIndex(t){this._index=t}getIndex(){return this._index}next(){for(this._cachedGeometry=null;++this._index<this._items.length&&!this._getExists(););return this._index<this._items.length}readGeometryArea(){throw new Error("InternalError: readGeometryArea not supported for graphics.")}_readGeometry(){if(!this._cachedGeometry){let t=nt(this._current.projectedGeometry,this.hasZ,this.hasM);if("esriGeometryPolyline"===this.geometryType&&(t=ht(new at,t,this.hasZ,this.hasM,this.geometryType,this._tile.transform.scale[0])),this._cachedGeometry=ot(new at,t,this.hasZ,this.hasM,this.geometryType,this._tile.transform),!this._cachedGeometry)return null;this._wrapGeometry(this._cachedGeometry)}return this._cachedGeometry}_wrapGeometry(s){if(!this._wrappingInfo)return;const{worldSizeX:i}=this._wrappingInfo;if(s.isPoint)return 1===i?(s.coords.push(t,0),s.coords.push(2*-t,0),void s.lengths.push(3)):2===i?(s.coords.push(2*t,0),s.coords.push(4*-t,0),void s.lengths.push(3)):void this._wrapVertex(s.coords,0,2,i);if("esriGeometryMultipoint"!==this.geometryType);else{if(1===i){const t=s.coords.slice();t[0]-=512;const i=s.coords.slice();i[0]+=512,s.coords.push(...t,...i);const e=s.lengths[0];return void s.lengths.push(e,e)}this._wrapVertex(s.coords,0,2,i)}}_wrapVertex(s,i,e,r){const n=i*e,h=s[n];h<-t*(r-2)?s[n]=h+t*r:h>t*(r-1)&&(s[n]=h-t*r)}_readX(){const t=this._readGeometry();return null!=t?t.coords[0]:0}_readY(){const t=this._readGeometry();return null!=t?t.coords[1]:0}_readServerCentroid(){switch(this.geometryType){case"esriGeometryPolygon":{const t=i(this._current.projectedGeometry),s=new at([],t);return ot(new at,s,this.hasZ,this.hasM,this.geometryType,this._tile.transform)}case"esriGeometryPolyline":{const t=this._current.projectedGeometry,i=s(t.paths,this.hasZ),e=new at([],i);return ot(new at,e,this.hasZ,this.hasM,this.geometryType,this._tile.transform)}}return null}_readAttribute(t,s){const i=this._current.attributes[t];if(void 0!==i)return i;const e=t.toLowerCase();for(const t in this._current.attributes)if(t.toLowerCase()===e)return this._current.attributes[t]}_readAttributes(){return this._current.attributes}}class mt{static fromGraphic(t,s,i,e){return new mt(t.geometry,s,t.attributes,t.visible,t.uid,t.version,i,e)}constructor(t,s,i,e,n,h,o,a){this.geometry=t,this.symbol=s,this.attributes=i,this.visible=e,this.objectId=n,this._version=h,this.zOrder=o,this.displayId=a,this.bounds=r(),this.prevBounds=r(),this.size=[0,0,0,0]}get linearCIM(){return this.symbolResource?.symbolInfo.linearCIM}get hasAnimations(){const{linearCIM:t}=this;return!!t&&t.some((t=>"animationParams"in t&&!!t.animationParams))}update(t,s,i){return(this._version!==t.version||this.zOrder!==i||this.symbol!==s)&&(this.prevBounds=this.bounds,this.bounds=r(),this.zOrder=i,this.geometry=t.geometry,this.attributes=t.attributes,this.symbol=s,this.visible=t.visible,this._version=t.version,this.symbolResource=null,this.projectedGeometry=null,!0)}async projectAndNormalize(t){let s=this.geometry;if(!s||!s.spatialReference||"mesh"===s.type)return;"extent"===s.type&&(s=R(s)),await ut(s.spatialReference,t);const i=ct(s);if(!i)return;const e=lt(i,s.spatialReference,t);e&&n(e),this.projectedGeometry=h(e)?R(e):e}}class wt{constructor(t,s,i){this.added=t,this.updated=s,this.removed=i}hasAnyUpdate(){return!!(this.added.length||this.updated.length||this.removed.length)}}const yt=1e-5;function gt(t,s){return s.zOrder-t.zOrder}class bt{constructor(t,s,i,e,r){this._items=new Map,this._boundsDirty=!1,this._outSpatialReference=t,this._cimResourceManager=s,this._hittestDrawHelper=new U(s),this._tileInfoView=i,this._store=r;const n=i.getClosestInfoForScale(e);this._resolution=this._tileInfoView.getTileResolution(n.level)}destroy(){this._hittestDrawHelper.destroy()}items(){return this._items.values()}getItem(t){return this._items.get(t)}async update(t,s,i){const e=[],r=[],n=[],h=new Set,o=[];let a=0;for(const n of t.items){a++;const t=n.uid,c=this._items.get(t),u=s(n);if(h.add(t),c){c.update(n,u,a)&&(r.push(c),o.push(this._updateItem(c,i)));continue}const l=this._store.createDisplayIdForObjectId(t),d=mt.fromGraphic(n,u,a,l);o.push(this._updateItem(d,i)),this._items.set(d.objectId,d),e.push(d)}for(const[t,s]of this._items.entries())h.has(t)||(this._store.releaseDisplayIdForObjectId(t),this._items.delete(t),n.push(s));return await Promise.all(o),this._index=null,new wt(e,r,n)}updateLevel(t){this._resolution!==t&&(this._index=null,this._boundsDirty=!0,this._resolution=t)}hitTest(t,s,i,e,n){const h=o("esri-mobile"),c=h?f:m,u=c+(h?0:w);t=d(t,this._tileInfoView.spatialReference);const l=e*window.devicePixelRatio*u,p=r();p[0]=t-l,p[1]=s-l,p[2]=t+l,p[3]=s+l;const y=e*window.devicePixelRatio*c,g=r();g[0]=t-y,g[1]=s-y,g[2]=t+y,g[3]=s+y;const b=.5*e*(u+k),I=this._searchIndex(t-b,s-b,t+b,s+b);if(!I||0===I.length)return[];const _=[],x=r(),M=r();for(const t of I){if(!t.visible)continue;const{projectedGeometry:s,symbolResource:i}=t;this._getSymbolBounds(x,i,s,M,n),M[3]=M[2]=M[1]=M[0]=0,a(x,p)&&_.push(t)}if(0===_.length)return[];const G=this._hittestDrawHelper,S=[];for(const t of _){const{projectedGeometry:s,symbolResource:i}=t;if(!i)continue;const{textInfo:r,symbolInfo:h}=i,o=h.cimSymbol;G.hitTest(g,o.symbol,s,r,n,e)&&S.push(t)}return S.sort(gt),S.map((t=>t.objectId))}queryItems(t){return 0===this._items.size?[]:this._searchForItems(t)}clear(){this._items.clear(),this._index=null}async _updateItem(t,s){await t.projectAndNormalize(this._outSpatialReference),await s(t);const{size:i}=t;i[0]=i[1]=i[2]=i[3]=0,this._getSymbolBounds(t.bounds,t.symbolResource,t.projectedGeometry,t.size,0)}_searchIndex(t,s,i,e){return this._boundsDirty&&(this._items.forEach((t=>this._getSymbolBounds(t.bounds,t.symbolResource,t.projectedGeometry,t.size,0))),this._boundsDirty=!1),this._index||(this._index=c(9,(t=>({minX:t.bounds[0],minY:t.bounds[1],maxX:t.bounds[2],maxY:t.bounds[3]}))),this._index.load(Array.from(this._items.values()))),this._index.search({minX:t,minY:s,maxX:i,maxY:e})}_searchForItems(t){const s=this._tileInfoView.spatialReference,i=t.bounds,e=p(s);if(e&&s.isWrappable){const[s,n]=e.valid,h=Math.abs(i[2]-n)<yt,o=Math.abs(i[0]-s)<yt;if((!h||!o)&&(h||o)){const e=t.resolution;let o;o=r(h?[s,i[1],s+e*k,i[3]]:[n-e*k,i[1],n,i[3]]);const a=this._searchIndex(i[0],i[1],i[2],i[3]),c=this._searchIndex(o[0],o[1],o[2],o[3]);return[...new Set([...a,...c])]}}return this._searchIndex(i[0],i[1],i[2],i[3])}_getSymbolBounds(t,s,i,e,n){if(!s||!s.symbolInfo.linearCIM||!i)return null;if(t||(t=r()),u(t,i),!e||0===e[0]&&0===e[1]&&0===e[2]&&0===e[3]){const{textInfo:t,symbolInfo:i}=s,r=i.cimSymbol;e||(e=[0,0,0,0]);const h=F.getSymbolInflateSize(e,r.symbol,this._cimResourceManager,n,t);e[0]=l(h[0]),e[1]=l(h[1]),e[2]=l(h[2]),e[3]=l(h[3])}const h=this._resolution,o=F.safeSize(e);return t[0]-=o*h,t[1]-=o*h,t[2]+=o*h,t[3]+=o*h,t}}class It{static getOrCreate(t,s,i){let e=s.get(t.id);return e||(e=new It(t,i),s.set(t.id,e)),e}static fromItems(t,s,i){const e=new It(t,i);for(const t of s)e.append(t);return e}constructor(t,s){this.tile=t,this.metadata=s,this.addedOrModified=[],this.removed=[],this.objectIdMap=null}get reader(){return this._reader||(this._reader=ft.from(this.addedOrModified,this.tile,this.metadata)),this._reader}append(t){this.addedOrModified.push(t),t.hasAnimations&&(this.objectIdMap=this.objectIdMap||{},this.objectIdMap[t.displayId]=t.objectId)}}let _t=class extends(y(g)){constructor(t){super(t),this._attached=!1,this._tiles=new Map,this._controller=new AbortController,this._hashToSymbolInfo=new Map,this._lastCleanup=performance.now(),this._cleanupRequired=!0,this.lastUpdateId=-1,this.renderer=null,this._updateTracking=new dt({debugName:"GraphicsView2D"}),this.updateRequested=!1,this.defaultPointSymbolEnabled=!0,this._commandQueue=new et({process:t=>{if("update"===t.type)return this._update();throw new Error("InternalError: Unsupported command")}}),this.graphicUpdateHandler=this.graphicUpdateHandler.bind(this)}destroy(){this.container.destroy(),this.view=null,this.renderer=null,this._set("graphics",null),this._controller.abort(),this._graphicStore.clear(),this._graphicStore.destroy(),this._attributeStore=null,this._hashToSymbolInfo.clear(),this._updateTracking.destroy(),this._commandQueue.destroy()}_initAttributeStore(){this._storage=new X({spatialReference:this.view.spatialReference,fields:new b}),this._attributeStore=new q({isLocal:!0,update:t=>{o("esri-2d-update-debug")&&console.debug(`[Id: ${this.layerId}] GraphicsView2D.AttributeStoreView.updateStart`,{message:t}),this.container.attributeView.requestUpdate(t),this.container.requestRender(),o("esri-2d-update-debug")&&console.debug(`[Id: ${this.layerId}] GraphicsView2D.AttributeStoreView.updateEnd`,{message:t})}});const t=rt(null,[]);this._attributeStore.update(t,this._storage,null),this.container.checkHighlight=()=>this._attributeStore.hasHighlight}initialize(){this._initAttributeStore(),this._metadata=N.createGraphics(this.view.spatialReference),this._resourceProxy=new H({fetch:t=>Promise.all(t.map((t=>this.view.stage.textureManager.rasterizeItem(t)))),fetchDictionary:t=>{throw new Error("InternalError: Graphics do not support Dictionary requests")}}),this.addHandles([I((()=>this._effectiveRenderer),(()=>this._pushUpdate())),this.view.graphicsTileStore.on("update",this._onTileUpdate.bind(this)),this.container.on("attach",(()=>{this.addHandles([this.graphics.on("change",(()=>this._pushUpdate()))]),this._graphicStore?.destroy(),this._graphicStore=new bt(this.view.spatialReference,this._cimResourceManager,this.view.featuresTilingScheme,this.view.state.scale,this._attributeStore),this._attached=!0,this.requestUpdate(),this._pushUpdate()}))]),this._updateTracking.addUpdateTracking("CommandQueue",this._commandQueue.updateTracking);const t=this.view.graphicsTileStore.tiles;this._onTileUpdate({added:t,removed:[]})}get _effectiveRenderer(){return"function"==typeof this.renderer?this.renderer():this.renderer}get _cimResourceManager(){return this.view.stage.textureManager.resourceManager}get updating(){const t=!this._attached||this._updateTracking.updating;return o("esri-2d-log-updating")&&console.log(`Updating GraphicsView2D: ${t}\n  -> attaching ${!this._attached}\n  -> updateTracking ${this._updateTracking.updating}`),t}hitTest(t){if(!this.view||this.view.suspended)return[];const{resolution:s,rotation:i}=this.view.state,e=this._graphicStore.hitTest(t.x,t.y,2,s,i),r=new Set(e),n=this.graphics.items.reduce(((t,s)=>(r.has(s.uid)&&t.set(s.uid,s),t)),new Map);return e.map((t=>n.get(t))).filter(_)}requestUpdate(){this.updateRequested||(this.updateRequested=!0,this.requestUpdateCallback()),this.notifyChange("updating")}processUpdate(t){this.updateRequested&&(this.updateRequested=!1,this.update(t))}viewChange(){this.requestUpdate()}setHighlight(t){const s=[];for(const{objectId:i,highlightFlags:e}of t){const t=this._graphicStore.getItem(i)?.displayId;s.push({objectId:i,highlightFlags:e,displayId:t})}this._attributeStore.setHighlight(s,t),this._pushUpdate()}graphicUpdateHandler(t){this._pushUpdate()}update(t){this.updateRequested=!1,this._attached&&this._graphicStore.updateLevel(t.state.resolution)}pushUpdate(){this._pushUpdate()}_pushUpdate(){x(this._commandQueue.push({type:"update"}))}async _update(){try{o("esri-2d-update-debug")&&console.debug(`[Id: ${this.layerId}] GraphicsView._update start`);const t=await this._graphicStore.update(this.graphics,(t=>this._getSymbolForGraphic(t)),(t=>this._ensureSymbolResource(t)));for(const s of t.updated)this.container.restartAnimation(s.objectId);if(!t.hasAnyUpdate())return void this._attributeStore.sendUpdates();t.removed.length&&(this._cleanupRequired=!0),o("esri-2d-update-debug")&&console.debug(`[Id: ${this.layerId}] GraphicsView updateMessage`,t);const s=this._createTileMessages(t);await this._fetchResources(s),this._write(s);for(const s of t.added)this._setFilterState(s);for(const s of t.updated)this._setFilterState(s);o("esri-2d-update-debug")&&console.debug(`[Id: ${this.layerId}] GraphicsView sendUpdate`,t),this._attributeStore.sendUpdates(),o("esri-2d-update-debug")&&console.debug(`[Id: ${this.layerId}] GraphicsView sendUpdate.await`,t)}catch(t){}this._cleanupSharedResources()}_createTileMessages(t){const s=new Map;for(const i of t.added){const t=this.view.graphicsTileStore.getIntersectingTiles(i.bounds);for(const e of t){It.getOrCreate(e,s,this._metadata).append(i)}}for(const i of t.updated){const t=this.view.graphicsTileStore.getIntersectingTiles(i.prevBounds),e=this.view.graphicsTileStore.getIntersectingTiles(i.bounds);for(const e of t){It.getOrCreate(e,s,this._metadata).removed.push(i.displayId)}for(const t of e){It.getOrCreate(t,s,this._metadata).append(i)}}for(const i of t.removed){const t=this.view.graphicsTileStore.getIntersectingTiles(i.bounds);for(const e of t){It.getOrCreate(e,s,this._metadata).removed.push(i.displayId)}}return Array.from(s.values())}async _fetchResources(t){for(const{tile:s,reader:i}of t){o("esri-2d-update-debug")&&console.debug(`Id[${this.layerId}] Tile[${s.id}] GraphicsView fetchResources`,t);const e=i.getCursor();for(;e.next();)for(const t of e.getMeshWriters())t.enqueueRequest(this._resourceProxy,e,s.createArcadeEvaluationOptions(this.view.timeZone))}await this._resourceProxy.fetchEnqueuedResources()}_write(t){for(const s of t){o("esri-2d-update-debug")&&console.debug(`Id[${this.layerId}] Tile[${s.tile.id}] GraphicsView write`,s);const t=this._writeMeshes(s);let i=this._tiles.get(s.tile.key);i||(i=this._createFeatureTile(s.tile.key)),o("esri-2d-update-debug")&&console.debug(`Id[${this.layerId}] Tile[${s.tile.id}] GraphicsView onTileData`,s),this.container.onTileData(i,{type:"update",modify:t,remove:s.removed,end:!1,attributeEpoch:this._attributeStore.epoch,objectIdMap:s.objectIdMap}),this.container.requestRender()}}_writeMeshes(t){const s=new Y(t.tile.id),i=t.reader.getCursor();for(;i.next();){s.entityStart(i.getDisplayId(),i.getZOrder());for(const e of i.getMeshWriters())e.write(s,this._resourceProxy,i,t.tile.createArcadeEvaluationOptions(this.view.timeZone),t.tile.level);s.entityEnd()}return{...s.serialize().message,tileId:t.tile.id}}_setFilterState(t){const s=t.displayId,i=this._attributeStore.getHighlightFlags(t.objectId);this._attributeStore.setData(s,0,0,i|(t.visible?M:0))}_getSymbolForGraphic(t){return null!=t.symbol?t.symbol:null!=this._effectiveRenderer?this._effectiveRenderer.getSymbol(t):this._getNullSymbol(t)}async _ensureSymbolResource(t){if(!t.symbol)return;const s=await this._getSymbolInfo(t.symbol);if(!s)return;const i=s.linearCIM.filter((t=>"text"===t.type));if(i.length>0){const e=await this._getTextResources(t,i);t.symbolResource={symbolInfo:s,textInfo:e}}else t.symbolResource={symbolInfo:s}}_getSymbolInfo(t){const s=t.hash();return this._hashToSymbolInfo.has(s)||this._hashToSymbolInfo.set(s,this._createSymbolInfo(s,t).catch((t=>null))),this._hashToSymbolInfo.get(s)}async _createSymbolInfo(t,s){const i=await this._convertToCIMSymbol(s),e=await this._createLinearCIM(i);return{hash:t,cimSymbol:i,linearCIM:e,meshWriters:await this._createMeshWriters(i,e)}}async _convertToCIMSymbol(t){const s=D(t);if("web-style"===s.type){return(await s.fetchCIMSymbol()).data}return s}async _createLinearCIM(t){return await Promise.all(z.fetchResources(t.symbol,this._cimResourceManager,[])),this.view.stage.cimAnalyzer.analyzeSymbolReference(t,!1)}async _createMeshWriters(t,s){G(this._controller.signal);const i=this.container.instanceStore,e=this.view.stage.meshWriterRegistry,r=await pt(t,s,i);return Promise.all(r.map((t=>e.createMeshWriter(this._storage,this._resourceProxy,{tileInfo:this.view.featuresTilingScheme.tileInfo},t))))}_onTileUpdate(t){if(t.added&&t.added.length>0)for(const s of t.added)this._updateTracking.addPromise(this._addTile(s));if(t.removed&&t.removed.length>0)for(const s of t.removed)this._removeTile(s.key)}_createFeatureTile(t){const s=this.view.featuresTilingScheme.getTileBounds(r(),t),i=this.view.featuresTilingScheme.getTileResolution(t.level),e=new L(t,i,s[0],s[3]);return this._tiles.set(t,e),this.container.addChild(e),e}async _addTile(t){if(!this._attached)return;const s=this._graphicStore.queryItems(t);if(!s.length)return;const i=this._createFeatureTile(t.key),e=It.fromItems(t,s,this._metadata);await this._fetchResources([e]);const r=this._writeMeshes(e);i.onMessage({type:"append",append:r,clear:!1,end:!0,attributeEpoch:this._attributeStore.epoch,objectIdMap:e.objectIdMap})}_removeTile(t){if(!this._tiles.has(t))return;const s=this._tiles.get(t);this.container.removeChild(s),s.destroy(),this._tiles.delete(t)}_getNullSymbol(t){const s=t.geometry;return S(s)?v:T(s)||h(s)?j:this.defaultPointSymbolEnabled?A:null}async _getTextResources(t,s){const i=new Array,r=new Array;for(let n=0;n<s.length;n++){const h=s[n],{resource:o,overrides:a}=h.textRasterizationParam;if(a?.length>0){const s=C.resolveSymbolOverrides({type:"CIMSymbolReference",primitiveOverrides:a,symbol:{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,size:o.symbol.height,anchorPointUnits:"Relative",frame:{xmin:-5,ymin:-5,xmax:5,ymax:5},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:o.symbol,textString:o.textString}],scaleSymbolsProportionally:!0,respectFrame:!0}]}},t,this.view.spatialReference,null,e(t.projectedGeometry),null,null);s.then((t=>{const s=t.symbolLayers[0],{textString:i}=s.markerGraphics[0];r.push({type:"cim-rasterization-info",resource:{type:"text",textString:i||"",font:o.font}}),h.text=o.textString=i||""})),i.push(s)}else r.push({type:"cim-rasterization-info",resource:o})}i.length>0&&await Promise.all(i);const n=r.map((t=>this.view.stage.textureManager.rasterizeItem(t))),h=await Promise.all(n);E(h);const o=new Map;for(let t=0;t<s.length;t++){const i=s[t];o.set(i.textRasterizationParam.resource.symbol,{text:i.text,glyphMosaicItems:h[t]})}return o}_cleanupSharedResources(){if(!this._cleanupRequired)return;const t=performance.now();if(t-this._lastCleanup<5e3)return;this._cleanupRequired=!1,this._lastCleanup=t;const s=new Set;for(const t of this._graphicStore.items()){const i=t.symbolResource?.symbolInfo.hash;s.add(i)}const i=new Set(this._hashToSymbolInfo.keys());for(const t of i.values())s.has(t)||this._hashToSymbolInfo.delete(t)}};P([V()],_t.prototype,"_effectiveRenderer",null),P([V({constructOnly:!0})],_t.prototype,"layerId",void 0),P([V({constructOnly:!0})],_t.prototype,"requestUpdateCallback",void 0),P([V()],_t.prototype,"container",void 0),P([V({constructOnly:!0})],_t.prototype,"graphics",void 0),P([V()],_t.prototype,"renderer",void 0),P([V()],_t.prototype,"_updateTracking",void 0),P([V()],_t.prototype,"updating",null),P([V()],_t.prototype,"view",void 0),P([V()],_t.prototype,"updateRequested",void 0),P([V()],_t.prototype,"defaultPointSymbolEnabled",void 0),_t=P([$("esri.views.2d.layers.graphics.GraphicsView2D")],_t);const xt=_t;export{xt as F};
//# sourceMappingURL=p-4f2b7ad8.js.map