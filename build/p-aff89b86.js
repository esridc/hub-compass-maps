const t=2;class s{constructor(t=[],s=[]){this.lengths=t??[],this.coords=s??[]}static fromJSON(t){return new s(t.lengths,t.coords)}static fromRect(t){const[e,r,i,h]=t,n=i-e,o=h-r;return new s([5],[e,r,n,0,0,o,-n,0,0,-o])}get isPoint(){return 0===this.lengths.length&&this.coords.length>=2}get maxLength(){return Math.max(...this.lengths)}get size(){return this.lengths.reduce(((t,s)=>t+s))}forEachVertex(s){let e=0;this.lengths.length||s(this.coords[0],this.coords[1]);for(let r=0;r<this.lengths.length;r++){const i=this.lengths[r];for(let r=0;r<i;r++){s(this.coords[t*(r+e)],this.coords[t*(r+e)+1])}e+=i}}deltaDecode(){const t=this.clone(),{coords:s,lengths:e}=t;let r=0;for(const t of e){for(let e=1;e<t;e++)s[2*(r+e)]+=s[2*(r+e)-2],s[2*(r+e)+1]+=s[2*(r+e)-1];r+=t}return t}clone(e){if(0===this.lengths.length)return new s([],[this.coords[0],this.coords[1]]);const r=(0===this.lengths.length?1:this.lengths.reduce(((t,s)=>t+s)))*t,i=this.coords.slice(0,r);return e?(e.set(i),new s(this.lengths,e)):new s(Array.from(this.lengths),Array.from(i))}}export{s};
//# sourceMappingURL=p-aff89b86.js.map