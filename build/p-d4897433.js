import{kV as t,kM as i,kN as e,kX as s,iP as a,az as n,E as o,s as r,w as h,iM as l,n as c,hP as d,a3 as u,oC as p,a0 as f,c2 as y,r as w,p as L,q as m}from"./p-aad64c9f.js";import{o as C}from"./p-875cbb57.js";import{s as g}from"./p-aff89b86.js";import{u as O,E as I,o as A,A as E,a as R,s as M,b,n as N,d as v,e as G,t as k,r as _,c as T,f as j,v as P,L as D,m as S,h as H,g as x,i as U}from"./p-e58b8b4b.js";import{F}from"./p-08eca8f5.js";import"./p-2af77f97.js";import"./p-da522976.js";import"./p-d492d39b.js";import"./p-f590152b.js";import"./p-a1bf330d.js";import"./p-339b5e24.js";import"./p-56b85bad.js";import"./p-5ae33da2.js";import"./p-1c285990.js";import"./p-e3657bc3.js";import"./p-bac7b09c.js";import"./p-e2849960.js";import"./p-02236077.js";import"./p-cea3971b.js";import"./p-4295487d.js";import"./p-1317d6d9.js";import"./p-bdd45e95.js";import"./p-ca379176.js";import"./p-85c76b3c.js";import"./p-4c90e3f2.js";import"./p-e33d4456.js";var z;!function(t){t.MULTIPLIER="multiplier",t.ABSOLUTE="absoluteValue"}(z||(z={}));let B=class extends(t(i(e(s(a))))){constructor(t){if(super(t),this.dataPreloadedInLocalCache=!1,this.defaultLinkChartConfig=null,this._currentLinkChartConfig={layoutMode:"RADIAL_TREE"},this._graphTypeLookup=new Map,this.dataManager=null,this.knowledgeGraph=null,this.layers=new(n.ofType(O)),this.entityLinkChartDiagramLookup=new Map,this.relationshipLinkChartDiagramLookup=new Map,this.linkChartExtent=new o({xmin:-1e-7,ymin:-1e-7,xmax:1e-7,ymax:1e-7}),this.memberEntityTypes=null,this.memberRelationshipTypes=null,this.operationalLayerType="LinkChartLayer",this.sublayerIdsCache=new Map,this.tables=new(n.ofType(O)),this.type="link-chart",this.chronologicalAuxiliaryGraphics=null,this._originalInclusionList=t?.inclusionModeDefinition,t?.dataPreloadedInLocalCache&&!t?.inclusionModeDefinition)throw new r("knowledge-graph:linkchart-layer-constructor","If creating a link chart composite layer and configured that data is already loaded in the cache, you must specify an inclusion list so the Composite Layer knows what records belong to it");this.addHandles(h((()=>this.layers.concat(this.tables)),((t,i)=>this._handleSublayersChange(t,i)),l))}normalizeCtorArgs(t){if(!t)return{};const{url:i,title:e,dataPreloadedInLocalCache:s,defaultLinkChartConfig:a}=t;return{url:i,title:e,dataPreloadedInLocalCache:s,defaultLinkChartConfig:a}}_initializeLayerProperties(t){if(!this.title&&this.url){const t=this.url.split("/");this.title=t[t.length-2]}const i=new Set;let e=[],s=[];if(t.inclusionModeDefinition&&(!t.inclusionModeDefinition.namedTypeDefinitions||t.inclusionModeDefinition.namedTypeDefinitions.size<1))throw new r("knowledge-graph:composite-layer-constructor","If an explicit inclusion definition is defined, at least one namedTypeDefinition must also be defined");t.knowledgeGraph.dataModel.entityTypes?.forEach((t=>{t.name&&this._graphTypeLookup.set(t.name,t)})),t.knowledgeGraph.dataModel.relationshipTypes?.forEach((t=>{t.name&&this._graphTypeLookup.set(t.name,t)})),t.inclusionModeDefinition?.generateAllSublayers?(e=t.knowledgeGraph.dataModel.entityTypes??[],s=t.knowledgeGraph.dataModel.relationshipTypes??[]):t.inclusionModeDefinition?.namedTypeDefinitions&&t.inclusionModeDefinition?.namedTypeDefinitions.size>0?t.inclusionModeDefinition?.namedTypeDefinitions.forEach(((a,n)=>{const o=this._graphTypeLookup.get(n);if(!o)return c.getLogger(this).warn(`A named type, ${n}, was in the inclusion list that wasn't in the data model and will be removed`),void t.inclusionModeDefinition?.namedTypeDefinitions.delete(n);"relationship"===o.type?i.has(n)||(i.add(n),s.push(o)):"entity"===o.type?i.has(n)||(i.add(n),e.push(o)):(c.getLogger(this).warn(`A named type, ${n}, was in the inclusion list that wasn't properly modeled and will be removed`),t.inclusionModeDefinition?.namedTypeDefinitions.delete(n))})):(e=t.knowledgeGraph.dataModel.entityTypes??[],s=t.knowledgeGraph.dataModel.relationshipTypes??[]);const a=new I({knowledgeGraph:t.knowledgeGraph,inclusionModeDefinition:t.inclusionModeDefinition});this.knowledgeGraph=t.knowledgeGraph,this.memberEntityTypes=e,this.memberRelationshipTypes=s,this.dataManager=a}load(t){const i=async()=>{const t=[],i=[];this.loadLayerAssumingLocalCache(),await T(this),this.dataManager.inclusionModeDefinition&&(this.dataManager.inclusionModeDefinition.generateAllSublayers=!1),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach((t=>{t.useAllData=!1})),await this._initializeDiagram(),this.layers.forEach((e=>{i.push(e.refreshCachedQueryEngine()),t.push(new Promise((t=>{e.on("layerview-create",(()=>{t(null)}))})))})),this.tables.forEach((t=>{i.push(t.refreshCachedQueryEngine())})),await Promise.all(i)};return this.addResolvingPromise(new Promise((e=>{F(this.url).then((async s=>{if(this._initializeLayerProperties({knowledgeGraph:s,inclusionModeDefinition:this._originalInclusionList}),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.size||(this.dataManager.inclusionModeDefinition={generateAllSublayers:!1,namedTypeDefinitions:new Map},this.dataManager.knowledgeGraph.dataModel.entityTypes?.forEach((t=>{t.name&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(t.name,{useAllData:!0})})),this.dataManager.knowledgeGraph.dataModel.relationshipTypes?.forEach((t=>{t.name&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(t.name,{useAllData:!0})}))),this.dataPreloadedInLocalCache){const t=A.getInstance();for(const[i,e]of this.dataManager.inclusionModeDefinition?.namedTypeDefinitions??[])for(const s of e.members?.values()??[]){const e=t.readFromStoreById(`${i}__${s.id}`);if(e){d(this.dataManager.sublayerCaches,i,(()=>new Map)).set(s.id,e)}}await i()}else{const e="GEOGRAPHIC"===this.defaultLinkChartConfig?.layoutMode;this.addResolvingPromise(this.dataManager.refreshCacheContent(void 0,!1,e,!0).then((async()=>{u(t),await i()})))}e(null)}))}))),Promise.resolve(this)}set inclusionModeDefinition(t){"loaded"!==this.loadStatus&&"failed"!==this.loadStatus?this._set("inclusionModeDefinition",t):c.getLogger(this).error("#inclusionModeDefinition","inclusionModeDefinition cannot be changed after the layer is loaded.")}async addRecords(t,i){let e=[];i?.cascadeAddRelationshipEndNodes&&this.dataManager.knowledgeGraph.dataModel&&(e=await E(t,this.dataManager.knowledgeGraph));const s=t.concat(e).filter((t=>!this.sublayerIdsCache.get(t.typeName)?.has(t.id)));await this._handleNewRecords(s)}async removeRecords(t,{cascadeRemoveRelationships:i=!0,recalculateLayout:e=!1}={cascadeRemoveRelationships:!0,recalculateLayout:!1}){let s=[];for(const i of t)!1===this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(i.typeName)?.useAllData&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(i.typeName)?.members?.has(i.id)&&s.push(i);if(i){const t=new Set,i=[];for(const i of s)if(this.dataManager.nodeConnectionsLookup.has(i.id))for(const e of this.dataManager.nodeConnectionsLookup.get(i.id))t.add(e);for(const e of t)if(this.dataManager.memberIdTypeLookup.has(e))for(const t of this.dataManager.memberIdTypeLookup.get(e))this.dataManager.relationshipTypeNames.has(t)&&i.push({id:e,typeName:t});s=s.concat(i)}this.dataManager.removeFromLayer(s);for(const t of s)this.sublayerIdsCache.get(t.typeName)?.delete(t.id),this.dataManager.relationshipTypeNames.has(t.typeName)?this.relationshipLinkChartDiagramLookup.delete(t.id):this.entityLinkChartDiagramLookup.delete(t.id);e&&await this._calculateLayoutWithSublayerTimeInfo(this._currentLinkChartConfig.layoutMode,this._currentLinkChartConfig.layoutOptions);const a=[];return this.layers.forEach((t=>{a.push(t.refreshCachedQueryEngine())})),await Promise.all(a),this._refreshNamedTypes(),s}async expand(t,i){const e=await this.dataManager.getConnectedRecordIds(t,i),s=e.filter((t=>!this.sublayerIdsCache.get(t.typeName)?.has(t.id)));return await this._handleNewRecords(e),{records:s}}loadLayerAssumingLocalCache(){const t=[...this.memberRelationshipTypes,...this.memberEntityTypes];this.originIdOf("layers")===p.DEFAULTS?this._createSublayers(t,this.layers,(t=>!!t.geometryType)):this._updateSublayers(t,this.layers),this.originIdOf("tables")===p.DEFAULTS?this._createSublayers(t,this.tables,(t=>!t.geometryType)):this._updateSublayers(t,this.tables),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach(((t,i)=>{const e=d(this.sublayerIdsCache,i,(()=>new Set));t.members?.forEach((({id:t,linkChartLocation:s})=>{if(e.add(t),s){const e=s instanceof g?s:C(s);this.dataManager.relationshipTypeNames.has(i)?this.relationshipLinkChartDiagramLookup.set(t,e):this.entityLinkChartDiagramLookup.set(t,e)}}))}))}async calculateLinkChartLayout(t="RADIAL_TREE",i){const e=[],s=[],a=[];this.dataManager.sublayerCaches.forEach(((t,i)=>{this.dataManager.entityTypeNames.has(i)?t.forEach((t=>{e.push({typeName:i,feature:t})})):this.dataManager.relationshipTypeNames.has(i)&&t.forEach((t=>{s.push({typeName:i,feature:t})}))})),this.entityLinkChartDiagramLookup=new Map,this.relationshipLinkChartDiagramLookup=new Map;const n=new Map,h=new Map,l=new Map,d=new Map,u=new Uint8Array(e.length),p=new Float64Array(e.length),w=new Float64Array(e.length),L=new Float64Array(e.length),m=new Float64Array(e.length),g=new Uint32Array(s.length),O=new Uint32Array(s.length),I=new Float64Array(s.length),A=new Float64Array(s.length),E=[],T="FORCE_DIRECTED",F=new o({xmin:-1e-7,ymin:-1e-7,xmax:1e-7,ymax:1e-7});let z,B="FORCE_DIRECTED",$=0,W=0;const q=j.apply;switch(B="GEOGRAPHIC"===t?T:t,B){case"FORCE_DIRECTED":z=U.apply;break;case"COMMUNITY":z=x.apply;break;case"HIERARCHICAL":z=H.apply;break;case"RADIAL_TREE":z=S.apply;break;case"SMART_TREE":z=D.apply;break;default:z=P.apply}let V=!1;e.forEach((({typeName:e,feature:s})=>{if("CHRONOLOGICAL_SINGLE"!==t&&"CHRONOLOGICAL_MULTIPLE"!==t&&i?.lockedNodeLocations?.has(s.attributes[R])){"GEOGRAPHIC"===t&&this.dataManager.geographicLookup.has(e)?u[$]=M.IsGeographic:u[$]=M.None;const a=i.lockedNodeLocations.get(s.attributes[R]);p[$]=a.x,w[$]=a.y}else if("GEOGRAPHIC"===t&&this.dataManager.geographicLookup.has(e)){u[$]=M.IsGeographic;let t=null;const i=s.attributes[this.dataManager.geographicLookup.get(e).name],a=this.dataManager.geographicLookup.get(e)?.geometryType;switch(a){case"esriGeometryPoint":p[$]=i?.x,w[$]=i?.y;break;case"esriGeometryPolygon":t=i?.centroid,null!=t?.x&&null!=t?.y?(p[$]=t.x,w[$]=t.y):u[$]=M.IsMovable;break;case"esriGeometryPolyline":case"esriGeometryMultipoint":t=i?.extent?.center,null!=t?.x&&null!=t?.y?(p[$]=t.x,w[$]=t.y):u[$]=M.IsMovable;break;default:u[$]=M.IsMovable}(null==p[$]||null==w[$]||Number.isNaN(p[$])||Number.isNaN(w[$]))&&(u[$]=M.IsMovable,p[$]=0,w[$]=0)}else if("CHRONOLOGICAL_SINGLE"===t||"CHRONOLOGICAL_MULTIPLE"===t){!V&&i?.lockedNodeLocations?.has(s.attributes[R])&&(V=!0);const t=i?.timeInfoByTypeName?.get(e),a=t?.startField,n=a&&t?.startField?s.attributes[a]:null;L[$]=n?new Date(n).getTime():NaN;const o=t?.endField,r=o&&t?.endField?s.attributes[o]:null;m[$]=r?new Date(r).getTime():NaN,p[$]=0,w[$]=0,u[$]=M.IsMovable}else u[$]=M.IsMovable,p[$]=0,w[$]=0;d.set(s.attributes[R],$),E[$]={feature:s,typeName:e},$++})),V&&c.getLogger(this).warn("Locked node locations are not supported for chronological layout at this time.  Requested node locations were ignored");let Y=!1;const X=new Map;s.forEach((e=>{const s=e.feature.attributes[k],n=e.feature.attributes[_],o=d.get(s),r=d.get(n),h=i?.timeInfoByTypeName?.get(e.typeName),l=i?.timeInfoByTypeName?h?.startField:null,c=l?e.feature.attributes[l]:null,u=h?.endField,p=u?e.feature.attributes[u]:null;if(void 0!==o&&void 0!==r){let i=s+"-"+n;"CHRONOLOGICAL_SINGLE"!==t&&"CHRONOLOGICAL_MULTIPLE"!==t||(i=i+"-"+c+"-"+p);const h=X.get(i),l=h?.has(e.typeName);l||(g[W]=o,O[W]=r,"CHRONOLOGICAL_SINGLE"!==t&&"CHRONOLOGICAL_MULTIPLE"!==t||(I[W]=c?new Date(c).getTime():NaN,A[W]=p?new Date(p).getTime():NaN),void 0===h?X.set(i,new Map([[e.typeName,W]])):h.set(e.typeName,W),W++),a.push(e)}else Y=!0,this.relationshipLinkChartDiagramLookup.set(s,null)})),Y&&c.getLogger(this).warn("A relationship is a member of this layer that has either origin or destination entity nodes that are not members. The diagram geometry will be set to null");const J=this._validateLayoutSettings(t,i),K=this._convertLayoutSettingsToCalculationSettings(J);await b();let Q=!1,Z=null;if("CHRONOLOGICAL_SINGLE"===t||"CHRONOLOGICAL_MULTIPLE"===t){let e;({success:Q,links:Z,graphics:e}=q(u,p,w,L,m,g.subarray(0,W),O.subarray(0,W),I.subarray(0,W),A.subarray(0,W),"CHRONOLOGICAL_MULTIPLE"===t,i?.chronologicalLayoutSettings??{})),Q&&(this.chronologicalAuxiliaryGraphics=e)}else({success:Q,links:Z}=z(u,p,w,g.subarray(0,W),O.subarray(0,W),K.computationBudgetTime,K.idealEdgeLengthMultiplier,K.repulsionRadiusMultiplier));if(!Q)throw new r("knowledge-graph:layout-failed","Attempting to arrange the records in the specified layout failed");for(let t=0;t<E.length;t++){if(w[t]>84.9999?w[t]=84.9999:w[t]<-84.9999&&(w[t]=-84.9999),p[t]>179.9999?p[t]=179.9999:p[t]<-179.9999&&(p[t]=-179.9999),E[t].feature.attributes[N]=new f(p[t],w[t]),n.has(E[t].typeName)){const i=n.get(E[t].typeName);i?.set(E[t].feature.attributes[R],E[t].feature)}else{const i=new Map;i.set(E[t].feature.attributes[R],E[t].feature),n.set(E[t].typeName,i)}l.set(E[t].feature.attributes[R],E[t].feature);const i=C(E[t].feature.attributes[N]);this.entityLinkChartDiagramLookup.set(E[t].feature.attributes[R],E[t].feature.attributes[N]?i:null),E[t].feature.attributes[N].x<F.xmin&&(F.xmin=E[t].feature.attributes[N].x),E[t].feature.attributes[N].x>F.xmax&&(F.xmax=E[t].feature.attributes[N].x),E[t].feature.attributes[N].y<F.ymin&&(F.ymin=E[t].feature.attributes[N].y),E[t].feature.attributes[N].y>F.ymax&&(F.ymax=E[t].feature.attributes[N].y)}if(this.linkChartExtent.xmin=F.xmin,this.linkChartExtent.xmax=F.xmax,this.linkChartExtent.ymin=F.ymin,this.linkChartExtent.ymax=F.ymax,!Z)throw new r("knowledge-graph:layout-failed","Attempting to retrieve link geometry from diagram engine failed");const tt=new Map,it=new Map,et=new Map,st=new Set;for(let e=0;e<a.length;e++){const s=[],n=a[e],o=n.feature.attributes[k],r=n.feature.attributes[_];let u=o+"-"+r;if("CHRONOLOGICAL_SINGLE"===t||"CHRONOLOGICAL_MULTIPLE"===t){const t=i?.timeInfoByTypeName?.get(n.typeName),e=i?.timeInfoByTypeName?t?.startField:null,s=e?n.feature.attributes[e]:null,a=t?.endField;u+="-"+s+"-"+(a?n.feature.attributes[a]:null)}const p=X.get(u).get(n.typeName),f=0===p?0:Z?.vertexEndIndex[p-1];if(!st.has(p)){if(st.add(p),Z.types[p]===v.Recursive){const t=[Z.vertices[2*f],Z.vertices[2*f+1]],i=[Z.vertices[2*(f+1)],Z.vertices[2*(f+1)+1]],e=[.5*(t[0]+i[0]),.5*(t[1]+i[1])],a=[e[0]-t[0],e[1]-t[1]],n=[e[0]+a[1],e[1]-a[0]],o=[e[0]-a[1],e[1]+a[0]];s.push(t),s.push(n),s.push(i),s.push(o),s.push(t)}else{if(Z.types[p]!==v.Regular){c.getLogger(this).warn("A relationship generated an unsupported link geometry type.  It will not be rendered");continue}for(let t=f;t<Z.vertexEndIndex[p];t++)s.push([Z.vertices[2*t],Z.vertices[2*t+1]])}if("CHRONOLOGICAL_SINGLE"!==t&&"CHRONOLOGICAL_MULTIPLE"!==t){const t=E[d.get(o)]?.feature.attributes[N],i=E[d.get(r)]?.feature.attributes[N];s[0][0]===t.x&&s[0][1]===t.y||(s[0]=[t.x,t.y]),s[s.length-1][0]===i.x&&s[s.length-1][1]===i.y||(s[s.length-1]=[i.x,i.y])}for(let t=1;t<s.length-1;t++)s[t][1]>85.5?s[t][1]=85.5:s[t][1]<-85.5&&(s[t][1]=-85.5),s[t][0]>179.9999?s[t][0]=179.9999:s[t][0]<-179.9999&&(s[t][0]=-179.9999);tt.has(u)?tt.get(u).push(s):tt.set(u,[s])}const w=tt.get(u);it.has(u)||(it.set(u,new Map),et.set(u,new Map));const L=it.get(u),m=et.get(u);L.has(n.typeName)||(L.set(n.typeName,w.shift()),m.set(n.typeName,0));const g=L.get(n.typeName);m.set(n.typeName,m.get(n.typeName)+1);const O=new y({paths:[g]});if(n.feature.attributes[N]=O,h.has(n.typeName)){const t=h.get(n.typeName);t?.set(n.feature.attributes[R],n.feature)}else{const t=new Map;t.set(n.feature.attributes[R],n.feature),h.set(n.typeName,t)}l.set(n.feature.attributes[R],n.feature);const I=C(n.feature.attributes[N]);this.relationshipLinkChartDiagramLookup.set(n.feature.attributes[R],n.feature.attributes[N]?I:null)}for(const t of a)t.feature.attributes[G]=et.get(t.feature.attributes[k]+"-"+t.feature.attributes[_])?.get(t.typeName)??null;return this._currentLinkChartConfig={layoutMode:t,layoutOptions:J},{nodes:n,links:h,idMap:l}}async applyNewLinkChartLayout(t="RADIAL_TREE",i){const e=[];await this._calculateLayoutWithSublayerTimeInfo(t,i),this.layers.forEach((t=>{e.push(t.refreshCachedQueryEngine())})),await Promise.all(e),this._refreshNamedTypes()}getCurrentNodeLocations(){const t=new Map;return this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((i=>{i?.members?.forEach((i=>{const e=i.linkChartLocation;let s;const a=i.id;e&&(s="x"in e?{x:e.x,y:e.y}:{x:e.coords[0],y:e.coords[1]},t.set(a,new f({x:s.x,y:s.y})))}))})),t}async synchronizeInclusionListWithCache(){return new Promise((t=>{this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach(((t,i)=>{if(t.useAllData=!1,t.members&&t.members.size>0){if(!this.dataManager.sublayerCaches.get(i))return;const e=new Set(Array.from(this.dataManager.sublayerCaches.get(i).keys()));Array.from(t.members.keys()).filter((t=>!e.has(t))).forEach((i=>{t.members?.delete(i)}))}})),t()}))}async refreshLinkChartCache(t){await this.dataManager.refreshCacheContent(t);const i=[];this.layers.forEach((t=>{i.push(t.refreshCachedQueryEngine())})),await Promise.all(i),this._refreshNamedTypes()}async connectBetweenEntities(t){let i=[];for(const t of this.dataManager.relationshipTypeNames){const e=this.sublayerIdsCache.get(t);e&&(i=i.concat(Array.from(e.keys())))}const e=await this.dataManager.getRelationshipsBetweenNodes(t,i);return await this._handleNewRecords(e),{records:e}}async connectFromEntities(t){let i=[];for(const t of this.dataManager.relationshipTypeNames){const e=this.sublayerIdsCache.get(t);e&&(i=i.concat(Array.from(e.keys())))}let e=[];for(const t of this.dataManager.entityTypeNames){const i=this.sublayerIdsCache.get(t);i&&(e=e.concat(Array.from(i)))}const s=await this.dataManager.getRelationshipsFromNodes(t,e,i);return await this._handleNewRecords(s),{records:s}}getCurrentLayout(){return this._currentLinkChartConfig.layoutMode}async _calculateLayoutWithSublayerTimeInfo(t="RADIAL_TREE",i){const e=new Map;this.layers.forEach((t=>{e.set(t.objectType.name,t.timeInfo)})),await this.calculateLinkChartLayout(t,{timeInfoByTypeName:e,...i})}async _handleNewRecords(t){const i=[];this.dataManager.addToLayer(t);for(const e of t)this.sublayerIdsCache.has(e.typeName)||(this.sublayerIdsCache.set(e.typeName,new Set),i.push(e.typeName)),this.sublayerIdsCache.get(e.typeName).add(e.id);for(const t of i){const i=this._graphTypeLookup.get(t);if(i){const e=this._createSublayer(i);"entity"===i.type?this.dataManager.entityTypeNames.add(t):this.dataManager.relationshipTypeNames.add(t),e.geometryType?this.layers.push(e):this.tables.push(e),this.dataManager.sublayerCaches.set(t,new Map)}}await T(this,i),await this.dataManager.refreshCacheContent(t.map((t=>t.id)));const e=Object.assign({},this._currentLinkChartConfig.layoutOptions);e.lockedNodeLocations=new Map;for(const[t,i]of this.entityLinkChartDiagramLookup.entries())i&&e.lockedNodeLocations.set(t,new f(i.coords[0],i.coords[1]));await this.applyNewLinkChartLayout(this._currentLinkChartConfig.layoutMode,e)}_createSublayers(t,i,e){t.forEach((t=>{const s=this._createSublayer(t);e(s)&&i.push(s),this._updateSublayerCaches(t)}))}_updateSublayers(t,i){i.forEach((i=>{i.parentCompositeLayer=this;const e=t.find((t=>t.type===i.graphType&&t.name===i.graphTypeName));e&&(i.objectType=e,i.read({title:e.name},{origin:"service"}),this._updateSublayerCaches(e))}))}_updateSublayerCaches(t){const i=this.dataManager.sublayerCaches;i.has(t.name)||i.set(t.name,new Map)}async _initializeDiagram(){this.defaultLinkChartConfig?this.defaultLinkChartConfig.doNotRecalculateLayout?(this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach(((t,i)=>{t?.members?.forEach((t=>{const e=t.linkChartLocation;let s;const a=t.id;if(!e)return;s="x"in e?{x:e.x,y:e.y}:{x:e.coords[0],y:e.coords[1]};const n=C(s);this.dataManager.relationshipTypeNames.has(i)?this.relationshipLinkChartDiagramLookup.set(a,n):this.entityLinkChartDiagramLookup.set(a,n),this.linkChartExtent.xmin>s.x&&(this.linkChartExtent.xmin=s.x),this.linkChartExtent.xmax<s.x&&(this.linkChartExtent.xmax=s.x),this.linkChartExtent.ymin>s.y&&(this.linkChartExtent.ymin=s.y),this.linkChartExtent.ymax<s.y&&(this.linkChartExtent.ymax=s.y)}))})),this.memberRelationshipTypes.forEach((t=>{t.name&&this.dataManager.sublayerCaches.get(t.name)?.forEach((t=>{const i=this.relationshipLinkChartDiagramLookup.get(t.attributes[k]),e=this.relationshipLinkChartDiagramLookup.get(t.attributes[_]);if(i&&e){const s=C(new y({paths:[[[i.coords[0],i.coords[1]],[e.coords[0],e.coords[1]]]]}));this.relationshipLinkChartDiagramLookup.set(t.attributes[R],s)}else this.relationshipLinkChartDiagramLookup.set(t.attributes[R],null)}))}))):await this._calculateLayoutWithSublayerTimeInfo(this.defaultLinkChartConfig.layoutMode,{lockedNodeLocations:this.getCurrentNodeLocations(),...this.defaultLinkChartConfig.layoutOptions||{}}):await this._calculateLayoutWithSublayerTimeInfo("RADIAL_TREE",{lockedNodeLocations:this.getCurrentNodeLocations()})}_refreshNamedTypes(){for(const t of this.layers)t.emit("refresh",{dataChanged:!0});for(const t of this.tables)t.emit("refresh",{dataChanged:!0})}_validateLayoutSettings(t,i){const e=t=>"number"==typeof t&&!isNaN(t),s=t=>e(t)&&t>=1,a=t=>e(t)&&t>=1,n=t=>Object.values(z).includes(t),o=t=>e(t)&&t>=0,r={organicLayoutSettings:{},chronologicalLayoutSettings:{}};if(!new Set(["FORCE_DIRECTED","COMMUNITY","GEOGRAPHIC","CHRONOLOGICAL_MULTIPLE","CHRONOLOGICAL_SINGLE"]).has(t)||!i)return r;i.organicLayoutSettings??={};const{computationBudgetTime:h,repulsionRadiusMultiplier:l,idealEdgeLength:d,idealEdgeLengthType:u}=i.organicLayoutSettings;a(h)?r.organicLayoutSettings.computationBudgetTime=h:void 0!==h&&c.getLogger(this).warn("Invalid layout computationBudgetTime setting, will revert to default setting"),s(l)?r.organicLayoutSettings.repulsionRadiusMultiplier=l:void 0!==l&&c.getLogger(this).warn("Invalid layout repulsionRadiusMultiplier setting, will revert to default setting");if("GEOGRAPHIC"===t&&(void 0!==d||void 0!==u)&&(n(u)?r.organicLayoutSettings.idealEdgeLengthType=u:void 0!==u&&c.getLogger(this).warn('Invalid layout idealEdgeLengthType setting, will revert to "multiplier" setting'),o(d)?r.organicLayoutSettings.idealEdgeLength=d:void 0!==d&&c.getLogger(this).warn("Invalid layout idealEdgeLength setting, will revert to default setting")),("CHRONOLOGICAL_MULTIPLE"===t||"CHRONOLOGICAL_SINGLE"===t)&&i.chronologicalLayoutSettings){const t=i.chronologicalLayoutSettings;t.durationLineWidth&&t.durationLineWidth<0&&c.getLogger(this).warn("Invalid layout durationLineWidth setting, will revert to default setting")}return r}_convertLayoutSettingsToCalculationSettings(t){t.organicLayoutSettings??={};let i=t.organicLayoutSettings.idealEdgeLength;return t.organicLayoutSettings.idealEdgeLengthType===z.ABSOLUTE&&(void 0===i?i=-1:i*=-1),{computationBudgetTime:t.organicLayoutSettings.computationBudgetTime,repulsionRadiusMultiplier:t.organicLayoutSettings.repulsionRadiusMultiplier,idealEdgeLengthMultiplier:i}}_createSublayer(t){return new O({objectType:t,parentCompositeLayer:this,graphType:t.type})}_handleSublayersChange(t,i){i&&(i.forEach((t=>{t.parent=null})),this.removeHandles("sublayers-owner")),t&&(t.forEach((t=>{t.parent=this})),this.addHandles([t.on("after-add",(({item:t})=>{t.parent=this})),t.on("after-remove",(({item:t})=>{t.parent=null}))],"sublayers-owner"))}};w([L()],B.prototype,"dataPreloadedInLocalCache",void 0),w([L()],B.prototype,"defaultLinkChartConfig",void 0),w([L()],B.prototype,"dataManager",void 0),w([L()],B.prototype,"inclusionModeDefinition",null),w([L()],B.prototype,"knowledgeGraph",void 0),w([L({type:n.ofType(O),json:{write:{ignoreOrigin:!0}}})],B.prototype,"layers",void 0),w([L()],B.prototype,"entityLinkChartDiagramLookup",void 0),w([L()],B.prototype,"relationshipLinkChartDiagramLookup",void 0),w([L()],B.prototype,"linkChartExtent",void 0),w([L()],B.prototype,"memberEntityTypes",void 0),w([L()],B.prototype,"memberRelationshipTypes",void 0),w([L({type:["LinkChartLayer"]})],B.prototype,"operationalLayerType",void 0),w([L()],B.prototype,"sublayerIdsCache",void 0),w([L({type:n.ofType(O),json:{write:{ignoreOrigin:!0}}})],B.prototype,"tables",void 0),w([L({json:{read:!1}})],B.prototype,"type",void 0),w([L({json:{read:!1}})],B.prototype,"chronologicalAuxiliaryGraphics",void 0),B=w([m("esri.layers.LinkChartLayer")],B);const $=B;export default $;
//# sourceMappingURL=p-d4897433.js.map