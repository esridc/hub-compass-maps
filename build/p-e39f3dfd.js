import{b7 as t,_ as s,y as e,gn as i,aX as r,bt as n,b4 as h,jn as o,aS as a,aZ as c,c2 as u,h as l,gT as d,R as f,af as p,W as g,b_ as y,ds as w,dr as m,an as b,ao as S,ap as I,am as v,ah as _,a as M,b3 as x,s as F,jo as A,hZ as C,S as j,hB as k,bh as E,al as T,C as P,jp as R,jq as q,U as $,ae as G,Z as D,jr as O,js as N,g1 as U,fi as V,u as B}from"./p-3013819f.js";import{a as L}from"./p-b362a32c.js";import{n as z,i as W,r as Q,M as Z,p as X,d as Y,f as J,g as H,a as K,b as tt,h as st,j as et}from"./p-721433ed.js";import{o as it}from"./p-9a31fdd8.js";import{S as rt,R as nt,A as ht}from"./p-23c050ff.js";import{g as ot,e as at,c as ct,N as ut,n as lt,p as dt,b as ft,w as pt,a as gt,K as yt,O as wt,r as mt,f as bt}from"./p-ec95a4fb.js";import{s as St,t as It}from"./p-1f0b604e.js";import{x as vt,j as _t}from"./p-8b1f6523.js";import{o as Mt,$ as xt}from"./p-37d27f4e.js";import{e as Ft}from"./p-94b15954.js";import{d as At,c as Ct,S as jt}from"./p-71d25f62.js";import{$ as kt}from"./p-40389bf3.js";import{n as Et}from"./p-ad726e47.js";import{b as Tt,h as Pt}from"./p-a71453e3.js";import{t as Rt}from"./p-4c2ef9f4.js";import{createConnection as qt}from"./p-d9bcd2a2.js";import{d as $t}from"./p-ffa11fc1.js";import"./p-3b51db5e.js";import"./p-c7810a6f.js";import"./p-8567e6fe.js";import"./p-30a1f911.js";import"./p-c268fbe3.js";import"./p-201cec5f.js";import"./p-89242a33.js";import"./p-a897fcf8.js";import"./p-1cf43261.js";import"./p-a9376829.js";import"./p-3811f238.js";import"./p-e6812c2f.js";import"./p-f1aede5a.js";import"./p-a925664a.js";import"./p-7b13247d.js";import"./p-347800d3.js";import"./p-4f73c6ea.js";import"./p-a20ea8a0.js";import"./p-976040d8.js";import"./p-9a63ab56.js";import"./p-c1b8730f.js";import"./p-2779f4bc.js";import"./p-19067929.js";import"./p-b821ae32.js";import"./p-a047dd27.js";import"./p-8c0cd8a3.js";import"./p-808395fb.js";import"./p-508fdb0a.js";import"./p-7580bdba.js";import"./p-a62b18ce.js";class Gt{constructor(t){this._client=t,this.layerView=this._client.createInvokeProxy("",{ignoreConnectionErrors:!0}),this.container=this._client.createInvokeProxy("container",{ignoreConnectionErrors:!0}),this.eventLog=this._client.createInvokeProxy("eventLog",{ignoreConnectionErrors:!0})}}const Dt=1,Ot=2,Nt=4,Ut=8,Vt=16,Bt=32,Lt=64,zt=128;function Wt(t){switch(t){case Dt:case Ut:case Bt:return-1;case Ot:case Lt:return 0;case Nt:case Vt:case zt:return 1}}function Qt(t){switch(t){case Dt:case Ot:case Nt:return-1;case Ut:case Vt:return 0;case Bt:case Lt:case zt:return 1}}const Zt=Dt|Ut|Bt,Xt=Nt|Vt|zt,Yt=Dt|Ot|Nt,Jt=Bt|Lt|zt;class Ht{constructor(t,s,e,i=0){this.tileKey=t,this._bufferingEnabled=s,this._sizeHint=i,this._meshes={self:new z(this.id,this._sizeHint),neighbors:new Array},this._currentRecordOverlaps=0,this._currentEntityOverlaps=0,this._copyBufferedDataIntoSelf=e&&this._bufferingEnabled&&0===t.level}get id(){return this.tileKey.id}vertexCount(){return this._meshes.self.vertexCount()}indexCount(){return this._meshes.self.indexCount()}indexEnsureSize(t){this._meshes.self.indexEnsureSize(t)}entityStart(t,s=t){this._currentEntityOverlaps=0,this._meshes.self.entityStart(t,s)}entityRecordCount(){return this._meshes.self.entityRecordCount()}entityEnd(){if(this._meshes.self.entityEnd(),this._bufferingEnabled){if(this._copyBufferedDataIntoSelf)return;for(let t=0;t<8;t++){const s=1<<t;!!(this._currentEntityOverlaps&s)&&this._meshes.neighbors[t].entityEnd()}}}recordStart(t,s,e){this._currentRecordOverlaps=0,this._meshes.self.recordStart(t,s,e)}recordEnd(t=0){const s=this._meshes.self.recordEnd(this._currentRecordOverlaps);return s&&0!==this._currentRecordOverlaps?(this._copyIntoNeighbors(),this._currentEntityOverlaps|=this._currentRecordOverlaps,!0):s}recordBounds(t,s,e,i){this._bufferingEnabled&&this._addOverlap(t,s,e,i)}recordCount(){return this._meshes.self.recordCount()}metricStart(t){this._meshes.self.metricStart(t)}metricBoxWrite(t){this._meshes.self.metricBoxWrite(t)}metricEnd(){this._meshes.self.metricEnd()}vertexWrite(t){this._meshes.self.vertexWrite(t)}vertexWriteF32(t){this._meshes.self.vertexWriteF32(t)}vertexWriteRegion(t){this._meshes.self.vertexWriteRegion(t)}indexWrite(t){this._meshes.self.indexWrite(t)}serialize(s){const e={message:[],transferList:[]},i=this._meshes.self.serialize();return e.message.push({tileId:this.tileKey.id,...i.message}),e.transferList.push(...i.transferList),this._meshes.neighbors.forEach(((i,r)=>{const n=i.serialize(),h=1<<r,o=Wt(h),a=Qt(h),c=it(new t(this.tileKey),o,a,s);e.message.push({tileId:c.id,...n.message}),e.transferList.push(...n.transferList)})),e}_addOverlap(t,s,e,i){const r=Math.min(L/2,e),n=Math.min(L/2,i),h=255^((t<0+r?Xt:t>=L-r?Zt:Xt|Zt)|(s<0+n?Jt:s>=L-n?Yt:Jt|Yt));this._currentRecordOverlaps|=h}_copyIntoNeighbors(){for(let t=0;t<8;t++){const s=1<<t;if(!!(this._currentRecordOverlaps&s)){if(this._copyBufferedDataIntoSelf){const t=-Wt(s)*L,e=-Qt(s)*L;this._meshes.self.copyLast(t,e);continue}if(!this._meshes.neighbors[t]){const e=Math.floor(this._sizeHint/16);this._meshes.neighbors[t]=new z(s,e)}const e=this._meshes.neighbors[t],i=-Wt(s)*L,r=-Qt(s)*L;e.copyLastFrom(this._meshes.self,i,r)}}}}class Kt{}class ts{constructor(){this._defaultResult=null,this._backgroundFillResult=null}static async from(t,s,e,i){const r=new ts;return r.setDefault(await W(t,s,e.meshes,i)),r}size(){return 1}getDefault(){return this._defaultResult}setDefault(t){this._defaultResult=t}getBackgroundFill(){return this._backgroundFillResult}setBackgroundFill(t){this._backgroundFillResult=t}match(t,s){const e=this.doMatch(t,s)||this.getDefault();if(e&&e.length>0){const t=this.getBackgroundFill();if(t)return[...t,...e]}return e}getSortKey(t,s){return 0}doMatch(t,s){return null}async fetchResources(t,s){}}class ss extends ts{static async fromDictionaryRenderer(t,s,e){return new ss(t,s,e)}constructor(t,s,e){super(),this._storage=t,this._schema=s,this._viewParams=e,this._hashToGroup=new Map}get fieldMap(){return this._schema.fieldMap}async fetchResources(t,s){const e=s.getCursor(),i=[];for(;e.next();)i.push(this._updateMeshWriterGroup(t,e));await Promise.all(i)}match(t,s){const e=t.getAttributeHash();return this._hashToGroup.get(e)}async _updateMeshWriterGroup(t,s){const e=s.readLegacyFeatureForDisplay(),i=s.getAttributeHash();if(this._hashToGroup.has(i))return;this._hashToGroup.set(i,null);const r=await t.fetchDictionaryResourceImmediate({type:"dictionary-request",feature:e});if(!r)return;const n=await W(this._storage,t,r.meshes,this._viewParams);this._hashToGroup.set(i,n)}}class es extends ts{constructor(t,s){super(),this._intervals=[],this._isMaxInclusive=s,this._field=t}static async fromIntervalSchema(t,s,e,i){const r=await t.createComputedField(e),n=new es(r,e.isMaxInclusive);await Promise.all(e.intervals.map((async e=>{const r=await W(t,s,e.meshes,i);n.add(e,r)})));const h=await W(t,s,e.defaultSymbol,i);n.setDefault(h);const o=await W(t,s,e.backgroundFill,i);return n.setBackgroundFill(o),n}add(t,s){this._intervals.push({interval:t,result:s}),this._intervals.sort(((t,s)=>t.interval.min-s.interval.min))}size(){return super.size()+this._intervals.length}doMatch(t,s){const e=this._field?.read(t,s);if(null==e||isNaN(e)||e===1/0||e===-1/0)return null;for(let t=0;t<this._intervals.length;t++){const{interval:s,result:i}=this._intervals[t],r=e>=s.min,n=this._isMaxInclusive?e<=s.max:e<s.max;if(r&&n)return i}return null}}class is extends ts{static async fromLabelSchema(t,s,e,i){const r=e.classes.map((async e=>{const r=await W(t,s,e.meshes,i);return{minScale:e.minScale,maxScale:e.maxScale,meshes:r,expression:null,where:await t.createWhereClause(e.where)}})),n=await Promise.all(r);return new is(n)}constructor(t){super(),this._labels=t}match(t,s){if(!this._labels.length)return null;const e=this._getLabels(s.$view.scale),i=[];for(const s of e)s.where&&!s.where(t)||i.push(...s.meshes);return i}_getLabels(t){return this._labels.filter((s=>this._validForTileScale(s,t)))}_validForTileScale(t,s){const e=s-s/4,i=s+s/2;return(!t.minScale||t.minScale>=e)&&(!t.maxScale||t.maxScale<=i)}}class rs extends ts{constructor(t,s){super(),this._defaultSymbolSortKey=0,this._nullResult=null,this._resultsMap=new Map,this._fields=[],this._fields=t,this._separator=s||""}static async fromMatcherSchema(t,s,e,i){const r=e.expression?[t.createComputedField({expression:e.expression})]:[e.field?t.createComputedField({field:e.field}):null,e.field2?t.createComputedField({field:e.field2}):null,e.field3?t.createComputedField({field:e.field3}):null],n=(await Promise.all(r)).filter((t=>!!t)),h=new rs(n,e.fieldDelimiter),o=await W(t,s,e.defaultSymbol,i);h.setDefault(o);const a=await W(t,s,e.backgroundFill,i);return h.setBackgroundFill(a),await Promise.all(e.map.map((async(e,r)=>{const n=await W(t,s,e.symbol,i);"<Null>"===e.value?h.setNullResult(n):h.add(e.value,n,r+1)}))),h}setNullResult(t){this._nullResult=t}getSortKey(t,s){const e=this._getValueFromFields(t,s);if(null==e||""===e||"<Null>"===e)return 0;const i=this._resultsMap.get(e.toString());return i?i.sortKey:this._defaultSymbolSortKey}add(t,s,e){this._resultsMap.set(t.toString(),{meshWriters:s,sortKey:e}),this._defaultSymbolSortKey=Math.max(this._defaultSymbolSortKey,e+1)}size(){return super.size()+this._resultsMap.size}doMatch(t,s){const e=this._getValueFromFields(t,s);if(null!==this._nullResult&&(null==e||""===e||"<Null>"===e))return this._nullResult;if(null==e)return null;const i=e.toString();return this._resultsMap.get(i)?.meshWriters}_getValueFromFields(t,s){const e=[];for(const i of this._fields){const r=i.read(t,s);null==r||""===r?e.push("<Null>"):e.push(r)}return e.join(this._separator)}}async function ns(t,s,e,i){switch(e.type){case"simple":case"heatmap":case"dot-density":case"pie-chart":return ts.from(t,s,e,i);case"interval":return es.fromIntervalSchema(t,s,e,i);case"dictionary":return ss.fromDictionaryRenderer(t,e,i);case"label":return is.fromLabelSchema(t,s,e,i);case"map":return rs.fromMatcherSchema(t,s,e,i);case"subtype":return hs.fromSubtypes(t,s,e,i);case"cluster":return os.fromClusterSchema(t,s,e,i);default:throw new Error("Impl")}}class hs extends ts{constructor(t,s){super(),this._subMatchers=t,this._subtypeField=s}static async fromSubtypes(t,s,e,i){const r=new Map,n=[];for(const h in e.renderers){const o=parseInt(h,10),a=ns(t,s,e.renderers[h],i).then((t=>r.set(o,t)));n.push(a)}return await Promise.all(n),new hs(r,e.subtypeField)}match(t,s){const e=t.readAttribute(this._subtypeField),i=this._subMatchers.get(e);return i?i.match(t,s):null}}class os extends ts{static async fromClusterSchema(t,s,e,i){const[r,n]=await Promise.all([ns(t,s,e.feature,i),ns(t,s,e.cluster,i)]);return new os(r,n)}constructor(t,s){super(),this._featureMatcher=t,this._clusterMatcher=s}match(t,s){return 1===t.readAttribute("cluster_count")?this._featureMatcher.match(t,s):this._clusterMatcher.match(t,s)}}class as extends Kt{static async create(t,s,e,i){const r=await ns(t,s,e.symbology,i),n=e.labels?await ns(t,s,e.labels,i):null;return new as(r,n)}constructor(t,s){super(),this._symbology=t,this._labels=s}destroy(){}async enqueueMatcherRequests(t,s){await Promise.all([this._symbology.fetchResources(t,s),this._labels?.fetchResources(t,s)])}enqueueWriterRequests(t,s,e){const i=this._symbology.match(s,e);if(i){for(const r of i)r.enqueueRequest(t,s,e);if(this._labels){const i=this._labels.match(s,e);if(!i)return;for(const r of i)r.enqueueRequest(t,s,e)}}}write(t,s,e,i,r){const n=this._symbology.match(e,i);if(!n)return;for(const h of n)h.write(t,s,e,i,r);if(t.entityRecordCount()>=1&&this._labels){const h=this._labels.match(e,i);if(!h)return;for(const o of h)o.setReferences(n),o.write(t,s,e,i,r)}}getSortKey(t,s){return this._symbology.getSortKey(t,s)}}class cs{constructor(t){this._outstandingMessages=[],this._queue=new s({concurrency:t.concurrency,process:s=>t.process(s)})}async push(t){if(t.end)return await Promise.all(this._outstandingMessages),await this._queue.push(t),void(this._outstandingMessages=[]);const s=this._queue.push(t);return this._outstandingMessages.push(s),s}}class us{static async create(t,s){if("count"===s.statisticType){const t=new Q(1);return new us(s.name,s.alias,s.type,s.statisticType,t)}const e=await t.createComputedField({expression:s.onStatisticExpression?.expression,field:s.onStatisticField});return new us(s.name,s.alias,s.type,s.statisticType,e)}constructor(t,s,e,i,r){this.name=t,this.alias=s,this.type=e,this.statisticType=i,this.computed=r}}class ls{constructor(t){this.subscription=t,this.handledChunks=new Set}destroy(){}}class ds{constructor(t,s){this._source=t,this._attributeStore=s,this._sendStates=new Map}destroy(){}get enablePixelBuffering(){return!0}onSubscribe(t){const s=this.createState(t);this._sendStates.set(t.key.id,s),this.updateChunks()}onUnsubscribe(t){this._sendStates.get(t.key.id)?.destroy(),this._sendStates.delete(t.key.id)}invalidate(){const t=Array.from(this._sendStates.values());this._sendStates.clear();for(const s of t)s.destroy(),this.onSubscribe(s.subscription)}invalidateAttributeData(){}getFeatureObjectIdsForAggregate(t){throw new Error("InternalError: AggregateId lookup not supported")}getDisplayIds(t){return this.displayMap(t,(t=>t),(t=>t))}getDisplayAndObjectIds(t){return this.displayMap(t,(t=>t),((t,s,e)=>[t,e]))}afterUpdateChunks(){}}class fs extends ds{constructor(t,s,i,r){super(t,s),this.spatialReference=i,this.aggregateFields=r,this.events=new e,this.featureAdapter=Mt}get aggregateQueryEngine(){return this._aggregateQueryEngine||(this._aggregateQueryEngine=new xt({featureStore:this,fieldsIndex:this._metadata.fieldsIndex,geometryType:this._metadata.geometryType,objectIdField:this._metadata.objectIdField,spatialReference:this.spatialReference})),this._aggregateQueryEngine}removeChunks(t){}forEach(t){return this.forEachAggregateWorldSpace(t)}forEachInBounds(t,s){}forEachBounds(t,s){const e=i();for(const i of t){const t=ot(e,i.geometry,!1,!1);t&&s(t)}}}class ps{constructor(t,s,e,i,r){this.subscription=t,this.reader=s,this.clear=e,this.end=i,this.debugInfo=r,this.type="append"}get id(){return this.subscription.tile.id}createMessage(t,s,e){return{type:"append",clear:this.clear,id:this.id,append:t,end:this.end,debugInfo:this.debugInfo,subscriptionVesrion:this.subscription.version,version:s,attributeEpoch:e}}}class gs{constructor(t,s,e,i,r){this.subscription=t,this.reader=s,this.remove=e,this.end=i,this.debugInfo=r,this.type="update"}get id(){return this.subscription.tile.id}createMessage(t,s,e){return{type:"update",id:this.id,modify:t,debugInfo:this.debugInfo,remove:this.remove,version:s,subscriptionVesrion:this.subscription.version,end:this.end,attributeEpoch:e}}}class ys extends Z{static fromFeatures(t,s){const{objectIdField:e,geometryType:i}=s,r=at([],t,i,!1,!1,e);for(let s=0;s<r.length;s++)r[s].displayId=t[s].displayId;return ys.fromOptimizedFeatures(r,s)}static fromFeatureSet(t,s){const e=ct(t,s.objectIdField);return ys.fromOptimizedFeatureSet(e,s)}static fromOptimizedFeatureSet(t,s){const e=ys.fromOptimizedFeatures(t.features,s);return e._exceededTransferLimit=t.exceededTransferLimit,e._transform=t.transform,e._fieldsIndex=new r(t.fields),e}static fromOptimizedFeatures(t,s,e){const i=new ys(t,s);return i._fieldsIndex=s.fieldsIndex,i._transform=e,i}static empty(t){return new ys([],t)}constructor(t,s){super(s),this._exceededTransferLimit=!1,this._featureIndex=-1,this._fieldsIndex=null,this._geometryType=s.geometryType,this._features=t}get fields(){return this._fieldsIndex}get geometryType(){return this._geometryType}get hasFeatures(){return!!this._features.length}get hasNext(){return this._featureIndex+1<this._features.length}get exceededTransferLimit(){return this._exceededTransferLimit}get hasZ(){return!1}get hasM(){return!1}get _current(){return this._features[this._featureIndex]}removeIds(t){const s=new Set(t);this._features=this._features.filter((t=>!(null!=t.objectId&&s.has(t.objectId))))}getSize(){return this._features.length}getCursor(){return this.copy()}getInTransform(){return this._transform}getAttributeHash(){let t="";for(const s in this._current.attributes)t+=this._current.attributes[s];return t}getIndex(){return this._featureIndex}setIndex(t){this._featureIndex=t}getObjectId(){return this._current?.objectId}getDisplayId(){return this._current.displayId}setDisplayId(t){this._current.displayId=t}copy(){const t=new ys(this._features,this.metadata);return this.copyInto(t),t}next(){for(;++this._featureIndex<this._features.length&&!this._getExists(););return this._featureIndex<this._features.length}readGeometryArea(){return St(this._current)?ut(this._current.geometry,2):0}_readX(){return St(this._current)?this._current.geometry.coords[0]:0}_readY(){return St(this._current)?this._current.geometry.coords[1]:0}_readGeometry(){return St(this._current)?this._current.geometry??null:null}_readServerCentroid(){return this._current.centroid}_readAttribute(t,s){if(!this._fieldsIndex){const s=this._current.attributes[t];if(void 0!==s)return s;const e=t.toLowerCase();for(const t in this._current.attributes)if(t.toLowerCase()===e)return this._current.attributes[t];return}const e=this._fieldsIndex.get(t);if(!e)return;let i=this._current.attributes[e.name];return null==i?i:("esriFieldTypeTimestampOffset"===this.fields.get(t)?.type&&(i=this.parseTimestampOffset(i)),s&&this.fields.isDateField(t)?new Date(i):i)}_readAttributes(){return this._current.attributes}copyInto(t){super.copyInto(t),t._featureIndex=this._featureIndex,t._transform=this._transform,t._fieldsIndex=this._fieldsIndex}}class ws extends ls{constructor(t,s){super(t),this.bins=new Map,this.done=!1,this._store=s}reset(){this.destroy(),this.bins.clear(),this.done=!1,this.handledChunks.clear()}destroy(){const t=this.subscription.tile.key.level;for(const s of this.bins.values()){const e=s.cachedFeature?.objectId;null!=e&&this._store.releaseDisplayIdForObjectId(`${e}.${t}`)}}*featuresWorldSpace(){for(const t of this.bins.values()){const s=t.cachedFeature;if(s){const t=s.clone();t.geometry&&dt(t.geometry,t.geometry,!1,!1,this.subscription.tile.transform),yield t}}}getGeohashBounds(t,s){const e=this.subscription.tile;return rt(e.extent,e.resolution,s,t)}}class ms extends fs{static async create(t,s,e,i,r){const h=new X({spatialReference:s}),o=t.fixedBinLevel,a=await Promise.all(t.fields.map((async t=>us.create(h,t)))),c=t.featureFilter?await Y.create({geometryType:e.metadata.geometryType,hasM:!1,hasZ:!1,timeInfo:e.metadata.timeInfo,fieldsIndex:e.metadata.fieldsIndex,spatialReference:s,filterJSON:t.featureFilter}):null;return await vt(s,n.WGS84),new ms({fields:a,geohashLevel:o,spatialReference:s,featureFilter:c,timeZone:r},t.fields,e,i)}constructor(t,s,e,i){super(e,i,t.spatialReference,t.fields),this._indexOptions=t,this._metadata=new J({geometryType:"esriGeometryPolygon",objectIdField:"aggregateId",fields:s,globalIdField:null,spatialReference:e.metadata.spatialReference,subtypeField:null,subtypes:null,timeInfo:null,timeReferenceUnknownClient:null,typeIdField:null,types:null})}createState(t){return new ws(t,this._attributeStore)}async*applyOverride(t){for(const t of this._sendStates.values()){t.reset();const s=new ps(t.subscription,ys.empty(this._source.metadata),!0,!1,{});yield s}}displayMap(t,s,e){const i=new Map(t.map((t=>[s(t),t]))),r=[];for(const t of this._sendStates.values())for(const s of t.featuresWorldSpace()){const{objectId:t,displayId:n}=s,h=i.get(t);if(null!=h){const s=e(n,h,t);r.push(s),i.delete(t)}}return r}getDisplayFeatures(t){const s=new Set(t),e=new Set,i=[];for(const t of this._sendStates.values())for(const r of t.featuresWorldSpace())s.has(r.displayId)&&!e.has(r.objectId)&&(r.geometry&&i.push({...lt(r,this._metadata.geometryType,!1,!1),displayId:r.displayId}),e.add(r.objectId));return{features:[],aggregates:i}}getFeatureObjectIdsForAggregate(t){for(const s of this._sendStates.values())for(const e of s.bins.values())if(e.id===t)return Array.from(e.objectIds);return[]}async*updateChunks(){if(this._source.chunks().length)for(const t of this._sendStates.values())yield*this._update(t,this._source)}forEachAggregateWorldSpace(t){for(const s of this._sendStates.values())for(const e of s.featuresWorldSpace())t(e)}async*_update(s,e){const{handledChunks:i,subscription:r,bins:n}=s,{spatialReference:h,geohashLevel:o}=this._indexOptions,a=r.tile;if(s.done)return;for(const r of e.chunks()){if(i.has(r.chunkId))continue;i.add(r.chunkId);const e=r.queryInfo;if("tileId"in e){const s=new t(e.tileId);if(s.level!==a.level||s.world!==a.key.world)continue}const c=r.getGeohashIndex(this._indexOptions),u=s.getGeohashBounds(h,o);null!=u&&c.putBins(n,u)}const c=[],u=r.tile.transform,l=r.tile.key.level;for(const t of n.values()){if(t.cachedFeature)t.cachedFeature.attributes=t.getAttributes();else{const s=t.getGeometry(this.spatialReference,u),e=new It(s,t.getAttributes(),null);s||(e.centroid=t.getGeometryCentroid(this.spatialReference,u)),e.objectId=t.id,e.displayId=this._attributeStore.createDisplayIdForObjectId(`${e.objectId}.${l}`),t.cachedFeature=e}c.push(t.cachedFeature)}this.events.emit("changed"),s.done=!e.updateTracking.updating;const d=ys.fromOptimizedFeatures(c,this._metadata,u),f=d.getCursor(),p=s.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.timeZone);for(;f.next();)this._attributeStore.setAttributeData(f.getDisplayId(),f,p);const g=new gs(s.subscription,d,[],s.done,{});yield g}}const bs=Math.PI/180;class Ss{static create(t){return new Ss(t.map((t=>Is(t))))}constructor(t){this._statistics=t}values(){return this._statistics.values()}insert(t,s){for(const e of this._statistics)e.insert(t,s)}merge(t){for(let s=0;s<this._statistics.length;s++){const e=this._statistics[s],i=t._statistics[s];if(e.field.name!==i.field.name)throw new Error("InternalError: Tried to merge incompatible statistics");e.merge(i)}}clone(){return new Ss(this._statistics.map((t=>t.clone())))}}function Is(t){switch(t.statisticType){case"min":return new _s(t);case"max":return new Ms(t);case"avg":return new Fs(t);case"avg_angle":return new As(t);case"sum":case"count":return new xs(t);case"mode":return new Cs(t)}}class vs{constructor(t){this.field=t}insert(t,s){if(!this.field.computed)return;const e=this.field.computed.read(t,s);H(e)||this._insertValue(e)}}class _s extends vs{constructor(){super(...arguments),this.type="min",this.value=Number.MAX_VALUE}_insertValue(t){this.value=Math.min(this.value,t)}merge(t){this.value=Math.min(this.value,t.value)}clone(){const t=new _s(this.field);return t.value=this.value,t}}class Ms extends vs{constructor(){super(...arguments),this.type="max",this.value=Number.MIN_VALUE}_insertValue(t){this.value=Math.max(this.value,t)}merge(t){this.value=Math.max(this.value,t.value)}clone(){const t=new Ms(this.field);return t.value=this.value,t}}class xs extends vs{constructor(){super(...arguments),this.type="sum",this.value=0}_insertValue(t){this.value+=t}merge(t){this.value+=t.value}clone(){const t=new xs(this.field);return t.value=this.value,t}}class Fs extends vs{constructor(){super(...arguments),this.type="avg",this._total=0,this._count=0}get value(){return this._total/this._count}_insertValue(t){this._total+=t,this._count+=1}merge(t){this._total+=t._total,this._count+=t._count}clone(){const t=new Fs(this.field);return t._total=this._total,t._count=this._count,t}}class As extends vs{constructor(){super(...arguments),this.type="avg_angle",this._x=0,this._y=0,this._count=0}get value(){const t=this._x/this._count,s=this._y/this._count,e=180/Math.PI;return Math.atan2(s,t)*e}_insertValue(t){this._x=this._x+Math.cos(t*bs),this._y=this._y+Math.sin(t*bs),this._count+=1}merge(t){this._x+=t._x,this._y+=t._y,this._count+=t._count}clone(){const t=new As(this.field);return t._x=this._x,t._y=this._y,t._count=this._count,t}}class Cs extends vs{constructor(){super(...arguments),this._frequencies=new Map}get value(){let t,s=0;for(const[e,i]of this._frequencies.entries())i>s&&(s=i,t=e);return t}_insertValue(t){const s=this._frequencies.get(t);null!=s?this._frequencies.set(t,s+1):this._frequencies.set(t,1)}merge(t){for(const[s,e]of t._frequencies.entries()){const t=this._frequencies.get(s);null!=t?this._frequencies.set(s,t+e):this._frequencies.set(s,e)}}clone(){const t=new Cs(this.field);return t._frequencies=new Map(this._frequencies),t}}class js{static createId(t,s){return`${t}.${s}`}static create(t,s,e,i){return new js(t,s,Ss.create(e),i)}constructor(t,s,e,i){this.gridX=t,this.gridY=s,this._statistics=e,this._worldUnitsPerCell=i,this._count=0,this._xWorldTotal=0,this._yWorldTotal=0,this._objectIds=new Set}get id(){return js.createId(this.gridX,this.gridY)}get count(){return this._count}get statistics(){return this._statistics}get objectIds(){return this._objectIds}get firstObjectId(){return this._objectIds.values().next().value}get centroidXWorld(){return this._xWorldTotal/this._count}get centroidYWorld(){return this._yWorldTotal/this._count}clone(){const t=new js(this.gridX,this.gridY,this._statistics.clone(),this._worldUnitsPerCell);return t._count=this._count,t._xWorldTotal=this._xWorldTotal,t._yWorldTotal=this._yWorldTotal,t._firstFeatureAttributes=this._firstFeatureAttributes,t._objectIds=new Set(this._objectIds),t}insert(t,s,e,i){0===this._count?this._firstFeatureAttributes=t.readAttributes():this._firstFeatureAttributes=null,this._count+=1,this._xWorldTotal+=e,this._yWorldTotal+=i,this._statistics.insert(t,s),this._objectIds.add(t.getObjectId())}merge(t){if(0!==t._count){this._count+=t._count,this._firstFeatureAttributes=t._firstFeatureAttributes,this._xWorldTotal+=t._xWorldTotal,this._yWorldTotal+=t._yWorldTotal,this._statistics.merge(t._statistics);for(const s of t._objectIds.values())this._objectIds.add(s)}}getCentroidX(t){return null==t?this.centroidXWorld:ft(t,this.centroidXWorld)}getCentroidY(t){return null==t?this.centroidYWorld:pt(t,this.centroidYWorld)}getCentroid(t){const s=new Ft([],[this.centroidXWorld,this.centroidYWorld]);if(null!=t){const e=new Ft;return gt(e,s,!1,!1,"esriGeometryPoint",t)}return s}getGeometricCentroid(t){const s=this.gridX*this._worldUnitsPerCell+.5*this._worldUnitsPerCell,e=this.gridY*this._worldUnitsPerCell+.5*this._worldUnitsPerCell,i=new Ft([],[s,e]);if(null!=t){const s=new Ft;return gt(s,i,!1,!1,"esriGeometryPoint",t)}return i}getAttributes(){const t={aggregateId:this.id};for(const s of this._statistics.values())t[s.field.name]=s.value;return null!=this._firstFeatureAttributes?{...t,...this._firstFeatureAttributes}:t}}const ks=96;function Es(t,s){return h(t)*o*ks/s}class Ts{constructor(t){this._options=t,this._cells=new Map,this._pixelsPerMapUnit=Es(t.spatialReference,t.scale)}insert(t,s){const e=t.getCursor(),i={$view:{scale:this._options.scale,timeZone:this._options.timeZone}};for(;e.next();)this._insertFeature(e,i,s)}putCellsInBounds(t,s){const[e,i,r,n]=s,h=Math.floor(e*this._pixelsPerMapUnit/this._options.cellSize),o=Math.floor(i*this._pixelsPerMapUnit/this._options.cellSize),a=Math.ceil(r*this._pixelsPerMapUnit/this._options.cellSize),c=Math.ceil(n*this._pixelsPerMapUnit/this._options.cellSize);for(let s=o;s<=c;s++)for(let e=h;e<=a;e++){const i=`${e}.${s}`,r=this._cells.get(i);if(!r)continue;const n=t.get(r.id);n?r&&!t.has(r.id)&&n.merge(r):t.set(r.id,r.clone())}}putCells(t){for(const s of this._cells.values()){const e=t.get(s.id);e?e.merge(s):t.set(s.id,s.clone())}}_insertFeature(t,s,e){const{featureFilter:i}=this._options;if(null!==i&&!i.check(t))return;let r=0,n=0;if("esriGeometryPoint"===t.geometryType)r=t.readXWorldSpace(),n=t.readYWorldSpace();else{if(e){const s=t.readCentroidForDisplay();if(null==s)return;const[e,i]=s.coords;if(e<0||e>L||i<0||i>L)return}const s=t.readCentroidWorldSpace();if(null==s)return;r=s.coords[0],n=s.coords[1]}const h=r*this._pixelsPerMapUnit,o=n*this._pixelsPerMapUnit,a=Math.floor(h/this._options.cellSize),c=Math.floor(o/this._options.cellSize);this._getCellOrCreate(a,c).insert(t,s,r,n)}_getCellOrCreate(t,s){const e=js.createId(t,s);let i=this._cells.get(e);if(!i){const r=1*this._options.cellSize/this._pixelsPerMapUnit;i=js.create(t,s,this._options.fields,r),this._cells.set(e,i)}return i}}class Ps{constructor(t,s){this.inner=t,this.displayId=s}}const Rs=128;class qs extends ls{constructor(t){super(t),this.didSend=!1,this.done=!1}}class $s{constructor(t,s,e,i,r){this._level=t,this._scale=s,this._indexOptions=e,this._clusterRadius=i,this._store=r,this._cells=new Map,this._handledChunks=new Set,this._statistics=new Map,this._clusters=new Map}destroy(){this._clearClusters()}_clearClusters(){for(const t of this._clusters.values())this._store.releaseDisplayIdForObjectId(t.inner.id);this._clusters.clear()}*aggregatesWorldSpace(){for(const t of this._clusters.values()){const s=t.inner.getCentroid(null),e=new It(s,t.inner.getAttributes(),null);e.objectId=t.inner.id,e.displayId=t.displayId,yield e}}clusters(){return this._clusters.values()}updateChunks(s,e){let i=!1;for(const e of s){const s=e.queryInfo;if("tileId"in s){if(new t(s.tileId).level!==this._level)continue}if(!this._handledChunks.has(e.normalizedChunkId)){this._handledChunks.add(e.normalizedChunkId),i=!0;e.getGridIndex({...this._indexOptions,scale:this._scale}).putCells(this._cells)}}const r={xMin:1/0,yMin:1/0,xMax:-1/0,yMax:-1/0},n=Es(this._indexOptions.spatialReference,this._scale),h=this._indexOptions.cellSize;for(const{subscription:t}of e){const s=t.tile.bounds,e=Math.floor(s[0]*n/h),i=Math.floor(s[1]*n/h),o=Math.ceil(s[2]*n/h),a=Math.ceil(s[3]*n/h);r.xMin=Math.min(r.xMin,e),r.yMin=Math.min(r.yMin,i),r.xMax=Math.max(r.xMax,o),r.yMax=Math.max(r.yMax,a)}return null!=this._lastCellBounds&&r.xMin===this._lastCellBounds.xMin&&r.yMin===this._lastCellBounds.yMin&&r.yMin===this._lastCellBounds.yMin&&r.yMax===this._lastCellBounds.yMax||(i=!0,this._lastCellBounds=r),i&&this._clusterCells(r),i}async updateStatistics(t){let s=!1;for(const t of this._clusters.values())t.inner.count>1&&(s=this._updateAggregateStatistics(this._statistics,t.inner)||s);if(s){const s=Array.from(this._statistics.entries()).map((([t,s])=>({fieldName:t,minValue:s.minValue,maxValue:s.maxValue})));await t.container.updateStatistics(this._level,s)}}createAggregateFeatures(t,s){const e=t.subscription,i=[],r=e.tile.transform;for(const t of this._clusters.values()){let s=t.inner.getCentroidX(r);const n=t.inner.getCentroidY(r),h=e.tile.lod,o=h.wrap?h.worldSize[0]:null,a=1===t.inner.count?t.inner.firstObjectId:t.inner.id,c=t.displayId;if(null!=o)if(1===o){const e=new Ft([],[s,n]),r=new It(e,t.inner.getAttributes(),null);r.geometry.coords[0]-=L,r.objectId=a,r.displayId=c,i.push(r);const h=new Ft([],[s,n]),o=new It(h,t.inner.getAttributes(),null);o.geometry.coords[0]+=L,o.objectId=a,o.displayId=c,i.push(o)}else s>L+L/2?s-=o*L:s<-L/2&&(s+=o*L);if(s<L+Rs&&s>=-Rs&&n<L+Rs&&n>=-Rs){const e=new Ft([],[s,n]),r=new It(e,t.inner.getAttributes(),null);r.objectId=a,r.displayId=c,i.push(r)}}return ys.fromOptimizedFeatures(i,s,e.tile.transform)}_clusterCells(t){let s=Array.from(this._cells.values());s=s.sort(((t,s)=>s.count-t.count));const e=[];for(const t of this._clusters.values())e.push(t.inner.id);this._clusters.clear();const i=this._clusterRadius*(1/Es(this._indexOptions.spatialReference,this._scale)),r=1+this._clusterRadius/this._indexOptions.cellSize,n=new Set;for(const e of s){if(n.has(e.id))continue;if(e.gridX<t.xMin||e.gridX>t.xMax||e.gridY<t.yMin||e.gridY>t.yMax)continue;const s=this._store.createDisplayIdForObjectId(e.id),h=new Ps(e.clone(),s);n.add(e.id),this._clusters.set(e.id,h);const o=e.centroidXWorld,a=e.centroidYWorld;for(let t=e.gridY-r;t<=e.gridY+r;t++)for(let s=e.gridX-r;s<=e.gridX+r;s++){if(t===e.gridY&&s===e.gridX)continue;const r=this._cells.get(js.createId(s,t));if(!r||n.has(r.id))continue;const c=Math.abs(r.centroidXWorld-o),u=Math.abs(r.centroidYWorld-a);c<i&&u<i&&(h.inner.merge(r),n.add(r.id))}}for(const t of e)this._store.releaseDisplayIdForObjectId(t)}_updateAggregateStatistics(t,s){let e=!1;for(const i of s.statistics.values()){if("esriFieldTypeString"===i.field.type)continue;const s=i.value,r=i.field,n=t.get(r.name);if(n){const{minValue:t,maxValue:i}=n,r=Math.min(n.minValue,s),h=Math.max(n.maxValue,s);t===r&&i===h||(n.minValue=r,n.maxValue=h,e=!0)}else t.set(r.name,{minValue:s,maxValue:s}),e=!0}return e}}class Gs extends fs{static async create(t,s,e,i,r,n){const h=new X({spatialReference:e}),o={fields:await Promise.all(s.fields.map((async t=>us.create(h,t)))),spatialReference:e,featureFilter:s.featureFilter?await Y.create({geometryType:i.metadata.geometryType,hasM:!1,hasZ:!1,timeInfo:i.metadata.timeInfo,fieldsIndex:i.metadata.fieldsIndex,spatialReference:e,filterJSON:s.featureFilter}):null,cellSize:s.clusterRadius/4,timeZone:n};return new Gs(t,s.clusterRadius,o,s.fields,i,r)}constructor(t,s,e,i,r,n){super(r,n,e.spatialReference,e.fields),this._connection=t,this._clusterRadius=s,this._indexOptions=e,this._cellsPerScale=new Map,this._metadata=new J({geometryType:"esriGeometryPoint",objectIdField:"aggregateId",fields:[...i,...this._source.metadata.fieldsIndex.fields,{name:"aggregateId",alias:"aggregateId",type:"esriFieldTypeOID"}],globalIdField:null,spatialReference:r.metadata.spatialReference,subtypeField:null,subtypes:null,timeInfo:null,timeReferenceUnknownClient:null,typeIdField:null,types:null})}get enablePixelBuffering(){return!1}invalidate(){super.invalidate();for(const t of this._cellsPerScale.values())t.destroy();this._cellsPerScale.clear()}onSubscribe(t){super.onSubscribe(t),this._requiredLevel=t.tile.level,this._requiredScale=t.tile.scale}createState(t){return new qs(t)}async*applyOverride(t){for(const t of this._cellsPerScale.values())t.destroy();this._cellsPerScale.clear();for(const t of this._sendStates.values())t.done=!1}displayMap(t,s,e){const i=new Map(t.map((t=>[s(t),t]))),r=[],n=this._getClusterState(this._requiredLevel,this._requiredScale);for(const t of n.clusters()){const s=i.get(t.inner.id);if(null==s){if(1===t.inner.count){const s=i.get(t.inner.firstObjectId);if(null!=s){const n=e(t.displayId,s,t.inner.firstObjectId);r.push(n),i.delete(t.inner.firstObjectId)}}}else{const n=e(t.displayId,s,t.inner.id);r.push(n),i.delete(t.inner.id)}}return r}getDisplayFeatures(t){const s=new Set(t),e=new Set,i=[],r=[],n=this._getClusterState(this._requiredLevel,this._requiredScale);for(const t of n.aggregatesWorldSpace())if(s.has(t.displayId)&&!e.has(t.displayId)){const s=lt(t,this._metadata.geometryType,!1,!1);if(e.add(t.displayId),1===s.attributes.cluster_count){i.push({...s,displayId:t.displayId});continue}r.push({...s,displayId:t.displayId})}return{features:i,aggregates:r}}getFeatureObjectIdsForAggregate(t){const s=this._getClusterState(this._requiredLevel,this._requiredScale);for(const e of s.clusters())if(e.inner.id===t)return Array.from(e.inner.objectIds);return[]}async*updateChunks(){const t=this._source.chunks();if(!t.length)return;const s=this._getClusterState(this._requiredLevel,this._requiredScale),e=Array.from(this._sendStates.values()).filter((t=>t.subscription.tile.level===this._requiredLevel));if(s.updateChunks(t,e)||!this._source.updateTracking.updating)for(const t of e)t.subscription.tile.level===this._requiredLevel&&(t.didSend=!1,t.done=!1);const i=Array.from(this._sendStates.values()).filter((t=>t.done)).map((t=>t.subscription.tile.key)),r=new Set(i);for(const t of this._sendStates.values()){if(this._source.updateTracking.updating){if(i.some((s=>s.containsChild(t.subscription.tile.key))))continue;if(t.subscription.tile.key.getChildKeys().every((t=>r.has(t))))continue}t.didSend||t.subscription.tile.level!==this._requiredLevel||(t.didSend=!0,yield*this._update(t,s,this._source))}await s.updateStatistics(this._connection)}forEachAggregateWorldSpace(t){if(null==this._requiredLevel||null==this._requiredScale)return;const s=this._getClusterState(this._requiredLevel,this._requiredScale);for(const e of s.aggregatesWorldSpace())t(e)}_getClusterState(t,s){if(null==t||null==s)throw new Error("InternalError: Level and scale must be defined");let e=this._cellsPerScale.get(s);return e||(e=new $s(t,s,this._indexOptions,this._clusterRadius,this._attributeStore),this._cellsPerScale.set(s,e)),e}async*_update(t,s,e){if(t.done)return;const i=s.createAggregateFeatures(t,this._metadata);this.events.emit("changed"),t.done=!e.updateTracking.updating;const r=i.getCursor(),n=t.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.timeZone);for(;r.next();)this._attributeStore.setAttributeData(r.getDisplayId(),r,n);const h=new ps(t.subscription,i,!0,t.done,{});yield h}}class Ds{static fromReader(t){const s=[],e=t.copy(),r=i();for(;e.next();){e.getBounds(r)&&s.push(e.getIndex())}const n=a(9,(t=>(e.setIndex(t),{minX:e.getBoundsXMin(),minY:e.getBoundsYMin(),maxX:e.getBoundsXMax(),maxY:e.getBoundsYMax()})));return n.load(s),new Ds(n)}constructor(t){this._index=t}search(t){const s={minX:t[0],minY:t[1],maxX:t[2],maxY:t[3]};return this._index.search(s)}}class Os{static create(t,s,e,i){const r=Ss.create(t),n=new Array(32);for(let t=0;t<n.length;t++)n[t]=null;return new Os(r,s,e,i,n)}constructor(t,s,e,i,r){this._statistics=t,this.xNode=s,this.yNode=e,this.depth=i,this.children=r,this._objectIds=new Set,this._count=0,this._xWorldTotal=0,this._yWorldTotal=0,this._xGeohashTotal=0,this._yGeohashTotal=0,this.next=null}get id(){return`${this.xNode}.${this.yNode}`}get objectIds(){return this._objectIds}clone(){const t=new Os(this._statistics.clone(),this.xNode,this.yNode,this.depth,this.children);return t._count=this._count,t._xWorldTotal=this._xWorldTotal,t._yWorldTotal=this._yWorldTotal,t._xGeohashTotal=this._xGeohashTotal,t._yGeohashTotal=this._yGeohashTotal,t.next=this.next,t.cachedFeature=this.cachedFeature,t._objectIds=new Set(this._objectIds),t}insert(t,s,e,i,r,n){this._count+=1,this._xWorldTotal+=s,this._yWorldTotal+=e,this._xGeohashTotal+=i,this._yGeohashTotal+=r,this._statistics.insert(t,n),this._objectIds.add(t.getObjectId())}merge(t){if(0!==t._count){this._count+=t._count,this._xWorldTotal+=t._xWorldTotal,this._yWorldTotal+=t._yWorldTotal,this._xGeohashTotal+=t._xWorldTotal,this._yGeohashTotal+=t._yWorldTotal,this._statistics.merge(t._statistics);for(const s of t._objectIds.values())this._objectIds.add(s)}}getGeometry(t,s){const e=this._getLngLatBounds(),[i,r,h,o]=e,a=_t({rings:[[[i,r],[i,o],[h,o],[h,r],[i,r]]]},n.WGS84,t),c=yt(new Ft,a,!1,!1);if(null!=s){return gt(new Ft,c,!1,!1,"esriGeometryPolygon",s,!1,!1)}return c}getGeometryCentroid(t,s){const e=this._getLngLatBounds(),[i,r,h,o]=e,a=_t({x:(i+h)/2,y:(r+o)/2},n.WGS84,t),c=wt(new Ft,a);if(null!=s){return gt(new Ft,c,!1,!1,"esriGeometryPoint",s,!1,!1)}return c}getAttributes(){const t={aggregateId:this.id};for(const s of this._statistics.values())t[s.field.name]=s.value;return t.aggregateCount=this._count,t}_getLngLatBounds(){const t=this.depth,s=Math.ceil(t/2),e=Math.floor(t/2),i=30-(3*s+2*e),r=30-(2*s+3*e),n=this.xNode<<i,h=this.yNode<<r;return nt({geohashX:n,geohashY:h},this.depth)}}class Ns{constructor(t){this._fields=t,this._root=Os.create(this._fields,0,0,0)}destroy(){}insert(t,s,e,i,r,n,h){let o=this._root,a=0,c=0,u=0;for(;null!==o;){if(o.insert(t,s,e,i,r,h),a>=n)return;const l=Math.ceil((a+1)/2),d=Math.floor((a+1)/2),f=1-a%2,p=30-(3*l+2*d),g=30-(2*l+3*d),y=(i&7*f+3*(1-f)<<p)>>p,w=(r&3*f+7*(1-f)<<g)>>g,m=y+w*(8*f+4*(1-f));c=c<<3*f+2*(1-f)|y,u=u<<2*f+3*(1-f)|w,null==o.children[m]&&(o.children[m]=Os.create(this._fields,c,u,a+1)),a+=1,o=o.children[m]}}putBins(t,s){for(const e of this.getNodes(s)){const s=t.get(e.id);s?s.merge(e):t.set(e.id,e.clone())}}getNodes(t){const s=[],{geohashBounds:e,level:i}=t;let r=this._root;for(;null!==r;){const t=r.depth,n=r.xNode,h=r.yNode;if(t>=i){s.push(r),r=r.next;continue}const o=Math.ceil((t+1)/2),a=Math.floor((t+1)/2),c=1-t%2,u=30-(3*o+2*a),l=30-(2*o+3*a),d=~((1<<u)-1),f=~((1<<l)-1),p=(e.xLL&d)>>u,g=(e.yLL&f)>>l,y=(e.xTR&d)>>u,w=(e.yTR&f)>>l,m=n<<3*c+2*(1-c),b=h<<2*c+3*(1-c),S=m+8*c+4*(1-c),I=b+4*c+8*(1-c),v=Math.max(m,p),_=Math.max(b,g),M=Math.min(S,y),x=Math.min(I,w);let F=null,A=null;for(let t=_;t<=x;t++)for(let s=v;s<=M;s++){const e=s-m+(t-b)*(8*c+4*(1-c)),i=r.children[e];i&&(F||(F=i,F.next=r.next),A&&(A.next=i),A=i,i.next=r.next)}r=F||r.next}return s}}class Us{constructor(t){this._options=t,this._tree=new Ns(t.fields)}insert(t,s){const e=t.getCursor(),i={$view:{scale:0,timeZone:this._options.timeZone}};for(;e.next();)this._insertFeature(e,i,s)}putBins(t,s){this._tree.putBins(t,s)}_insertFeature(t,s,e){const{featureFilter:i,geohashLevel:r,spatialReference:n}=this._options;if(null!==i&&!i.check(t))return;let h=0,o=0;if("esriGeometryPoint"===t.geometryType)h=t.readXWorldSpace(),o=t.readYWorldSpace();else{if(e){const s=t.readCentroidForDisplay();if(null==s)return;const[e,i]=s.coords;if(e<0||e>L||i<0||i>L)return}const s=t.readCentroidWorldSpace();if(null==s)return;h=s.coords[0],o=s.coords[1]}const a=ht(h,o,r,n);a&&this._tree.insert(t,h,o,a[0],a[1],r,s)}}class Vs extends Z{static from(t,s){return new Vs(t.copy(),s)}constructor(t,s){super(t.metadata),this._currentIndex=-1,this._displayTranslationX=0,this._displayTranslationY=0,this._displayScaleX=1,this._displayScaleY=1,this._reader=t,this._indices=s,this._isPoint="esriGeometryPoint"===t.geometryType}setTransformForDisplay(t){const s=this._reader.getInTransform();if(null==s){const[s,e]=t.scale,[i,r]=t.translate;return this._displayTranslationX=-i/s,this._displayScaleX=1/s,this._displayTranslationY=r/e,this._displayScaleY=1/-e,void(this._displayTransform=t)}const[e,i]=s.scale,[r,n]=s.translate,[h,o]=t.scale,[a,c]=t.translate;if(this._displayScaleX=e/h,this._displayTranslationX=(r-a)/h,this._displayScaleY=i/o,this._displayTranslationY=(-n+c)/o,!this._isPoint&&s)throw new Error("InternalError: Relative transformations not supported for non-point features");this._displayTransform=t}getInTransform(){return this._reader.getInTransform()}get fields(){return this._reader.fields}get hasNext(){return this._currentIndex+1<this._indices.length}getSize(){return this._indices.length}getCursor(){return this.copy()}copy(){const t=new Vs(this._reader.copy(),this._indices);return t._currentIndex=this._currentIndex,t._displayTransform=this._displayTransform,t._displayTranslationX=this._displayTranslationX,t._displayTranslationY=this._displayTranslationY,t._displayScaleX=this._displayScaleX,t._displayScaleY=this._displayScaleY,t}get contextTimeZone(){return this._reader.contextTimeZone}set contextTimeZone(t){this._reader.contextTimeZone=t}_nextIndex(){return++this._currentIndex<this._indices.length&&(this._reader.setIndex(this._indices[this._currentIndex]),!0)}next(){for(;this._nextIndex()&&!this._reader._getExists(););return this._currentIndex<this._indices.length}readXForDisplay(){return this._reader.readXForDisplay()*this._displayScaleX+this._displayTranslationX}readYForDisplay(){return this._reader.readYForDisplay()*this._displayScaleY+this._displayTranslationY}readGeometryForDisplay(){const t=this._reader.readGeometryForDisplay();if(!this._displayTransform)return t;const s=new Ft;return gt(s,t,this.hasZ,this.hasM,this.geometryType,this._displayTransform),s.deltaDecode()}readCentroidForDisplay(){const t=this._reader.readCentroidForDisplay()?.clone();if(t){const[s,e]=t.coords;t.coords[0]=s*this._displayScaleX+this._displayTranslationX,t.coords[1]=e*this._displayScaleY+this._displayTranslationY}return t}get geometryType(){return this._reader.geometryType}get hasFeatures(){return this._reader.hasFeatures}get exceededTransferLimit(){return this._reader.exceededTransferLimit}get hasZ(){return this._reader.hasZ}get hasM(){return this._reader.hasM}readAttribute(t,s=!1){return this._reader.readAttribute(t,s)}readAttributes(){return this._reader.readAttributes()}joinAttributes(t){return this._reader.joinAttributes(t)}getBounds(t){return this._reader.getBounds(t)}getAttributeHash(){return this._reader.getAttributeHash()}getObjectId(){return this._reader.getObjectId()}getDisplayId(){return this._reader.getDisplayId()}setDisplayId(t){return this._reader.setDisplayId(t)}setIndex(t){return this._reader.setIndex(t)}getIndex(){return this._reader.getIndex()}readXWorldSpace(){return this._reader.readXWorldSpace()}readYWorldSpace(){return this._reader.readYWorldSpace()}_readX(){return this._reader.readXForDisplay()}_readY(){return this._reader.readYForDisplay()}_readServerCentroid(){return this._reader._readServerCentroid()}readLegacyFeatureForDisplay(){const t=this.readCentroidForDisplay();return{attributes:this.readAttributes(),geometry:this.readLegacyGeometryForDisplay(),centroid:(t&&{x:t.coords[0],y:t.coords[1]})??null}}readLegacyGeometryForDisplay(){const t=this.readGeometryForDisplay();return mt(t,this.geometryType,!1,!1)}readGeometryArea(){return this._reader.readGeometryArea()}readGeometryWorldSpace(){return this._reader.readGeometryWorldSpace()}_readGeometry(){return this._reader._readGeometry()}_readAttribute(t,s){throw new Error("Error: Should not be called. Underlying _reader should be used instead")}_readAttributes(){throw new Error("Error: Should not be called. Underlying _reader should be used instead")}readArcadeFeature(){return this._reader.readArcadeFeature()}geometry(){return this._reader.geometry()}field(t){return this.readAttribute(t,!0)}hasField(t){return this._reader.hasField(t)}setField(t,s){return this._reader.setField(t,s)}keys(){return this._reader.keys()}castToText(t=!1){return this._reader.castToText(t)}}class Bs{size(){return this.reader.getSize()}get fields(){return this.reader.fields}invalidate(){this._geohashIndex=null,this._geohashIndexHash=null,this._spatialIndex=null,this._gridIndex=null,this._gridIndexHash=null}queryFeaturesInBounds(t){const s=this._getSpatialIndex().search(t);return Vs.from(this.reader,s)}getGeohashIndex(t){const s=JSON.stringify(t);return s!==this._geohashIndexHash&&(this._geohashIndexHash=s,this._geohashIndex=new Us(t),this._geohashIndex.insert(this.reader,this.isTiled)),this._geohashIndex}getGridIndex(t){const s=JSON.stringify(t);return s!==this._gridIndexHash&&(this._gridIndexHash=s,this._gridIndex=new Ts(t),this._gridIndex.insert(this.reader,this.isTiled)),this._gridIndex}_getSpatialIndex(){return this._spatialIndex||(this._spatialIndex=Ds.fromReader(this.reader)),this._spatialIndex}}class Ls extends Bs{constructor(t){super(),this.metadata=t,this.chunkId="override",this.normalizedChunkId="override",this.removed=new Set,this.overridenIds=new Set,this._features=[]}get reader(){return ys.fromOptimizedFeatures(this._features,this.metadata)}get queryInfo(){return{}}get first(){return!1}get end(){return!1}get isTiled(){return!1}applyOverrides(t){super.invalidate();const{reader:s,removed:e}=t,i=[],r=new Set,n=s.getCursor(),h=new Set(e);for(this.overridenIds.clear();n.next();){const t=n.readOptimizedFeatureWorldSpace(),s=t.objectId;i.push(t),r.add(s),this.overridenIds.add(s),this.removed.delete(s)}for(const t of this._features){const s=t.objectId;h.has(s)||r.has(s)||(i.push(t),this.overridenIds.add(s))}this._features=i;for(const t of r.values())this.removed.delete(t);for(const t of e)this.removed.add(t),this.overridenIds.add(t)}getTileReader(t){if(!this._features.length)return null;const s=this.queryFeaturesInBounds(t.bounds);return s.setTransformForDisplay(t.transform),s}}class zs extends ls{}class Ws extends ds{constructor(t,s,e){super(t,s),this._timeZone=e,this.handledChunks=new Set,this.handledChunksForIdCreation=new Set,this.handledChunksForAttributeData=new Set,this._streamLayerDeferredObjectIdsToRemove=[]}destroy(){super.destroy();for(const t of this._source.chunks())this._cleanupChunkIds(t)}invalidateAttributeData(){this.handledChunksForAttributeData.clear()}onSubscribe(t){super.onSubscribe(t),this._evalOptions=t.tile.createArcadeEvaluationOptions(this._timeZone)}createState(t){return new zs(t)}get aggregateQueryEngine(){return null}displayMap(t,s,e){const i=new Map(t.map((t=>[s(t),t]))),r=[];for(const t of this._source.chunks()){const s=t.reader.getCursor();for(;s.next();){const t=s.getObjectId(),n=s.getDisplayId(),h=i.get(t);if(null!=h){const s=e(n,h,t);r.push(s),i.delete(t)}}}return r}getDisplayFeatures(t){const s=new Set(t),e=new Set,i=[];for(const t of this._source.chunks()){const r=t.reader.getCursor();for(;r.next();){const t=r.getObjectId(),n=r.getDisplayId();s.has(n)&&!e.has(t)&&(i.push({...r.readLegacyFeatureWorldSpace(),displayId:n}),e.add(t))}}return{features:i,aggregates:[]}}async*applyOverride(t){const s=[],e=t.reader.getCursor();for(;e.next();){const t=e.getObjectId();s.push(t);const i=this._attributeStore.createDisplayIdForObjectId(t);e.setDisplayId(i),this._attributeStore.setAttributeData(i,e,this._evalOptions)}const i=this.getDisplayIds(s),r=this.getDisplayIds(t.removed),n=new Ls(this._source.metadata);n.applyOverrides(t),this.handledChunks.add(n.chunkId),this.handledChunksForAttributeData.add(n.chunkId),this.handledChunksForIdCreation.add(n.chunkId);for(const t of this._sendStates.values())t.handledChunks.add(n.chunkId),yield new gs(t.subscription,null,i,!1,n.queryInfo);for(const t of this._sendStates.values()){const s=n.getTileReader(t.subscription.tile);yield new gs(t.subscription,s,r,!1,n.queryInfo)}for(const s of t.removed)this._attributeStore.releaseDisplayIdForObjectId(s)}async*updateChunks(){if(this._source.chunks().length){await this._updateAttributeData();for(const t of this._sendStates.values())yield*this._update(t)}}removeChunks(t){for(const s of t)this.handledChunks.delete(s.chunkId),this.handledChunksForAttributeData.delete(s.chunkId),this._cleanupChunkIds(s)}afterUpdateChunks(){for(const t of this._streamLayerDeferredObjectIdsToRemove)this._attributeStore.releaseDisplayIdForObjectId(t);this._streamLayerDeferredObjectIdsToRemove=[]}_cleanupChunkIds(t){if(this.handledChunksForIdCreation.has(t.chunkId)){const s=t.reader.getCursor();for(;s.next();){const t=s.getObjectId();this._source.isStream?this._streamLayerDeferredObjectIdsToRemove.push(t):this._attributeStore.releaseDisplayIdForObjectId(t)}this.handledChunksForIdCreation.delete(t.chunkId)}}async _updateAttributeData(){for(const t of this._source.chunks()){const{chunkId:s,reader:e}=t;if(!this.handledChunksForIdCreation.has(s)){this.handledChunksForIdCreation.add(s);const t=e.getCursor();for(;t.next();){const s=this._attributeStore.createDisplayIdForObjectId(t.getObjectId());t.setDisplayId(s)}}}for(const t of this._source.chunks())if(!this.handledChunksForAttributeData.has(t.chunkId)){this.handledChunksForAttributeData.add(t.chunkId);const s=t.reader.getCursor();for(;s.next();){const t=s.getDisplayId();this._attributeStore.setAttributeData(t,s,this._evalOptions)}}}*_update(t){const{subscription:s,handledChunks:e}=t;for(const i of this._source.chunks()){const{chunkId:r}=i;if(e.has(r))continue;e.add(r);const n=i.getTileReader(s.tile);n&&(yield new ps(t.subscription,n,!1,i.end,i.queryInfo))}}}class Qs{constructor(t,s){this._connection=t,this._source=s,this._version=1,this._proxy=new K({fetch:(t,s)=>this._connection.layerView.fetch(t,s),fetchDictionary:(t,s)=>this._connection.layerView.fetchDictionary(t,s)}),this._attributeStore=new tt({isLocal:!1,update:t=>c(this._connection.container.updateAttributeView(t))})}destroy(){this._proxy.destory(),this._strategy?.destroy(),this._attributeStore.destroy()}get aggregateQueryEngine(){return this._strategy?.aggregateQueryEngine}getDisplayFeatures(t){return this._strategy?this._strategy.getDisplayFeatures(t):{features:[],aggregates:[]}}getFeatureObjectIdsForAggregate(t){return this._strategy?this._strategy.getFeatureObjectIdsForAggregate(t):[]}onSubscribe(t){this._strategy?.onSubscribe(t)}onUnsubscribe(t){this._strategy?.onUnsubscribe(t)}async update(t,s,e,i,r){const h=t.processor,o=u(this._schema,h);if(!o&&!i)return;l("esri-2d-update-debug")&&console.debug(`Version[${this._version}] SymbolProcessor.update`,{changes:o,schema:h}),this._schema=h;const a=n.fromJSON(t.source.mutable.dataFilter.outSpatialReference),c=new X({fields:this._source.metadata.fieldsIndex,spatialReference:a});return await this._attributeStore.update(h.storage,c,this._source.metadata,a,s),this._strategy?.invalidateAttributeData(),i||d(o,"mesh")?(d(o,"mesh.strategy")&&await this._updateStrategy(h.mesh.strategy,a,r,h.mesh.timeZone),this._updateSortKey(c,"sortKey"in h.mesh?h.mesh.sortKey:null),(d(o,"mesh.factory")||"dictionary"===h.mesh.factory.symbology.type)&&(this._factory=await as.create(c,this._proxy,h.mesh.factory,e)),this._invalidate(),this._version=s,this._connection.container.updateRenderState(this._version)):void 0}async applyOverride(t){if(!this._strategy)return;const s=this._strategy.applyOverride(t);for await(const t of s)try{await this._process(t)}catch(t){}this._source.applyOverride(t)}async updateChunks(){await this._doUpdateChunks(),this._strategy?.afterUpdateChunks()}async removeChunks(t){this._strategy?.removeChunks(t),this._attributeStore.incrementDisplayIdGeneration()}updateHighlight({highlights:t}){if(!this._strategy)return void this._attributeStore.setHighlight(t.map((({objectId:t,highlightFlags:s})=>({objectId:t,highlightFlags:s,displayId:-1}))),t);const s=this._strategy.displayMap(t,(({objectId:t})=>t),((t,{highlightFlags:s},e)=>({objectId:e,displayId:t,highlightFlags:s})));this._attributeStore.setHighlight(s,t)}async _doUpdateChunks(){if(!this._strategy)return;const t=this._strategy.updateChunks(),s=[],e=new Map;for await(const i of t){let t=e.get(i.id);null==t&&(t=new cs({concurrency:16,process:t=>this._process(t)}),e.set(i.id,t));const r=t.push(i).catch((t=>f(t)));s.push(r)}try{await Promise.all(s)}catch(t){}l("esri-2d-update-debug")&&console.log("SendUpdates"),await this._attributeStore.sendUpdates(),l("esri-2d-update-debug")&&console.log("SendUpdates.await")}async _updateStrategy(t,s,e,i){switch(this._strategy?.destroy(),t.type){case"feature":this._strategy=new Ws(this._source,this._attributeStore,i);break;case"binning":this._strategy=await ms.create(t,s,this._source,this._attributeStore,i);break;case"cluster":this._strategy=await Gs.create(this._connection,t,s,this._source,this._attributeStore,i)}for(const t of e)this._strategy.onSubscribe(t)}async _updateSortKey(t,s){if(this._sortInfo=p(this._sortInfo?.computed),null!=s){const e=s.byRenderer?null:await t.createComputedField(s);this._sortInfo={...s,computed:e}}}_invalidate(){this._strategy&&this._strategy.invalidate()}async _process(t){const s=t.subscription;if(l("esri-2d-update-debug")){const e=s.tile;console.debug(`Version[${this._version}] Tile[${e.key.id}, end=${t.end}] Processor._process`)}await this._fetchResources(t),g(s.signal);const e=await this._write(t,s.tile.createArcadeEvaluationOptions(this._schema.mesh.timeZone)),i=s.tile.tileInfoView.tileInfo.isWrappable,{message:r,transferList:n}=e.serialize(i),h=t.createMessage(r,this._version,this._attributeStore.epoch);if(g(s.signal),this._connection.container.onMessage(h,{signal:s.signal,transferList:n}),this._attributeStore.sendUpdates(),l("esri-2d-update-debug")){const e=s.tile;console.debug(`Version[${this._version}] Tile[${e.key.id}, end=${t.end}] Processor._process.await`)}}async _fetchResources(t){await this._fetchMatcherResources(t),await this._fetchWriterResources(t)}async _fetchMatcherResources(t){if(t.reader)return this._factory.enqueueMatcherRequests(this._proxy,t.reader)}async _fetchWriterResources(t){if(!t.reader)return;const s=t.reader.getCursor(),e=t.subscription.tile.createArcadeEvaluationOptions(this._schema.mesh.timeZone);for(;s.next();)this._factory.enqueueWriterRequests(this._proxy,s,e);await this._proxy.fetchEnqueuedResources()}async _write(t,s){const e=t.subscription.tile,i=t.reader?.getCursor(),r=i?.getSize()??0,n=e.tileInfoView.tileInfo.isWrappable,h=new Ht(e.key,this._strategy.enablePixelBuffering,n,r);if(!i)return h;const o=e.createArcadeEvaluationOptions(this._schema.mesh.timeZone);for(;i.next();){const t=this._getSortKeyValue(i,s);h.entityStart(i.getDisplayId(),t),this._factory.write(h,this._proxy,i,o,e.level),h.entityEnd()}return h}_getSortKeyValue(t,s){if(!this._sortInfo)return 0;const{computed:e,order:i,byRenderer:r}=this._sortInfo,n=r?this._factory.getSortKey(t,s):e?.read(t,s);return null==n||isNaN(n)?0:n*("asc"===i?-1:1)}}class Zs{static from(t){let s=0,e=0,i=0;return t.forEach((t=>{const r=t._readGeometry();r&&(e+=r.isPoint?1:r.lengths.reduce(((t,s)=>t+s),0),i+=r.isPoint?1:r.lengths.length,s+=1)})),new Zs(s,e,i)}constructor(t,s,e){this.featureCount=t,this.vertexCount=s,this.ringCount=e}toJSON(){return{featureCount:this.featureCount,ringCount:this.featureCount,vertexCount:this.featureCount}}}const Xs=4;function Ys(t,s){const{service:e}=t,i=e.orderByFields??s.objectIdField+" ASC",r=e.source,h={returnCentroid:!(null!==r&&"object"==typeof r&&"path"in r&&w(r.path))&&"esriGeometryPolygon"===s.geometryType,returnGeometry:!0,timeReferenceUnknownClient:s.timeReferenceUnknownClient??void 0,outSpatialReference:n.fromJSON(t.mutable.dataFilter.outSpatialReference),orderByFields:[i],where:t.mutable.dataFilter.definitionExpression??"1=1",outFields:t.mutable.availableFields};if("feature"===t.type){const{gdbVersion:s,historicMoment:e,timeExtent:i}=t.mutable.dataFilter;return{...h,gdbVersion:s,historicMoment:e?new Date(e):null,timeExtent:i?m.fromJSON(i):null,outFields:t.mutable.availableFields}}return h}class Js{static fromSchema(t,s){return new Js(Ys(t,s),t.mutable.dataFilter.customParameters,s.geometryType,t.service.queryMetadata.capabilities)}constructor(t,s,e,i){this._queryParams=t,this._customParameters=s,this._geometryType=e,this._capabilities=i}get pageSize(){if(null==this._capabilities)throw new Error("InternalError: Service does not support paged queries");const{query:t}=this._capabilities,s=t.supportsMaxRecordCountFactor?Xs:null,e=(t.maxRecordCount??8e3)*(s??1);return Math.min(8e3,e)}updateFields(t){this._queryParams.outFields=t}createPatchFieldsQuery(t,s){const e=t.clone();if("*"===this._queryParams.outFields[0]){if("*"===(e.outFields??[])[0])return null;e.outFields=this._queryParams.outFields}else{const t=new Set(this._queryParams.outFields),i=[];for(const e of t)s.hasField(e)||i.push(e);if(0===i.length)return null;e.outFields=i}return e.returnGeometry=!1,e.returnCentroid=!1,e.quantizationParameters=null,e.cacheHint=!0,{inner:e,customParameters:this._customParameters}}createQuery(t={}){if(!this._queryParams)throw new Error("InternalError: queryInfo should be defined");return{inner:new y({...this._queryParams,...t}),customParameters:this._customParameters}}createTileQuery(t,s){if(null==this._capabilities)throw new Error("InternalError: Service does not support tile queries");const e=this.createQuery(s),i=e.inner;return i.quantizationParameters=s.quantizationParameters??t.getQuantizationParameters(),i.resultType="tile",i.geometry=t.extent,this._capabilities.query.supportsQuantization?"esriGeometryPolyline"===this._geometryType&&(i.maxAllowableOffset=t.resolution*l("feature-polyline-generalization-factor")):"esriGeometryPolyline"!==this._geometryType&&"esriGeometryPolygon"!==this._geometryType||(i.maxAllowableOffset=t.resolution,"esriGeometryPolyline"===this._geometryType&&(i.maxAllowableOffset*=l("feature-polyline-generalization-factor"))),i.defaultSpatialReferenceEnabled=this._capabilities.query.supportsDefaultSpatialReference,i.compactGeometryEnabled=this._capabilities.query.supportsCompactGeometry,this._capabilities.query.supportsMaxRecordCountFactor&&(i.maxRecordCountFactor=Xs),e}createPagedTileQuery(t,s){const e=this.pageSize;return this.createTileQuery(t,{start:e*s,num:e,returnExceededLimitFeatures:!0})}createPagedQuery(t){const s=this.pageSize;return this.createQuery({start:s*t,num:s,returnExceededLimitFeatures:!0,maxRecordCountFactor:Xs})}}const Hs=2500;let Ks=class extends v{constructor(t){super(),this._connection=t,this._enabledEventTypes=new Set,this._updateInfo={websocket:0,client:0},this._lastTime=performance.now(),this.addHandles([_((()=>this._strategy?.connectionStatus??"disconnected"),(t=>{this._layerView.setProperty({propertyName:"pipelineConnectionStatus",value:t})}),{initial:!0}),_((()=>this._strategy?.errorString||null),(t=>this._layerView.setProperty({propertyName:"pipelineErrorString",value:t})),{initial:!0})])}destroy(){this._strategy=null,this.removeAllHandles()}get _layerView(){return this._connection.layerView}set strategy(t){null==this._strategy&&this._resetUpdateInfo(performance.now());const s="event-handles";this.removeHandles(s),null!=t&&this.addHandles([t.events.on("data-received",(t=>this._onFeature(t))),t.events.on("message-received",(t=>this._onWebSocketMessage(t))),t.events.on("features-updated",(t=>this._onUpdate(t))),t.events.on("tick",(()=>this._onTick()))],s),this._strategy=t}updateCustomParameters(t){null!=t&&this._strategy?.updateCustomParameters(t)}sendMessageToSocket(t){this._strategy?.sendMessageToSocket(t)}sendMessageToClient(t){this._strategy?.sendMessageToClient(t)}enableEvent(t,s){s?this._enabledEventTypes.add(t):this._enabledEventTypes.delete(t)}disconnect(){this._strategy?.disconnect()}connect(){this._strategy?.connect()}clear(){this._strategy?.clear()}_onWebSocketMessage(t){this._enabledEventTypes.has("message-received")&&this._layerView.emitEvent({name:"message-received",event:t})}_onFeature(t){this._updateInfo.websocket++,this._enabledEventTypes.has("data-received")&&this._layerView.emitEvent({name:"data-received",event:{attributes:t.attributes,centroid:t.centroid,geometry:t.geometry}})}_onUpdate(t){this._updateInfo.client+=t}_onTick(){const t=performance.now(),s=t-this._lastTime;if(s>Hs){const e=Math.round(this._updateInfo.client/(s/1e3)),i=Math.round(this._updateInfo.websocket/(s/1e3));this._resetUpdateInfo(t),this._layerView.emitEvent({name:"update-rate",event:{client:e,websocket:i}})}}_resetUpdateInfo(t){this._lastTime=t,this._updateInfo.client=0,this._updateInfo.websocket=0}};b([S()],Ks.prototype,"_strategy",void 0),Ks=b([I("esri.views.2d.layers.features.sources.StreamMessenger")],Ks);class te{constructor(t){this._store=t,this._controller=new AbortController}destroy(){this._controller.abort()}get _options(){return{signal:this._controller.signal}}async queryOverride(t){throw new Error("InternalError: LoadStrategy does not support fetching")}}const se=268435455;class ee{constructor(){this.hasFeatures=!1,this.exceededTransferLimit=!1,this.fieldCount=0,this.featureCount=0,this.objectIdFieldIndex=0,this.vertexCount=0,this.offsets={attributes:new Array,geometry:new Array},this.centroid=new Array}}function ie(t,s,e=!1){const i=1,n=3,h=9,o=12,a=13,c=15,u=t.asUnsafe(),l=u.pos(),d=new ee;let f=0,p=0;const g=1,y=2,w=4,m=3;let b=null,S=null,I=null,v=!1;const _=[];for(;u.next();)switch(u.tag()){case i:b=u.getString();break;case n:S=u.getString();break;case o:I=u.processMessage(Pt);break;case h:if(d.exceededTransferLimit=u.getBool(),d.exceededTransferLimit){d.offsets.geometry=e?new Float64Array(8e3):new Int32Array(8e3),d.centroid=e?new Float64Array(16e3):new Int32Array(16e3);for(let t=0;t<d.centroid.length;t++)d.centroid[t]=se}break;case a:{const t=u.processMessage(Tt);t.index=f++,_.push(t);break}case c:{const t=u.getLength(),i=u.pos()+t;if(!d.exceededTransferLimit){const t=d.offsets.geometry,s=d.centroid;t.push(0),s.push(se),s.push(se)}!v&&d.exceededTransferLimit&&(v=!0,d.offsets.attributes=e?new Float64Array(8e3*f):new Uint32Array(8e3*f));let r=p*f;for(;u.pos()<i&&u.next();)switch(u.tag()){case g:{if(v)d.offsets.attributes[r++]=u.pos();else{d.offsets.attributes.push(u.pos())}const t=u.getLength();u.skipLen(t);break}case y:if(s){const t=u.getLength(),s=u.pos()+t;for(;u.pos()<s&&u.next();)switch(u.tag()){case m:{u.getUInt32();const t=u.getSInt64(),s=u.getSInt64();d.centroid[2*p]=t,d.centroid[2*p+1]=s;break}default:u.skip()}}else{d.offsets.geometry[p]=u.pos();const t=u.getLength();d.vertexCount+=t,u.skipLen(t)}break;case w:{const t=u.getLength(),s=u.pos()+t;for(;u.pos()<s&&u.next();)switch(u.tag()){case m:{u.getUInt32();const t=u.getSInt64(),s=u.getSInt64();d.centroid[2*p]=t,d.centroid[2*p+1]=s;break}default:u.skip()}break}default:u.skip()}p++,d.hasFeatures=!0;break}default:u.skip()}const x=b||S;if(!x)throw new M("FeatureSet has no objectId or globalId field name");return d.fields=new r(_),d.featureCount=p,d.fieldCount=f,d.objectIdFieldIndex=d.fields.get(x)?.index,d.transform=I,d.displayIds=new Uint32Array(d.featureCount),d.groupIds=new Uint16Array(d.featureCount),u.move(l),d}const re=!0,ne=268435455,he=128,oe=128e3,ae={small:{delta:new Int32Array(he),decoded:new Int32Array(he)},large:{delta:new Int32Array(oe),decoded:new Int32Array(oe)}};function ce(t){return t<=ae.small.delta.length?ae.small:(t<=ae.large.delta.length||(ae.large.delta=new Int32Array(Math.round(1.25*t)),ae.large.decoded=new Int32Array(Math.round(1.25*t))),ae.large)}function ue(t){try{const s=2,e=new Et(new Uint8Array(t),new DataView(t));for(;e.next();){if(e.tag()===s)return le(e.getMessage());e.skip()}}catch(t){const s=new M("query:parsing-pbf","Error while parsing FeatureSet PBF payload",{error:t});F.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF").error(s)}return null}function le(t){const s=1;for(;t.next();){if(t.tag()===s)return t.getMessage();t.skip()}return null}function de(t){const s=1,e=2,i=3,r=4,n=5,h=6,o=7,a=8,c=9,u=t.getLength(),l=t.pos()+u;for(;t.pos()<l&&t.next();)switch(t.tag()){case s:return t.getString();case e:return t.getFloat();case i:return t.getDouble();case r:return t.getSInt32();case n:return t.getUInt32();case h:return t.getInt64();case o:return t.getUInt64();case a:return t.getSInt64();case c:return t.getBool();default:return t.skip(),null}return null}function fe(t,s,e,i,r,n){return.5*Math.abs(t*i+e*n+r*s-t*n-e*s-r*i)}function pe(t,s,e,i){return 0===t*i-e*s&&t*e+s*i>0}class ge extends Z{static fromBuffer(t,s,e=!1){const i=s.geometryType,r=ue(t),n=ie(r,"esriGeometryPoint"===i,e);return new ge(r,n,s)}constructor(t,s,e){super(e),this._hasNext=!1,this._isPoints=!1,this._featureIndex=-1,this._featureOffset=0,this._cache={area:0,unquantGeometry:void 0,geometry:void 0,centroid:void 0,legacyFeature:void 0,optFeature:void 0},this._parseCaches=new Array,this._geometryType=e.geometryType,this._reader=t,this._header=s,this._hasNext=s.hasFeatures,this._isPoints="esriGeometryPoint"===e.geometryType}get _size(){return this._header.featureCount}get fields(){return this._header.fields}get geometryType(){return this._geometryType}get hasZ(){return!1}get hasM(){return!1}get hasFeatures(){return this._header.hasFeatures}get hasNext(){return this._hasNext}get exceededTransferLimit(){return this._header.exceededTransferLimit}getSize(){return this._size}getInTransform(){return this._header.transform}getCursor(){return this.copy()}getIndex(){return this._featureIndex}setIndex(t){this._cache.area=0,this._cache.unquantGeometry=void 0,this._cache.geometry=void 0,this._cache.centroid=void 0,this._cache.legacyFeature=void 0,this._cache.optFeature=void 0,this._featureIndex=t}getAttributeHash(){let t="";for(const s of this._header.fields.fields)t+=this._readAttributeAtIndex(s.index)+".";return t}getObjectId(){return this._readAttributeAtIndex(this._header.objectIdFieldIndex)}getDisplayId(){return this._header.displayIds[this._featureIndex]}setDisplayId(t){this._header.displayIds[this._featureIndex]=t}readGeometryArea(){return this._cache.area||this._readGeometry(!0),this._cache.area}copy(){const t=this._reader.clone(),s=new ge(t,this._header,this.metadata);return this.copyInto(s),s}next(){for(this._cache.area=0,this._cache.unquantGeometry=void 0,this._cache.geometry=void 0,this._cache.centroid=void 0,this._cache.legacyFeature=void 0,this._cache.optFeature=void 0;++this._featureIndex<this._size&&!this._getExists(););return this._featureIndex<this._size}_readX(){return this._header.centroid[2*this._featureIndex]}_readY(){return this._header.centroid[2*this._featureIndex+1]}_readServerCentroid(){const t=this._header.centroid[2*this._featureIndex],s=this._header.centroid[2*this._featureIndex+1];return t===ne?null:new Ft([],[t,s])}_readGeometry(t=!1){if(void 0===this._cache.geometry){let s=null;if(this._isPoints){if(this._header.centroid[2*this._featureIndex]===ne)return null;const t=this._header.centroid[2*this._featureIndex],e=this._header.centroid[2*this._featureIndex+1];s=new Ft([],[t,e])}else{const e=this._header.offsets.geometry[this._featureIndex],i=this._reader;if(0===e)return null;i.move(e);try{s=t?this._parseGeometryForDisplay(i):this._parseGeometry(i)}catch(t){return console.error("Failed to parse geometry!",t),null}}return 0===s?.coords.length&&(s=null),this._cache.geometry=s,s}return this._cache.geometry}_readAttribute(t,s){const e=this._header.fields.get(t);if(null==e)return;let i=this._readAttributeAtIndex(e.index);"esriFieldTypeTimestampOffset"===this.fields.get(t)?.type&&(i=this.parseTimestampOffset(i));const r=this._header.fields.isDateField(e.name);return s?null==i?i:r?new Date(i):i:i}_readAttributes(){const t={};for(const s of this._header.fields.fields)t[s.name]=this._readAttributeAtIndex(s.index);return t}copyInto(t){super.copyInto(t),t._featureIndex=this._featureIndex,t._featureOffset=this._featureOffset,t._hasNext=this._hasNext,t._parseCaches=this._parseCaches}_readAttributeAtIndex(t){let s=this._parseCaches[t];if(s||(s=new st(this.getSize()),this._parseCaches[t]=s),s.has(this._featureIndex))return s.get(this._featureIndex);const e=this._header.offsets.attributes[this._featureIndex*this._header.fieldCount+t],i=this._reader;i.move(e);const r=de(i);return s.set(this._featureIndex,r),r}_readGeometryDeltaDecoded(t=!1){if(void 0===this._cache.unquantGeometry){const s=this._readGeometry(t);if(!s)return this._cache.unquantGeometry=void 0,null;if(!this.getInTransform())return this._cache.unquantGeometry=s,s;const e=ce(s.coords.length).decoded,i=s.clone(e),r=i.coords;let n=0;for(const t of i.lengths){for(let s=1;s<t;s++){const t=2*(n+s),e=2*(n+s-1);r[t]+=r[e],r[t+1]+=r[e+1]}n+=t}return this._cache.unquantGeometry=i,i}return this._cache.unquantGeometry}_parseGeometry(t){const s=2,e=3,i=t.asUnsafe(),r=i.getLength(),n=i.pos()+r,h=[],o=[];for(;i.pos()<n&&i.next();)switch(i.tag()){case s:{const t=i.getUInt32(),s=i.pos()+t;for(;i.pos()<s;)o.push(i.getUInt32());break}case e:{const t=i.getUInt32(),s=i.pos()+t;for(h.push(i.getSInt64()),h.push(i.getSInt64()),this.hasZ&&i.getSInt64(),this.hasM&&i.getSInt64();i.pos()<s;)h.push(i.getSInt64()),h.push(i.getSInt64()),this.hasZ&&i.getSInt64(),this.hasM&&i.getSInt64();break}default:i.skip()}return new Ft(o,h)}_parseGeometryForDisplay(t){const s=2,e=3,i=t.asUnsafe(),r=i.getLength(),n=i.pos()+r,h=[],o=[];let a=0,c=0,u=null,l=0;const d="esriGeometryPolygon"===this.geometryType;for(;i.pos()<n&&i.next();)switch(i.tag()){case s:{const t=i.getUInt32(),s=i.pos()+t;for(;i.pos()<s;){const t=i.getUInt32();h.push(t),a+=t}u=ce(2*a).delta;break}case e:{i.getUInt32();const t=2+(this.hasZ?1:0)+(this.hasM?1:0);x(u);for(const s of h)if(c+t*s>u.length)for(let t=0;t<s;t++)i.getSInt32(),i.getSInt32(),this.hasZ&&i.getSInt32(),this.hasM&&i.getSInt32();else if(d&&re){const t=this.getAreaSimplificationThreshold(s,this._header.vertexCount);let e=2,r=1;const n=!1;let h=i.getSInt32(),a=i.getSInt32();u[c++]=h,u[c++]=a,this.hasZ&&i.getSInt32(),this.hasM&&i.getSInt32();let d=i.getSInt32(),f=i.getSInt32();for(this.hasZ&&i.getSInt32(),this.hasM&&i.getSInt32();e<s;){let s=i.getSInt32(),n=i.getSInt32();this.hasZ&&i.getSInt32(),this.hasM&&i.getSInt32();const o=h+d,p=a+f;fe(h,a,o,p,o+s,p+n)>=t?(l+=-.5*(o-h)*(p+a),r>1&&pe(u[c-2],u[c-1],d,f)?(u[c-2]+=d,u[c-1]+=f):(u[c++]=d,u[c++]=f,r++),h=o,a=p):(s+=d,n+=f),d=s,f=n,e++}r<3||n?c-=2*r:(l+=-.5*(h+d-h)*(a+f+a),pe(u[c-2],u[c-1],d,f)?(u[c-2]+=d,u[c-1]+=f,o.push(r)):(u[c++]=d,u[c++]=f,o.push(++r)))}else{let t=0,e=i.getSInt32(),r=i.getSInt32();this.hasZ&&i.getSInt32(),this.hasM&&i.getSInt32(),u[c++]=e,u[c++]=r,t+=1;for(let n=1;n<s;n++){const s=i.getSInt32(),h=i.getSInt32(),o=e+s,a=r+h;l+=-.5*(o-e)*(a+r),this.hasZ&&i.getSInt32(),this.hasM&&i.getSInt32(),n>2&&pe(u[c-2],u[c-1],s,h)?(u[c-2]+=s,u[c-1]+=h):(u[c++]=s,u[c++]=h,t+=1),e=o,r=a}o.push(t)}break}default:i.skip()}return this._cache.area=l,o.length?new Ft(o,u):null}}class ye{constructor(t,s){this.service=t,this._metadata=s}destroy(){}}function we(t,s){switch(t.type){case"memory":return new be(t,s);case"ogc":return new ve(t,s);case"feature-service":return t.queryMetadata.capabilities.query.supportsFormatPBF&&l("featurelayer-pbf")?new Se(t,s):new Ie(t,s)}}async function me(t){const s=new A;return await s.open(t,{}),s}class be extends ye{constructor(t,s){super(t,s),this._portsOpen=me(t.source).then((t=>this.client=t))}destroy(){this.client.close(),this.client=null}async executeQuery(t,s){await this._portsOpen;const e=await this.client.invoke("queryFeatures",t.toJSON(),s);return ys.fromFeatureSet(e,this._metadata)}}class Se extends ye{async executeQuery(t,s){const{data:e}=await At(this.service.source,t,s),i=!t.quantizationParameters;return ge.fromBuffer(e,this._metadata,i)}}class Ie extends ye{async executeQuery(t,s){const{source:e,queryMetadata:i}=this.service,r=i.capabilities;if(null!=t.quantizationParameters&&!r.query.supportsQuantization){const i=t.clone(),r=C(i.quantizationParameters);i.quantizationParameters=null;const{data:n}=await Ct(e,i,this._metadata.spatialReference,s),h=ct(n,this._metadata.objectIdField);return bt(r,h),ys.fromOptimizedFeatureSet(h,this._metadata)}const{data:n}=await Ct(e,t,this._metadata.spatialReference,s);return"esriGeometryPoint"===this._metadata.geometryType&&(n.features=n.features?.filter((t=>{if(null!=t.geometry){const s=t.geometry;return Number.isFinite(s.x)&&Number.isFinite(s.y)}return!0}))),ys.fromFeatureSet(n,this._metadata)}}class ve extends ye{async executeQuery(t,s){const{capabilities:e}=this.service.queryMetadata;if(t.quantizationParameters&&!e.query.supportsQuantization){const e=t.clone(),i=C(e.quantizationParameters);e.quantizationParameters=null;const r=await kt(this.service.source,t,s);return bt(i,r),ys.fromOptimizedFeatureSet(r,this._metadata)}const i=await kt(this.service.source,t,s);return ys.fromOptimizedFeatureSet(i,this._metadata)}}class _e extends te{constructor(t,e,i,r,n){super(i),this._serviceInfo=t,this._queryInfo=e,this._metadata=r,this._eventLog=n,this._queue=new s({concurrency:16,process:async t=>{const s={signal:t.options?.signal,query:t.query.customParameters};return this._adapter.executeQuery(t.query.inner,s)}}),this._adapter=we(t,r)}async updateFields(t){this._queryInfo.updateFields(t);const s=Array.from(this._store.chunks()).map((async t=>{const s=y.fromJSON(t.queryInfo.queryJSON);if(s)try{return await this._tryUpdateFields(t.reader,s),null}catch(t){return t}})),e=(await Promise.all(s)).filter((t=>t));if(e.length)throw new M("featurelayer-query","Encountered errors when downloading fields",{errors:e})}async queryOverride({edits:t}){const s=[],e=[];for(const i of t.removed)null!=i.objectId&&-1!==i.objectId?s.push(i.objectId):e.push(i.globalId);e.length&&s.push(...this._mapGlobalIdsToObjectIds(e));const i=t.addOrModified.map((({objectId:t})=>t));let r;if(i.length){const t=this._queryInfo.createQuery({objectIds:i});r=await this._fetch(t)}else r=ys.empty(this._metadata);return{reader:r,removed:s}}_mapGlobalIdsToObjectIds(t){const s=new Set(t),e=this._metadata.globalIdField;if(null==e)throw new Error("InternalError: Recieved an edit with globalIds, but not supported by the service");const i=[];return this._store.forEachUnsafe((t=>{const r=t.readAttribute(e);s.has(r)&&i.push(t.getObjectId())})),i}async _fetch(t,s){const e=await this._enqueue(t,s);return await this._tryUpdateFields(e,t.inner),e}async _tryUpdateFields(t,s){const e=this._queryInfo.createPatchFieldsQuery(s,t);if(!e)return;const i=await this._enqueue(e,this._options);t.joinAttributes(i)}async _enqueue(t,s){return this._eventLog.onEvent({type:"fetchStart"}),this._queue.push({query:t,options:s}).finally((()=>{this._eventLog.onEvent({type:"fetchEnd",done:0===this._queue.length})}))}}class Me extends _e{constructor(){super(...arguments),this._chunksById=new Map}unload(t){this._removeChunks(t.tile)}_addChunk(t){const s=t.tile.id;this._chunksById.has(s)||this._chunksById.set(s,[]);const e=t.size();(e||t.first||t.end)&&(l("esri-2d-update-debug")&&console.debug(`Chunk[${t.chunkId}] ATileLoadStrategy.addChunk [count=${e}]`),this._chunksById.get(s).push(t),this._store.insert(t))}_removeChunks(t){const s=this._chunksById.get(t.key.id)??[];for(const e of s)l("esri-2d-update-debug")&&console.debug(`Tile[${t.key.id}] Chunk[${e.chunkId}] ATileLoadStrategy.removeChunk`),this._store.remove(e);this._chunksById.delete(t.key.id)}}class xe extends Bs{constructor(t,s,e,i,r,n){super(),this._reader=t,this._queryJSON=s,this._tile=e,this._sourceTile=i,this._sourceTileDepth=r,this._end=n,this.chunkId=`${this._tile.key.id}.${this._sourceTile?.key.id}${this._end?"e":""}`,this.normalizedChunkId=`${this._tile.key.normalizedId}.${this._sourceTile?.key.normalizedId}${this._end?"e":""}`}get queryInfo(){return{type:"drill-down-tile",chunkId:this.chunkId,tileId:this._tile.key.id,queryJSON:this._queryJSON,sourceTileDepth:this._sourceTileDepth,sourceTileId:this._sourceTile?.key.id,size:this.size(),end:this.end}}get first(){return 0===this._sourceTileDepth}get reader(){return this._reader}get end(){return this._end}get tile(){return this._tile}get isTiled(){return!0}getTileReader(t){return this._tile.key.id===t.key.id?this.reader:null}}class Fe{constructor(t,s){this.subscription=t,this._tileIdToResult=new Map,this._controller=new AbortController,j(t.options,(()=>this._controller.abort())),j(s,(()=>this._controller.abort()))}get(t){return this._tileIdToResult.get(t)}set(t,s){this._tileIdToResult.set(t,s)}get options(){return{signal:this._controller.signal}}}class Ae extends Me{constructor(){super(...arguments),this._loadStates=new Map}get about(){return{willQueryAllFeatures:!1,willQueryFullResolutionGeometry:!1}}async load(t){this._loadStates.has(t.key.id)||this._loadStates.set(t.key.id,new Fe(t,this._options));const s=this._loadStates.get(t.key.id);let e;try{for await(const e of this._fetchChunkInfos(s,t.tile,0)){const{queryJSON:s,reader:i,sourceTile:r,sourceTileDepth:n,tile:h}=e,o=new xe(i,s,h,r,n,!1);g(t.options),this._addChunk(o)}}catch(t){e=t}const i=new xe(ys.empty(this._metadata),null,t.tile,null,-1,!0);if(this._addChunk(i),e)throw e}unload(t){super.unload(t),this._loadStates.delete(t.key.id)}async*_fetchChunkInfos(t,s,e){let i=t.get(s.id);const r=!!i;if(i||(i=await this._fetchChunkInfo(t,s,e),t.set(s.id,i)),i.reader.exceededTransferLimit&&e<l("featurelayer-query-max-depth"))for(const i of s.createChildTiles())yield*this._fetchChunkInfos(t,i,e+1);else r||(yield i)}async _fetchChunkInfo(t,s,e){const i=t.subscription.tile.getQuantizationParameters(),r=this._queryInfo.createTileQuery(s,{returnExceededLimitFeatures:!1,quantizationParameters:i});return{reader:await this._fetch(r,t.subscription.options),queryJSON:r.inner.toJSON(),tile:t.subscription.tile,sourceTile:s,sourceTileDepth:e}}}class Ce extends Bs{constructor(t,s,e,i,r){super(),this._reader=t,this._queryJSON=s,this._tile=e,this._page=i,this._end=r,this.chunkId=`${this._tile.key.id}.${this._page}${this.end?"e":""}`,this.normalizedChunkId=`${this._tile.key.normalizedId}.${this._page}${this.end?"e":""}`}get queryInfo(){return{type:"paged-tile",chunkId:this.chunkId,tileId:this._tile.key.id,queryJSON:this._queryJSON,page:this._page,size:this.size(),end:this.end}}get reader(){return this._reader}get first(){return 0===this._page}get end(){return this._end}get page(){return this._page}get tile(){return this._tile}get isTiled(){return!0}getTileReader(t){return this._tile.key.id===t.key.id?this.reader:null}}class je{constructor(t,s){this.subscription=t,this._pages=new Set,this._controller=new AbortController,this._done=!1,j(t.options,(()=>this._controller.abort())),j(s,(()=>this._controller.abort()))}resetAbortController(){this._controller=new AbortController}get pageStart(){let t=-1;for(const s of this._pages.values())t=Math.max(t,s);return t+1}get done(){return this._done}get options(){return{signal:this._controller.signal}}add(t,s){this._pages.add(t),this._done=this._done||s}}class ke extends Me{constructor(){super(...arguments),this._loadStates=new Map}get about(){return{willQueryAllFeatures:!1,willQueryFullResolutionGeometry:!1}}async load(t){this._loadStates.has(t.key.id)||this._loadStates.set(t.key.id,new je(t,this._options));const s=this._loadStates.get(t.key.id);let e;s.resetAbortController();try{await this._fetchPages(s)}catch(t){e=t}const i=new Ce(ys.empty(this._metadata),null,t.tile,-1,!0);if(k(s.options)||this._addChunk(i),e)throw e}unload(t){super.unload(t),this._loadStates.delete(t.key.id)}async _fetchPages(t){const s=4,e=20;let i=0,r=t.pageStart,n=1;for(;i<e&&!t.done;){const e=[];for(let s=0;s<n;s++)e.push(this._fetchChunk(t,r++));const h=await Promise.all(e);for(const s of h)(0!==s.size()||s.first)&&(t.add(s.page,!s.reader.exceededTransferLimit),g(t.options),this._addChunk(s));i++,n=Math.min(n+1,s)}}async _fetchChunk(t,s){const e=t.subscription.tile,i=this._queryInfo.createPagedTileQuery(e,s),r=await this._fetch(i,t.options);return new Ce(r,i.inner.toJSON(),e,s,!1)}}class Ee extends Bs{constructor(t,s,e,i){super(),this._reader=t,this._queryJSON=s,this._page=e,this._end=i,this.chunkId=`${this._page}${this.end?"e":""}`,this.normalizedChunkId=this.chunkId}get reader(){return this._reader}get first(){return 0===this._page}get end(){return this._end}get queryInfo(){return{type:"snapshot",chunkId:this.chunkId,queryJSON:this._queryJSON,page:this._page,size:this.size(),end:this.end}}get isTiled(){return!1}getTileReader(t){const s=this.queryFeaturesInBounds(t.bounds);return s.setTransformForDisplay(t.transform),s}}class Te extends _e{constructor(t,s,e,i,r,n){super(t,s,e,r,n),this._random=new E(1e3),this._featureCount=i}get about(){return{willQueryAllFeatures:!0,willQueryFullResolutionGeometry:!0}}load(t){return null==this._promise&&(this._promise=this._downloadPages(this._featureCount)),this._promise}unload(t){}async _downloadPages(t){const s=Math.ceil(t/this._queryInfo.pageSize),e=Array.from({length:s},((t,s)=>s)).sort(((t,s)=>this._random.getInt()-this._random.getInt())),i=await Promise.all(e.map((t=>this._downloadPage(t)))),r=new Ee(ys.empty(this._metadata),null,-1,!0);this._store.insert(r);const n=i.filter((t=>t));if(n.length)throw new M("featurelayer-query","Encountered errors when downloading data",{errors:n})}async _downloadPage(t){try{const s=this._queryInfo.createPagedQuery(t),e=await this._fetch(s,this._options),i=new Ee(e,s.inner.toJSON(),t,!1);return g(this._options),this._store.insert(i),null}catch(t){return t}}}const Pe="__esri_stream_id__",Re="__esri_timestamp__",qe=1e3;class $e{constructor(t,s,e,i,r=128){this._trackIdToObservations=new Map,this._idCounter=0,this._lastPurge=performance.now(),this._addOrUpdated=new Map,this._removed=[],this._maxAge=0,this._timeInfo=e,this._purgeOptions=i,this.store=t,this.objectIdField=s,this.purgeInterval=r,this._useGeneratedIds=this.objectIdField===Pe}removeById(t){this._removed.push(t)}removeByTrackId(t){const s=this._trackIdToObservations.get(t);if(s)for(const t of s.entries)this._removed.push(t)}add(t){if(this._useGeneratedIds){const s=this._nextId();t.attributes[this.objectIdField]=s,t.objectId=s}else t.objectId=t.attributes[this.objectIdField];const s=t.objectId;if(this._addOrUpdated.set(s,t),this._maxAge=Math.max(this._maxAge,t.attributes[this._timeInfo.startTimeField]),!this._timeInfo.trackIdField)return null==this._trackIdLessObservations&&(this._trackIdLessObservations=new Rt(1e5)),void this._trackIdLessObservations.enqueue(s);const e=t.attributes[this._timeInfo.trackIdField];if(!this._trackIdToObservations.has(e)){const t=null!=this._purgeOptions?.maxObservations?this._purgeOptions.maxObservations:qe,s=T(t,0,qe);this._trackIdToObservations.set(e,new Rt(s))}const i=this._trackIdToObservations.get(e),r=i?.enqueue(s);null!=r&&(this._addOrUpdated.has(r)?this._addOrUpdated.delete(r):this._removed.push(r))}checkForUpdates(){const t=this._getToAdd(),s=this._getToRemove(),e=performance.now();e-this._lastPurge>=this.purgeInterval&&(this._purge(e),this._lastPurge=e);const i=[];if(null!=s)for(const t of s){const s=this.store.removeById(t);null!=s&&i.push(s)}const r=[];if(null!=t){const i=new Set(s??[]);for(const s of t)i.has(s.objectId)||(s.attributes[Re]=e,this.store.add(s),r.push(s))}return!(!r.length&&!i?.length)&&(this.store.update(r,i),!0)}_getToAdd(){if(!this._addOrUpdated.size)return null;const t=new Array(this._addOrUpdated.size);let s=0;return this._addOrUpdated.forEach((e=>t[s++]=e)),this._addOrUpdated.clear(),t}_getToRemove(){const t=this._removed;return this._removed.length?(this._removed=[],t):null}_nextId(){const t=this._idCounter;return this._idCounter=(this._idCounter+1)%4294967294+1,t}_purge(t){const s=this._purgeOptions;null!=s&&(this._purgeSomeByDisplayCount(s),this._purgeByAge(s),this._purgeByAgeReceived(t,s),this._purgeTracks())}_purgeSomeByDisplayCount(t){if(!t.displayCount)return;let s=this.store.size;if(s>t.displayCount){if(this._timeInfo.trackIdField)for(const e of this._trackIdToObservations.values())if(s>t.displayCount&&e.size){const t=e.dequeue();this._removed.push(t),s--}if(null!=this._trackIdLessObservations){let e=s-t.displayCount;for(;e-- >0;){const t=this._trackIdLessObservations.dequeue();null!=t&&this._removed.push(t)}}}}_purgeByAge(t){const s=this._timeInfo?.startTimeField;if(!t.age||!s)return;const e=60*t.age*1e3,i=this._maxAge-e;this.store.forEach((t=>{t.attributes[s]<i&&this._removed.push(t.objectId)}))}_purgeByAgeReceived(t,s){if(!s.ageReceived)return;const e=t-60*s.ageReceived*1e3;this.store.forEach((t=>{t.attributes[Re]<e&&this._removed.push(t.objectId)}))}_purgeTracks(){this._trackIdToObservations.forEach(((t,s)=>{0===t.size&&this._trackIdToObservations.delete(s)}))}}let Ge=class extends v{constructor(t){super(t)}get connectionStatus(){return this.connection?.connectionStatus}get errorString(){return this.connection?.errorString}};b([S()],Ge.prototype,"connection",void 0),b([S()],Ge.prototype,"connectionStatus",null),b([S()],Ge.prototype,"errorString",null),Ge=b([I("esri.views.2d.layers.features.sources.StreamConnectionState")],Ge);class De{constructor(t,s){this._metadata=t,this._onUpdate=s,this._objectIdToFeature=new Map}get size(){return this._objectIdToFeature.size}get reader(){return ys.fromFeatures([...this._objectIdToFeature.values()],this._metadata)}add(t){this._objectIdToFeature.set(t.objectId,t)}forEach(t){this._objectIdToFeature.forEach(t)}removeById(t){const s=this._objectIdToFeature.get(t);return s?(this._objectIdToFeature.delete(t),s):null}clear(){this._objectIdToFeature=new Map}update(t,s){this._onUpdate(t?.length??0)}}class Oe extends Bs{constructor(t){super(),this._reader=t,this.chunkId="stream-chunk",this.normalizedChunkId="stream-chunk"}get reader(){return this._reader}get first(){return!0}get end(){return!0}get queryInfo(){return{type:"stream",chunkId:this.chunkId,size:this.size(),end:this.end}}get isTiled(){return!1}getTileReader(t){const s=this.queryFeaturesInBounds(t.bounds);return s.setTransformForDisplay(t.transform),s}}class Ne extends te{constructor(t,s,i,r,n){super(i),this._service=t,this._dataFilter=s,this._streamOptions=r,this._metadata=n,this._connectionState=new Ge,this._forceRefresh=!1,this.events=new e;const{objectIdField:h,timeInfo:o}=this._metadata,{purgeOptions:a}=s;this._stagingStore=new De(this._metadata,(t=>this.events.emit("features-updated",t))),this._manager=new $e(this._stagingStore,h,o,a),this.connect()}destroy(){super.destroy(),this.disconnect()}get about(){return{willQueryAllFeatures:!1,willQueryFullResolutionGeometry:!1}}get connectionStatus(){return this._connectionState.connectionStatus}get errorString(){return this._connectionState?.errorString}async refresh(){const t=null!=this._chunk;this._manager.checkForUpdates()||!t||this._forceRefresh?(this._chunk&&this._store.remove(this._chunk),this._forceRefresh=!1,this._chunk=new Oe(this._stagingStore.reader),this._store.insert(this._chunk),this.events.emit("tick")):this.events.emit("tick")}async updateFields(t){throw new Error("Updating available fields not supported for StreamLayer")}async load(t){}unload(t){}disconnect(){this._connection=p(this._connection),this._connectionState.connection=null,this._handlesGroup?.remove()}connect(){if(null!=this._connection)return;const{geometryType:t,spatialReference:s}=this._metadata,{maxReconnectionAttempts:e,maxReconnectionInterval:i,geometryDefinition:r,definitionExpression:n,customParameters:h}=this._dataFilter;this._connection=qt(this._service.source,s,this._streamOptions.outSR,t,n,r,e,i,h),this._handlesGroup=P([this._connection.on("data-received",(t=>this._onFeature(t))),this._connection.on("message-received",(t=>this._onWebSocketMessage(t)))]),this._connectionState.connection=this._connection}clear(){this._manager.checkForUpdates(),this._stagingStore.clear(),this._forceRefresh=!0}updateCustomParameters(t){this._connection?.updateCustomParameters(t)}sendMessageToSocket(t){this._connection?.sendMessageToSocket(t)}sendMessageToClient(t){this._connection?.sendMessageToClient(t)}_onWebSocketMessage(t){if("type"in t)switch(t.type){case"delete":if(t.objectIds)for(const s of t.objectIds)this._manager.removeById(s);if(t.trackIds)for(const s of t.trackIds)this._manager.removeByTrackId(s);break;case"clear":this.clear()}this.events.emit("message-received",t)}_onFeature(t){try{this._manager.add(t),this.events.emit("data-received",t)}catch(t){}}}class Ue{constructor(t){this._onChange=t,this._chunks=new Map,this._chunksToRemove=[],this.events=new e,this.featureAdapter=new et}destroy(){this.clear()}clear(){for(const t of this._chunks.values())this._chunksToRemove.push(t);this._chunks.clear(),null!=this._overrideChunk&&this._chunksToRemove.push(this._overrideChunk),this._overrideChunk=null}*chunks(){this._overrideChunk&&(yield this._overrideChunk),yield*this._chunks.values()}insert(t){l("esri-2d-update-debug")&&console.debug(`Chunk[${t.chunkId}] SourceChunkStore.insert`),this._overrideChunk?.overridenIds.size&&t.reader.removeIds(this._overrideChunk.overridenIds),this._chunks.set(t.chunkId,t),this.events.emit("changed"),this._onChange()}remove(t){l("esri-2d-update-debug")&&console.debug(`Chunk[${t.chunkId}] SourceChunkStore.remove`),this._chunks.delete(t.chunkId),this._chunksToRemove.push(t)}cleanupRemovedChunks(){const t=this._chunksToRemove;return this._chunksToRemove=[],t}applyOverrides(t,s){null==this._overrideChunk&&(this._overrideChunk=new Ls(s)),this._overrideChunk.applyOverrides(t);for(const t of this._chunks.values())t.reader.removeIds(this._overrideChunk.overridenIds),t.invalidate()}forEach(t){const s=new Set;for(const e of this.chunks()){const i=e.reader.getCursor();for(;i.next();){const e=i.getObjectId();s.has(e)||(t(i.copy()),s.add(e))}}}forEachUnsafe(t){const s=new Set;for(const e of this.chunks()){const i=e.reader.getCursor();for(;i.next();){const e=i.getObjectId();s.has(e)||(t(i),s.add(e))}}}forEachInBounds(t,s){const e=new Set;for(const i of this.chunks()){const r=i.queryFeaturesInBounds(t);for(;r.next();){const t=r.getObjectId();e.has(t)||(s(r.copy()),e.add(t))}}}forEachBounds(t,s){const e=i();for(const i of t){i.getBounds(e)&&s(e)}}}class Ve{constructor(t,s,e,i){this._aggregateAdapter=t,this._subscriptions=s,this._onChange=e,this._connection=i,this._updateTracking=new $t({debugName:"FeatureSource"}),this._didInvalidateData=!1,this._store=new Ue(this._onChange)}destroy(){this._strategy?.destroy(),this._store.destroy(),this._streamMessenger?.destroy()}get _eventLog(){return this._connection.eventLog}get metadata(){if(!this._metadata)throw new Error("InternalError: Metadata not defined. Was update called?");return this._metadata}get service(){return this._schema.service}get store(){return this._store}get streamMessenger(){return null==this._streamMessenger&&this._initStreamMessenger(),this._streamMessenger}get statistics(){return Zs.from(this._store)}get updateTracking(){return this._updateTracking}get queryEngine(){if(!this._queryEngine){if(!this._schema)return null;const{dataFilter:t}=this._schema.mutable,s=this._schema.mutable.availableFields,e=this._metadata;this._queryEngine=new xt({featureStore:this._store,fieldsIndex:e.fieldsIndex,geometryType:e.geometryType,objectIdField:e.objectIdField,hasM:!1,hasZ:!1,spatialReference:t.outSpatialReference,cacheSpatialQueries:!0,aggregateAdapter:this._aggregateAdapter,timeInfo:e.timeInfo,definitionExpression:t.definitionExpression,availableFields:s})}return this._queryEngine}get isStream(){return"stream"===this._schema.type}chunks(){return Array.from(this._store.chunks())}cleanupRemovedChunks(){return this._store.cleanupRemovedChunks()}onSubscribe(t){this._eventLog.onEvent({type:"subscribe",tile:t.tile.id});const s=this._strategy?.load(t);s&&(s.then((()=>this._eventLog.onEvent({type:"loaded",tile:t.tile.id}))).catch((s=>this._eventLog.onEvent({type:"error",tile:t.tile.id,error:s}))),this._updateTracking.addPromise(s))}onResume(t){this._updateTracking.addPromise(c(this._strategy?.load(t)))}onUnsubscribe(t){this._eventLog.onEvent({type:"unsubscribe",tile:t.tile.id}),this._strategy?.unload(t)}getOverride(t){return this._updateTracking.addPromise(this._doGetOverride(t))}applyOverride(t){this._didInvalidateData=!0,this._store.applyOverrides(t,this.metadata)}async update(t,s){const e=t.source,i=u(this._schema?.mutable,e.mutable);if(!i)return!1;if(l("esri-2d-update-debug")&&console.debug(`Version[${s}] FeatureSource.update`,{changes:i}),this._schema=e,this._metadata=new J(this._schema.service.metadata),this._queryEngine?.destroy(),this._queryEngine=null,"feature"===this._schema.type&&null!=this._schema.service.queryMetadata.lastEditDate&&(this._lastEditDate=this._schema.service.queryMetadata.lastEditDate),null==this._streamMessenger&&"stream"===this._schema.type&&this._initStreamMessenger(),R(i,"sourceRefreshVersion")&&this._strategy?.refresh)return await this._strategy.refresh(),!0;if("feature"===e.type&&R(i,"availableFields")){if(await this._queryLastEditDateChanged()||this._didInvalidateData)this._didInvalidateData=!1,await this._updateStrategy(s);else{this._eventLog.onEvent({type:"updateFieldsStart"});try{await this._strategy.updateFields(e.mutable.availableFields),this._eventLog.onEvent({type:"updateFieldsEnd"})}catch(t){this._eventLog.onEvent({type:"updateFieldsError",error:t})}}return!1}return!(!q(i,"dataFilter")&&!q(i,"sourceRefreshVersion"))&&(await this._updateStrategy(s),!0)}_initStreamMessenger(){null==this._streamMessenger&&(this._streamMessenger=new Ks(this._connection))}async _doGetOverride(t){return this._strategy.queryOverride(t)}async _queryLastEditDateChanged(){if(null==this._lastEditDate)return!1;const t=this._schema.service.source,s={...t.query,f:"json"},e=(await $(t.path,{query:s,responseType:"json"})).data.editingInfo.lastEditDate;return e!==this._lastEditDate&&(this._lastEditDate=e,!0)}async _createStrategy(){const t=this.service,s="isSourceHosted"in t&&t.isSourceHosted,e=Array.isArray(t.source),i=t.source&&"collection"in t.source,r=s||e||i;if("stream"===this._schema.type){const t=new Ne(this._schema.service,this._schema.mutable.dataFilter,this._store,{outSR:this._schema.mutable.dataFilter.outSpatialReference},this.metadata);return this._streamMessenger.strategy=t,t}const n=Js.fromSchema(this._schema,this._metadata),h=await this._supportSnapshotMode(this._schema,n);return h?new Te(this._schema.service,n,this._store,h.featureCount,this.metadata,this._eventLog):r?new ke(this._schema.service,n,this._store,this.metadata,this._eventLog):new Ae(this._schema.service,n,this._store,this.metadata,this._eventLog)}async _updateStrategy(t){const s=await this._createStrategy();this._eventLog.onEvent({type:"updateStrategyStart",about:s.about});const e=!!this._strategy;this._store.clear(),this._strategy?.destroy(),this._strategy=s,l("esri-2d-update-debug")&&console.debug(`Version[${t}] FeatureSource.updateStrategy`,{strategy:s});const i=Array.from(this._subscriptions.values());if(!i.length)return void this._eventLog.onEvent({type:"updateStrategyEnd"});const r=Promise.all(i.map((t=>this._strategy.load(t).then((()=>this._eventLog.onEvent({type:"loaded",tile:t.tile.id}))).catch((s=>this._eventLog.onEvent({type:"error",tile:t.tile.id,error:s}))))));this._updateTracking.addPromise(r);try{e&&await r}catch(t){f(t)}this._eventLog.onEvent({type:"updateStrategyEnd"}),l("esri-2d-update-debug")&&console.debug(`Version[${t}] FeatureSource.updateStrategyEnd`,{strategy:s})}async _supportSnapshotMode(t,s){const{queryMetadata:e}=t.service,i=e.snapshotInfo;if(!i||!i.supportsSnapshotMinThreshold||!i.snapshotCountThresholds)return null;const r=t.service.source,n=s.createQuery();n.inner.orderByFields=[],n.inner.returnGeometry=!1;const h=(await jt(r,n.inner,{query:n.customParameters})).data.count,{min:o,max:a}=i.snapshotCountThresholds;return h<=o||i.supportsSnapshotMaxThreshold&&h<a?{featureCount:h}:null}}class Be{constructor(t,s){this._handles=new G,this._abortController=new AbortController,this._resolver=D(),this._isDone=!1,this._aborted=!1,this.tile=t,this._version=s,this._handles.add([])}destroy(){this.pause(),this._handles.destroy()}get key(){return this.tile.key}get version(){return this._version}set version(t){this._version=t}get signal(){return this._abortController.signal}get options(){return{signal:this._abortController.signal}}get done(){return this._resolver.promise}get isDone(){return this._isDone}resolve(){this._isDone=!0,this._resolver.resolve()}get paused(){return this._aborted}resume(){this._abortController=new AbortController,this._aborted=!1}pause(){this._aborted||(this._aborted=!0,this._abortController.abort())}}class Le{constructor(t){this.edit=t,this.resolver=D()}}class ze{constructor(t,s){this.schema=t,this.version=s,this.resolver=D()}}class We{constructor(){this._aggregateAdapter={getFeatureObjectIds:t=>this._processor.getFeatureObjectIdsForAggregate(t)},this._subscriptions=new Map,this._updateRequested=!1,this._updateSubscriptionRequests=[],this._updateHighlightRequests=[]}destroy(){this._subscriptions.clear(),this._processor.destroy(),this._source.destroy(),this._handles.remove(),this._editState=null,this._tileInfoView=null}onDetach(){this.destroy(),this._initialize(this._connection)}_initialize(t){this._source=new Ve(this._aggregateAdapter,this._subscriptions,(()=>this._requestUpdate()),t),this._processor=new Qs(t,this._source),this._handles=P([_((()=>this._source.updateTracking.updating),(()=>{this._requestUpdate(),this._connection.layerView.setUpdating({data:this._source.updateTracking.updating,pipeline:!0})}))])}set remoteClient(t){this._connection=new Gt(t),this._initialize(this._connection)}get features(){const t=this._source.queryEngine;if(!t)throw new M("no-queryEngine","No query engine defined");return t}get aggregates(){const t=this._processor.aggregateQueryEngine;if(!t)throw new M("no-queryEngine","No aggregate query engine defined");return t}get processor(){return this._processor}get streamMessenger(){return this._source.streamMessenger}getDisplayFeatures(t){return this._processor.getDisplayFeatures(t)}async updateSchema(t,s){return l("esri-2d-update-debug")&&this._updateSchemaState&&console.error("InternalError: Schema already updating"),this._updateSchemaState=new ze(t,s),this._requestUpdate(),this._updateSchemaState.resolver.promise}updateSubscriptions(t){this._updateSubscriptionRequests.push(t),this._requestUpdate()}updateHighlight(t){this._updateHighlightRequests.push(t),this._requestUpdate()}async onEdits(t){if(null!=this._editState)throw new M("InternalError - Already processing an edit");this._editState=new Le(t);const s=this._editState.resolver.promise;return this._requestUpdate(),s}queryStatistics(){return this._source.statistics.toJSON()}async queryVisibleFeatures(t,s){return this.features.executeQuery(t,s)}async queryHeatmapStatistics(t){const s=Math.round(B(t.radius));let e=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY;const r="string"==typeof t.fieldOffset,n=t.fieldOffset??0,h=Array.from(this._subscriptions.values()),o=this._source.chunks(),a=s**2,c=3/(Math.PI*a),u=2*s,l=Math.ceil(L/u);for(const s of h){const h=s.tile,d=new Float64Array(l*l);for(const s of o){const e=s.getTileReader(h);if(!e)continue;const i=e.getCursor();for(;i.next();){let s=1;if(null!=t.field){const e=i.readAttribute(t.field);s=r?-1*+e:+e+n}const e=i.readXForDisplay()/u,h=i.readYForDisplay()/u,o=Math.floor(e),f=Math.floor(h);if(o<0||f<0||o>=l||f>=l)continue;const p=((.5+o-e)*u)**2+((.5+f-h)*u)**2;if(p>a)continue;const g=s*(c*(1-p/a)**2);d[f+o*l]+=g}}for(let t=0;t<d.length;t++)e=Math.min(e,d[t]),i=Math.max(i,d[t])}return{max:i,min:e}}async getSampleFeatures(t){const s=this._source.chunks();if(s.reduce(((t,s)=>t+s.size()),0)<=t.minFeatureCount){if(!this._source.updateTracking.updating){const t=[];return this._source.store.forEachUnsafe((s=>t.push(s.readLegacyFeatureWorldSpace()))),t}return null}const e=new Set,i=[],r=s.map((t=>t.reader.getCursor())),n=new E,h=3*t.sampleSize;for(let o=0;o<h&&i.length<t.sampleSize;o++){const t=r[n.getIntRange(0,s.length-1)];if(0===t.getSize())continue;const h=n.getIntRange(0,t.getSize()-1);t.setIndex(h);const o=t.getObjectId();e.has(o)||(e.add(o),i.push(t.readLegacyFeatureWorldSpace()))}return i.length>=t.sampleSize?i:null}_requestUpdate(){this._updateRequested||(this._updateRequested=!0,O((()=>this._scheduleNextUpdate())))}_scheduleNextUpdate(){this._updateRequested&&(this._ongoingUpdate||(this._ongoingUpdate=this._doUpdate().finally((()=>{this._ongoingUpdate=null,this._scheduleNextUpdate()})),this._updateRequested=!1))}_subscribe(t){const s=t.tileId;if(this._subscriptions.has(s)){const e=this._subscriptions.get(s);return void(e.paused&&(l("esri-2d-update-debug")&&console.debug(`Tile[${s}] Pipeline.resume`),e.resume(),e.version=t.version,this._source.onResume(e)))}l("esri-2d-update-debug")&&console.debug(`Tile[${s}] Pipeline.subscribe`);const e=new N(this._tileInfoView,s),i=new Be(e,t.version);this._subscriptions.set(s,i),this._source.onSubscribe(i),this._processor.onSubscribe(i)}_unsubscribe(t){const s=this._subscriptions.get(t);s&&(l("esri-2d-update-debug")&&console.debug(`Tile[${t}] Pipeline.unsubscribe`),this._source.onUnsubscribe(s),this._processor.onUnsubscribe(s),this._subscriptions.delete(s.key.id),s.destroy())}_pauseSubscription(t){const s=this._subscriptions.get(t);s&&(l("esri-2d-update-debug")&&console.debug(`Tile[${t}] Pipeline.pause`),s.pause())}async _doUpdate(){if(l("esri-2d-update-debug")&&console.debug("Pipeline._doUpdateStart"),await this._connection.layerView.setUpdating({data:this._source.updateTracking.updating,pipeline:!0}),this._updateSubscriptionRequests.length){const t=this._updateSubscriptionRequests;this._updateSubscriptionRequests=[];for(const s of t)this._doUpdateSubscriptions(s)}const t=this._updateSchemaState;if(this._updateSchemaState=null,null!=t){const{schema:s,version:e}=t;await this._doUpdateSchema(s,e)}const s=this._editState;if(this._editState=null,null!=s){l("esri-2d-update-debug")&&console.debug("Pipeline.applyEditOverride",s.edit);const t=await this._source.getOverride(s.edit);await this._processor.applyOverride(t),l("esri-2d-update-debug")&&console.debug("Pipeline.endEditOverride",s.edit)}if(this._updateHighlightRequests.length){const t=this._updateHighlightRequests;this._updateHighlightRequests=[];for(const s of t)this._processor.updateHighlight(s)}const e=this._source.cleanupRemovedChunks();this._processor.removeChunks(e);try{this._subscriptions.size&&(l("esri-2d-update-debug")&&console.debug("Pipeline.updateChunksStart"),await this._processor.updateChunks(),l("esri-2d-update-debug")&&console.debug("Pipeline.updateChunksEnd"))}catch(t){f(t)}null!=s&&s.resolver.resolve(),null!=t&&t.resolver.resolve(),this._updateRequested?(l("esri-2d-update-debug")&&console.debug("Pipeline._doUpdateEnd [updateRequested=true]"),await this._connection.layerView.setUpdating({data:this._source.updateTracking.updating,pipeline:!0})):(l("esri-2d-update-debug")&&console.debug("Pipeline._doUpdateEnd [updateRequested=false, After flush]"),await this._connection.layerView.setUpdating({data:this._source.updateTracking.updating,pipeline:this._updateRequested}))}async _doUpdateSchema(t,s){if(l("esri-2d-update-debug")&&console.debug(`Version[${s}] Pipeline.updateStart`,{schema:t}),!this._tileInfoView){const s=U.fromJSON(t.source.tileInfoJSON);this._tileInfoView=new V(s)}const e={tileInfo:this._tileInfoView?.tileInfo};try{const i=await this._source.update(t,s),r=Array.from(this._subscriptions.values());await this._processor.update(t,s,e,i,r)}catch(t){console.error(t)}l("esri-2d-update-debug")&&console.debug(`Version[${s}] Pipeline.updateEnd`)}_doUpdateSubscriptions(t){if(l("esri-2d-update-debug")&&console.debug("Pipeline.updateSubscriptions",t),!this._tileInfoView){const s=U.fromJSON(t.tileInfoJSON);this._tileInfoView=new V(s)}for(const s of t.subscribe)this._subscribe(s);for(const s of t.unsubscribe)this._unsubscribe(s);if(l("featurelayer-query-pausing-enabled"))for(const s of t.pause)this._pauseSubscription(s)}}export default We;
//# sourceMappingURL=p-e39f3dfd.js.map