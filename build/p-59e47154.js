import{av as t,ai as e,aX as s,aV as i,aY as o,aZ as n,a_ as r,aM as a,aN as c,a$ as h,aT as u,aU as l,b0 as p,e as f}from"./p-2d2f231a.js";import{fx as m,n as d,s as y,fy as k,fz as g,fA as b,fB as w,c9 as x,fs as M,cL as P,dd as z,fC as A,fD as S,fE as _,dX as R,fF as v,fG as L,fH as C,fI as T,e$ as F,fe as I,d0 as G,e8 as B,e9 as X,fJ as E,ev as Y,ea as j,fK as D,ee as O,cQ as W,cZ as V,c$ as q,fL as Z,F as N,a7 as H}from"./p-aad64c9f.js";import{c as $,a as Q,d as U,x as J,t as K}from"./p-01ae94a1.js";import{l as tt}from"./p-b8a25c33.js";import{c as et,g as st,O as it,s as ot,d as nt,f as rt,h as at}from"./p-559f4b2d.js";import{c as ct}from"./p-6bf0c935.js";import{e as ht,d as ut,t as lt}from"./p-22458323.js";import{h as pt,r as ft}from"./p-875cbb57.js";import{s as mt}from"./p-aff89b86.js";import{e as dt}from"./p-deddb82e.js";import{o as yt,e as kt}from"./p-b74976e9.js";import{c as gt}from"./p-fa2632fc.js";const bt=()=>d.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils"),wt=0,xt=100;function Mt(t,e){return[!!t?.minScale&&e.scaleToZoom(t.minScale)||wt,!!t?.maxScale&&e.scaleToZoom(t.maxScale)||xt]}function Pt(t){return 1<<t}function zt(t){let e=0;for(const[s,i]of t)i&&(e|=1<<s);return e}function At(t){let e;if(!t)return[0,0,0,0];if("string"==typeof t){const s=m.fromString(t);if(!s)return bt().errorOnce(new y("mapview:mesh-processing","Unable to parse string into color",{color:t})),[0,0,0,0];e=s.toArray()}else e=t;const[s,i,o,n]=e;return[s*(n/255),i*(n/255),o*(n/255),n]}function St(t){switch(t){case"butt":case k.Butt:return g.BUTT;case"round":case k.Round:return g.ROUND;case"square":case k.Square:return g.SQUARE}}function _t(t){switch(t){case"bevel":case b.Bevel:return w.BEVEL;case"miter":case b.Miter:return w.MITER;case"round":case b.Round:return w.ROUND}}function Rt(t,e){return Math.round(Math.min(Math.sqrt(t*e),255))}function vt(t,e){return Math.round(t*e)/e}class Lt extends ${}function Ct(e){const{sprite:s,isMapAligned:i,colorLocked:o,scaleSymbolsProportionally:n,isStroke:r}=e;let a=0;return i&&(a|=Pt(t.bitset.isMapAligned)),o&&(a|=Pt(t.bitset.colorLocked)),s.sdf&&(a|=Pt(t.bitset.isSDF)),n&&(a|=Pt(t.bitset.scaleSymbolsProportionally)),r&&(a|=Pt(t.bitset.isStroke)),a}class Tt extends Lt{get vertexSpec(){return{createComputedParams:t=>{let{pixelDimensions:e,texelDimensions:s,baseSize:i,referenceSize:o,strokeWidth:n,sizeRatio:r}=t;e||(e=t.sprite.sdf?[0,0]:[t.sprite.width,t.sprite.height]),s||(s=t.sprite.sdf?[0,0]:e),i=P(i),o=P(o),n=P(n);const a=(t.sprite.sdfDecodeCoeff??1)*r;return{...t,pixelDimensions:e,texelDimensions:s,baseSize:i,referenceSize:o,strokeWidth:n,sdfDecodeCoeff:a}},optionalAttributes:{zoomRange:{type:x.SHORT,count:2,packPrecisionFactor:M,pack:({scaleInfo:t},{tileInfo:e})=>Mt(t,e)}},attributes:{id:{type:x.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:x.UNSIGNED_BYTE,count:1,pack:Ct},pos:{type:x.SHORT,count:2,pack:"position",packPrecisionFactor:1},offset:{type:x.FLOAT,count:2,packAlternating:{count:4,pack:t=>{const e=t.texelDimensions;return[[-.5*e[0],-.5*e[1]],[.5*e[0],-.5*e[1]],[-.5*e[0],.5*e[1]],[.5*e[0],.5*e[1]]]}}},uv:{type:x.SHORT,count:2,packPrecisionFactor:1,packAlternating:{count:4,packTessellation:({texXmax:t,texXmin:e,texYmax:s,texYmin:i})=>[[e,i],[t,i],[e,s],[t,s]]}},animationPointerAndBaseSizeAndReferenceSize:{type:x.UNSIGNED_SHORT,count:4,packPrecisionFactor:1,pack:({animations:t,baseSize:e,referenceSize:s})=>[t.dataColumn,t.dataRow,e,s]},sizing:{type:x.UNSIGNED_SHORT,count:4,packPrecisionFactor:8,pack:({strokeWidth:t,pixelDimensions:e,baseSize:s,sprite:i,sizeRatio:o})=>{const n=Math.max(s*i.width/i.height,s),r=i.sdfDecodeCoeff*n*o;return[e[0],e[1],t,r]}},angle:{type:x.BYTE,count:1,packTessellation:({angle:t})=>t}}}}_write(t,s){const i=this.evaluatedMeshParams.sprite,{textureBinding:o}=i;t.recordStart(this.instanceId,this.attributeLayout,o);const n=s.getDisplayId();if("esriGeometryPolygon"===s.geometryType){const e=s.readCentroidForDisplay();if(!e)return;const[i,o]=e.coords;this._writeQuad(t,n,i,o)}else if("esriGeometryPoint"===s.geometryType){const e=s.readXForDisplay(),i=s.readYForDisplay();this._writeQuad(t,n,e,i)}else{const i=s.readGeometryForDisplay();if(i){const{angleToLine:s}=this.evaluatedMeshParams;if(s){let s=!0,o=null,r=null;i.forEachVertex(((i,a)=>{if(null!=o&&null!=r){const c=Math.atan2(a-r,i-o)/e;s&&(this._writeQuad(t,n,o,r,c),s=!1),this._writeQuad(t,n,i,a,c)}o=i,r=a}))}else i.forEachVertex(((e,s)=>{this._writeQuad(t,n,e,s)}))}}t.recordEnd()}_writeQuad(t,e,s,i,o=0){const n=this.evaluatedMeshParams.sprite,{rect:r}=n,a=r.x+2,c=r.y+2,h=r.x+r.width-2,u=r.y+r.height-2,l=t.vertexCount();t.recordBounds(s,i,64,64);const p={texXmin:a,texYmin:c,texXmax:h,texYmax:u,angle:o};for(let o=0;o<4;o++)this._writeVertex(t,e,s,i,p);t.indexEnsureSize(6),t.indexWrite(l),t.indexWrite(l+1),t.indexWrite(l+2),t.indexWrite(l+1),t.indexWrite(l+3),t.indexWrite(l+2)}}const Ft={createComputedParams:t=>t,optionalAttributes:{},attributes:{id:{type:x.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:x.UNSIGNED_BYTE,count:1},pos:{type:x.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:x.FLOAT,count:1,packTessellation:({inverseArea:t})=>t}}};class It extends Q{constructor(){super(...arguments),this.vertexSpec=Ft}createTesselationParams(t){return{inverseArea:1/t.readGeometryArea()}}}const Gt={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:x.SHORT,count:2,packPrecisionFactor:M,pack:({scaleInfo:t},{tileInfo:e})=>Mt(t,e)}},attributes:{id:{type:x.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:x.UNSIGNED_BYTE,count:1},pos:{type:x.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:x.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>At(t)}}};class Bt extends Q{constructor(){super(...arguments),this.vertexSpec=Gt}createTesselationParams(t){return null}}const Xt={createComputedParams:t=>t,optionalAttributes:Gt.optionalAttributes,attributes:{...Gt.attributes,tlbr:{count:4,type:x.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:e,width:s,height:i}=t,o=e.x+z,n=e.y+z;return[o,n,o+s,n+i]}},inverseRasterizationScale:{count:1,type:x.BYTE,packPrecisionFactor:16,pack:({sprite:t})=>1/t.rasterizationScale}}};class Et extends Bt{constructor(){super(...arguments),this.vertexSpec=Xt}_write(t,e,s){const i=s?.asOptimized()??e.readGeometryForDisplay(),o=this._clip(i);if(!o)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,o),t.recordEnd()}}function Yt(t){const{sprite:e,aspectRatio:s,scaleProportionally:i}=t,o=P(t.height),n=o>0?o:e.height;let r=o*s;return r<=0?r=e.width:i&&(r*=e.width/e.height),{width:r,height:n}}function jt(t){const{applyRandomOffset:e,sampleAlphaOnly:o}=t;return zt([[s,e],[i,o]])}const Dt={createComputedParams:t=>t,optionalAttributes:Xt.optionalAttributes,attributes:{...Xt.attributes,bitset:{count:1,type:x.UNSIGNED_BYTE,pack:jt},width:{count:1,type:x.HALF_FLOAT,pack:t=>Yt(t).width},height:{count:1,type:x.HALF_FLOAT,pack:t=>Yt(t).height},offset:{count:2,type:x.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[P(t),-P(e)]},scale:{count:2,type:x.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:t,scaleY:e})=>[t,e]},angle:{count:1,type:x.UNSIGNED_BYTE,pack:({angle:t})=>tt(t)}}};class Ot extends Et{constructor(){super(...arguments),this.vertexSpec=Dt}}class Wt{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0}}const Vt={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:x.SHORT,count:2,packPrecisionFactor:M,pack:({scaleInfo:t},{tileInfo:e})=>Mt(t,e)}},attributes:{id:{type:x.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:x.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:x.UNSIGNED_BYTE,count:1},color:{type:x.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>At(t)},offset:{type:x.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[vt(t,16),vt(e,16)]},normal:{type:x.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:t,normalY:e})=>[vt(t,16),vt(e,16)]},halfWidth:{type:x.HALF_FLOAT,count:1,pack:({width:t})=>P(.5*t)},referenceHalfWidth:{type:x.HALF_FLOAT,count:1,pack:({referenceWidth:t})=>P(.5*t)}}};class qt{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0}}const Zt=65535;class Nt extends ${constructor(t,e,s,i){super(t,e,s,i),this.vertexSpec=Vt,this._currentWrite=new qt,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:Zt,textured:!1},this._tessParams=new Wt,this._initializeTessellator()}writeLineVertices(t,e,s){const i=this._getLines(e);null!=i&&this._writeVertices(t,s,i)}_initializeTessellator(){this._lineTessellator=new ct(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(t,e,s){const i=s??et.fromFeatureSetReaderCIM(e);i&&this._writeGeometry(t,e,i)}_writeGeometry(t,e,s,i){t.recordStart(this.instanceId,this.attributeLayout,i),this.writeLineVertices(t,s,e),t.recordEnd()}_getLines(t){return U(t,ht(this.evaluatedMeshParams))}_writeVertices(t,e,s){const{_currentWrite:i,_tessellationOptions:o,evaluatedMeshParams:n}=this,{width:r,capType:a,joinType:c,miterLimit:h,hasSizeVV:u}=n,l=P(.5*r);o.halfWidth=l,o.capType=St(a),o.joinType=_t(c),o.miterLimit=h;const p=!u;i.out=t,i.id=e.getDisplayId(),i.vertexCount=0,i.indexCount=0,i.vertexFrom=t.vertexCount(),i.vertexBounds=p&&l<A?0:1;for(const{line:t,start:e}of s)o.initialDistance=e%Zt,this._lineTessellator.tessellate(t,o,p)}_writeTesselatedVertex(t,e,s,i,o,n,r,a,c,h,u){const{out:l,id:p,vertexBounds:f}=this._currentWrite;return this.hasEffects&&l.recordBounds(t,e,f,f),this._tessParams.extrusionOffsetX=r,this._tessParams.extrusionOffsetY=a,this._tessParams.normalX=c,this._tessParams.normalY=h,this._tessParams.directionX=o,this._tessParams.directionY=n,this._tessParams.distance=u,this._writeVertex(l,p,t,e,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,e,s){const{out:i}=this._currentWrite;i.indexEnsureSize(3),i.indexWrite(t),i.indexWrite(e),i.indexWrite(s),this._currentWrite.indexCount+=3}}const Ht={createComputedParams:t=>t,optionalAttributes:Vt.optionalAttributes,attributes:{...Vt.attributes,bitset:{type:x.UNSIGNED_BYTE,count:1,pack:t=>0},color:{type:x.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>At(t)}}},$t={createComputedParams:t=>t,optionalAttributes:Vt.optionalAttributes,attributes:{...Vt.attributes,bitset:{type:x.UNSIGNED_BYTE,count:1,pack:t=>zt([[o,!0]])},color:{type:x.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>At(t)}}};class Qt extends Nt{constructor(){super(...arguments),this.vertexSpec=$t}}class Ut extends Bt{constructor(t,e,s,i){super(t,e,s,i),this.vertexSpec=Ht,this._lineMeshWriter=this._createOutlineWriter(t,e,s,i)}_createOutlineWriter(t,e,s,i){return new Qt(t,e,s,i)}_write(t,e,s){const i=s?.asOptimized()??e.readGeometryForDisplay(),o=this._clip(i);o&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,o),this._lineMeshWriter.writeLineVertices(t,et.fromOptimizedCIM(o,"esriGeometryPolyline"),e),t.recordEnd())}_clip(t){return t?J(t,ht(this.evaluatedMeshParams)):null}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const Jt=Dt,Kt=$t,te={createComputedParams:t=>t,optionalAttributes:Jt.optionalAttributes,attributes:{...Jt.attributes,bitset:{type:x.UNSIGNED_BYTE,count:1,pack:t=>jt(t)},aux1:{count:1,type:x.HALF_FLOAT,pack:t=>Yt(t).width},aux2:{count:1,type:x.HALF_FLOAT,pack:t=>Yt(t).height},aux3:{count:2,type:x.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[P(t),P(e)]},aux4:{count:2,type:x.UNSIGNED_BYTE,pack:({scaleX:t,scaleY:e})=>[t*n,e*n]}}},ee={createComputedParams:t=>t,optionalAttributes:Jt.optionalAttributes,attributes:{...Jt.attributes,color:Kt.attributes.color,bitset:{type:x.UNSIGNED_BYTE,count:1,pack:t=>zt([[o,!0]])},aux1:{count:1,type:x.HALF_FLOAT,pack:t=>P(.5*t.width)},aux2:{count:1,type:x.HALF_FLOAT,pack:t=>P(.5*t.referenceWidth)},aux3:{count:2,type:x.HALF_FLOAT,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[t,e]},aux4:{count:2,type:x.UNSIGNED_BYTE,packTessellation:({normalX:t,normalY:e})=>[t*n+r,e*n+r]}}};class se extends Qt{constructor(){super(...arguments),this.vertexSpec=ee}}class ie extends Ut{constructor(){super(...arguments),this.vertexSpec=te}_createOutlineWriter(t,e,s,i){return new se(t,e,s,i)}_write(t,e,s){const i=s?.asOptimized()??e.readGeometryForDisplay(),o=this._clip(i);if(!o)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,o),this._lineMeshWriter.writeLineVertices(t,et.fromOptimizedCIM(o,"esriGeometryPolyline"),e),t.recordEnd()}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const oe={optionalAttributes:Xt.optionalAttributes,createComputedParams:t=>t,attributes:{...Xt.attributes,...Ht.attributes}},ne={optionalAttributes:Xt.optionalAttributes,createComputedParams:t=>t,attributes:{...Xt.attributes,...$t.attributes}};class re extends Qt{constructor(){super(...arguments),this.vertexSpec=ne}}class ae extends Ut{constructor(){super(...arguments),this.vertexSpec=oe}_createOutlineWriter(t,e,s,i){return new re(t,e,s,i)}_write(t,e,s){const i=s?.asOptimized()??e.readGeometryForDisplay(),o=this._clip(i);if(!o)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,o),this._lineMeshWriter.writeLineVertices(t,et.fromOptimizedCIM(o,"esriGeometryPolyline"),e),t.recordEnd()}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const ce={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:x.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:x.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:x.UNSIGNED_BYTE,count:1},offset:{type:x.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};class he extends ${constructor(){super(...arguments),this.vertexSpec=ce}_write(t,e){t.recordStart(this.instanceId,this.attributeLayout);const s=e.getDisplayId();if("esriGeometryPoint"===e.geometryType){const i=e.readXForDisplay(),o=e.readYForDisplay();this._writeQuad(t,s,i,o)}else if("esriGeometryMultipoint"===e.geometryType){const i=e.readGeometryForDisplay();i?.forEachVertex(((e,i)=>{e>=0&&e<=512&&i>=0&&i<=512&&this._writeQuad(t,s,e,i)}))}t.recordEnd()}_writeQuad(t,e,s,i){const o=t.vertexCount();this._writeVertex(t,e,s,i),t.indexWrite(o+0),t.indexWrite(o+1),t.indexWrite(o+2),t.indexWrite(o+1),t.indexWrite(o+3),t.indexWrite(o+2)}}function ue(t,e,s){return t[0]=e[0]-s[0],t[1]=e[1]-s[1],t}function le(t,e){return Math.sqrt(t*t+e*e)}function pe(t){const e=le(t[0],t[1]);t[0]/=e,t[1]/=e}function fe(t,e){return le(t[0]-e[0],t[1]-e[1])}function me(t,e){return t[e+1]}function de(t){return t.length-1}function ye(t){let e=0;for(let s=0;s<de(t);s++)e+=ke(t,s);return e}function ke(t,e,s=1){let[i,o]=me(t,e);return[i,o]=[Math.round(i),Math.round(o)],Math.sqrt(i*i+o*o)*s}class ge{constructor(t,e,s,i,o){this._segments=t,this._index=e,this._distance=s,this._xStart=i,this._yStart=o,this._done=!1}static create(t){return new ge(t,0,0,t[0][0],t[0][1])}clone(){return new ge(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(t){return this._index===t._index||t._index===this._index-1&&(0===this._distance||1===t._distance)||t._index===this._index+1&&(1===this._distance||0===t._distance)}leq(t){return this._index<t._index||this._index===t._index&&this._distance<=t._distance}geq(t){return this._index>t._index||this._index===t._index&&this._distance>=t._distance}get _segment(){return this._segments[this._index+1]}get angle(){const t=this.dy,e=(0*t+-1*-this.dx)/(1*this.length);let s=Math.acos(e);return t>0&&(s=2*Math.PI-s),s}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:t,dy:e}=this;return Math.sqrt(t*t+e*e)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<de(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(t,e){const s=this.backwardLength;if(t<=s)return this._distance=(s-t)/this.length,this;let i=this.backwardLength;for(;this.prev();){if(i+this.length>t)return this._seekBackwards(t-i);i+=this.length}return this._distance=0,e?this:null}seek(t,e=!1){if(t<0)return this._seekBackwards(Math.abs(t),e);if(t<=this.remainingLength)return this._distance=(this.backwardLength+t)/this.length,this;let s=this.remainingLength;for(;this.next();){if(s+this.length>t)return this.seek(t-s,e);s+=this.length}return this._distance=1,e?this:null}}function be(t,e,s,i=!0){const o=ye(t),n=ge.create(t),r=o/2;if(!i)return n.seek(r),void(Math.abs(n.x)<dt&&Math.abs(n.y)<dt&&s(n.clone(),0,r+0*e,o));const a=Math.max((o-e)/2,0),c=Math.floor(a/e),h=r-c*e;n.seek(h);for(let t=-c;t<=c;t++)Math.abs(n.x)<dt&&Math.abs(n.y)<dt&&s(n.clone(),t,r+t*e,o),n.seek(e)}function we(t,e){const s=e;for(let e=0;e<t.length;e++){let i=t[e];xe(i,s);const o=[];o.push(i[0]);for(let t=1;t<i.length;t++){const[e,s]=i[t-1],[n,r]=i[t],a=n-e,c=r-s;o.push([a,c])}t[e]=o,i=o}return t}function xe(t,e){const s=1e-6;if(e<=0)return;const i=t.length;if(i<3)return;const o=[];let n=0;o.push(0);for(let e=1;e<i;e++)n+=fe(t[e],t[e-1]),o.push(n);e=Math.min(e,.2*n);const r=[];r.push(t[0][0]),r.push(t[0][1]);const a=t[i-1][0],c=t[i-1][1],h=ue([0,0],t[0],t[1]);pe(h),t[0][0]+=e*h[0],t[0][1]+=e*h[1],ue(h,t[i-1],t[i-2]),pe(h),t[i-1][0]+=e*h[0],t[i-1][1]+=e*h[1];for(let t=1;t<i;t++)o[t]+=e;o[i-1]+=e;const u=.5*e;for(let n=1;n<i-1;n++){let a=0,c=0,h=0;for(let i=n-1;i>=0&&!(o[i+1]<o[n]-u);i--){const r=u+o[i+1]-o[n],l=o[i+1]-o[i],p=o[n]-o[i]<u?1:r/l;if(Math.abs(p)<s)break;const f=p*p,m=p*r-.5*f*l,d=p*l/e,y=t[i+1],k=t[i][0]-y[0],g=t[i][1]-y[1];a+=d/m*(y[0]*p*r+.5*f*(r*k-l*y[0])-f*p*l*k/3),c+=d/m*(y[1]*p*r+.5*f*(r*g-l*y[1])-f*p*l*g/3),h+=d}for(let r=n+1;r<i&&!(o[r-1]>o[n]+u);r++){const i=u-o[r-1]+o[n],l=o[r]-o[r-1],p=o[r]-o[n]<u?1:i/l;if(Math.abs(p)<s)break;const f=p*p,m=p*i-.5*f*l,d=p*l/e,y=t[r-1],k=t[r][0]-y[0],g=t[r][1]-y[1];a+=d/m*(y[0]*p*i+.5*f*(i*k-l*y[0])-f*p*l*k/3),c+=d/m*(y[1]*p*i+.5*f*(i*g-l*y[1])-f*p*l*g/3),h+=d}r.push(a/h),r.push(c/h)}r.push(a),r.push(c);for(let e=0,s=0;e<i;e++)t[e][0]=r[s++],t[e][1]=r[s++]}class Me{static getPlacement(t,e,s,i,o,n){const r=st(s);if(!r)return null;-1===e&&t.invertY();return r.execute(t,s,i,o,n)}}const Pe=96;class ze{constructor(t){const{offsetX:e,offsetY:s,postAngle:i,fontSize:o,haloSize:n,outlineSize:r,scaleFactor:a,transforms:c}=t;if(this.offsetX=e,this.offsetY=s,this.postAngle=i,this.fontSize=Math.min(o,Pe),this.haloSize=n??0,this.outlineSize=r??0,this.transforms=c,c&&c.infos.length>1){const t=S(o,i,!1,e,s,c,!1);this.fontSize=Math.min(t.size,Pe);const n=t.size/o;this.haloSize*=n,this.outlineSize*=n,this.postAngle=t.rotation,this.offsetX=t.offsetX,this.offsetY=t.offsetY}a&&(this.fontSize*=a,this.offsetX*=a,this.offsetY*=a)}}const Ae=28,Se=[4,4],_e=[16,4],Re={topLeft:_e,topRight:_e,bottomLeft:_e,bottomRight:_e},ve=[4,2],Le=[4,6],Ce={topLeft:ve,topRight:ve,bottomLeft:Le,bottomRight:Le},Te={topLeft:ve,topRight:Le,bottomLeft:ve,bottomRight:Le},Fe={topLeft:Le,topRight:Le,bottomLeft:Se,bottomRight:Se},Ie={topLeft:Se,topRight:Se,bottomLeft:Le,bottomRight:Le},Ge={topLeft:Le,topRight:Se,bottomLeft:Le,bottomRight:Se},Be={topLeft:Se,topRight:Le,bottomLeft:Se,bottomRight:Le},Xe={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:x.UNSIGNED_SHORT,count:2,packPrecisionFactor:M,packTessellation:({minZoom:t,maxZoom:e})=>[t||0,e||Ae]},clipAngle:{type:x.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:t})=>Ye(t||0)},referenceSymbol:{type:x.BYTE,count:4,packPrecisionFactor:1,packTessellation:(t,e)=>{const s=t.isLineLabel||!t.referenceBounds,i=ot(s?"center":e.horizontalAlignment),o=nt(s?"middle":e.verticalAlignment),{offsetX:n,offsetY:r,size:a}=s?{offsetX:0,offsetY:0,size:0}:t.referenceBounds;return[P(n),-P(r),Math.round(P(a)),i+1<<2|o+1]}}},attributes:{pos:{type:x.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:x.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:x.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:t,mapAligned:e})=>zt([[a,t],[c,!!e]])},offset:{type:x.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:t})=>{const{bottomLeft:e,bottomRight:s,topLeft:i,topRight:o}=t;return[i,o,e,s]}}},textureUV:{type:x.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:t})=>{const{bottomLeft:e,bottomRight:s,topLeft:i,topRight:o}=t;return[i,o,e,s]}}},color:{type:x.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:t})=>t},fontSize:{type:x.UNSIGNED_SHORT,count:1,packPrecisionFactor:4,packTessellation:({fontSize:t})=>Math.round(P(t))},referenceSize:{type:x.UNSIGNED_BYTE,count:1,packPrecisionFactor:4,packTessellation:({fontSize:t},{referenceSize:e})=>Math.round(P(e??t))},outlineColor:{type:x.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>At(t)},haloColor:{type:x.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:t})=>At(t)},outlineAndHaloSize:{type:x.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:t,haloSize:e})=>[Math.round(P(t)),Math.round(P(e))]}}};class Ee extends ${constructor(){super(...arguments),this.vertexSpec=Xe,this._textMeshParamsPropsInitialized=!1}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new ze(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(t,e,s){const i=this._getShaping();if(!i)return;const o=e.getDisplayId();if(null!=this.evaluatedMeshParams.placement)return this._writePlacedTextMarkers(t,e,i,s);if(s?.nextPath())return s.nextPoint(),this._writeGlyphs(t,o,s.x,s.y,i,0);if("esriGeometryPolygon"===e.geometryType){const s=e.readCentroidForDisplay();if(!s)return;const[n,r]=s.coords;return this._writeGlyphs(t,o,n,r,i,0)}if("esriGeometryMultipoint"===e.geometryType){const s=e.readGeometryForDisplay();return void s?.forEachVertex(((e,s)=>this._writeGlyphs(t,o,e,s,i,0)))}const n=e.readXForDisplay(),r=e.readYForDisplay();return this._writeGlyphs(t,o,n,r,i,0)}_writePlacedTextMarkers(t,e,s,i){const o=i??et.fromFeatureSetReaderCIM(e);if(!o)return;const n=-1,r=Me.getPlacement(o,n,this.evaluatedMeshParams.placement,P(1),t.id,K());if(!r)return;const a=e.getDisplayId();let c=r.next();for(;null!=c;){const e=c.tx,i=-c.ty,o=-c.getAngle();this._writeGlyphs(t,a,e,i,s,o),c=r.next()}}_getShaping(t){const e=this._textMeshTransformProps,s=this.evaluatedMeshParams;if(!s.glyphs?.glyphs.length)return null;const i=P(e.fontSize),o=P(e.offsetX),n=P(e.offsetY),r=R(P(s.lineWidth),L,v),a=C*R(s.lineHeightRatio,.25,4);return it(s.glyphs,{scale:i/_,angle:e.postAngle,xOffset:o,yOffset:n,horizontalAlignment:s.horizontalAlignment,verticalAlignment:t||s.verticalAlignment,maxLineWidth:r,lineHeight:a,decoration:s.decoration,borderLineSizePx:P(s.boxBorderLineSize),hasBackground:!!s.boxBackgroundColor,useCIMAngleBehavior:s.useCIMAngleBehavior})}_writeGlyphs(t,e,s,i,o,n,r,a){const c=this.evaluatedMeshParams,h=this._textMeshTransformProps,u=P(h.fontSize),l=h.haloSize,p=h.outlineSize,f=P(h.offsetX),m=P(h.offsetY),[d,y]=Mt(c.scaleInfo,this.getTileInfo());0!==n&&o.setRotation(n);const k=o.bounds,g=s+k.x+f,b=i+k.y-m,w=2*(c.minPixelBuffer?c.minPixelBuffer/u:1),x=Math.max(k.width,k.height)*w;o.textBox&&(t.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding),t.recordBounds(g,b,x,x),this._writeTextBox(t,e,s,i,o.textBox,r,a),t.recordEnd());for(const n of o.glyphs){t.recordStart(this.instanceId,this.attributeLayout,n.textureBinding),t.recordBounds(g,b,x,x);const{texcoords:o,offsets:h}=n;this._writeQuad(t,e,s,i,{texcoords:o,offsets:h,fontSize:u,haloSize:l,outlineSize:p,color:At(c.color),isBackground:!1,referenceBounds:r,minZoom:d,maxZoom:y,...a}),t.recordEnd()}0!==n&&o.setRotation(-n)}_writeTextBox(t,e,s,i,o,n,r){const a=this.evaluatedMeshParams,{fontSize:c,haloSize:h,outlineSize:u}=this._textMeshTransformProps,{boxBackgroundColor:l,boxBorderLineColor:p}=a,f={isBackground:!0,fontSize:c,haloSize:h,outlineSize:u,referenceBounds:n,...r};l&&(this._writeQuad(t,e,s,i,{texcoords:Re,offsets:o.main,color:At(l),...f}),p||(this._writeQuad(t,e,s,i,{texcoords:Fe,offsets:o.top,color:At(l),...f}),this._writeQuad(t,e,s,i,{texcoords:Ie,offsets:o.bot,color:At(l),...f}),this._writeQuad(t,e,s,i,{texcoords:Ge,offsets:o.left,color:At(l),...f}),this._writeQuad(t,e,s,i,{texcoords:Be,offsets:o.right,color:At(l),...f}))),p&&(this._writeQuad(t,e,s,i,{texcoords:Ce,offsets:o.top,color:At(p),...f}),this._writeQuad(t,e,s,i,{texcoords:Ce,offsets:o.bot,color:At(p),...f}),this._writeQuad(t,e,s,i,{texcoords:Te,offsets:o.left,color:At(p),...f}),this._writeQuad(t,e,s,i,{texcoords:Te,offsets:o.right,color:At(p),...f}))}_writeQuad(t,e,s,i,o){const n=t.vertexCount();this._writeVertex(t,e,s,i,o),t.indexWrite(n+0),t.indexWrite(n+1),t.indexWrite(n+2),t.indexWrite(n+1),t.indexWrite(n+3),t.indexWrite(n+2)}}const Ye=t=>Math.round(t*(254/360));const je=1,De=0,Oe=128,We=D((t=>{let e=0;if(0===t)return 1/0;for(;!(t%2);)e++,t/=2;return e}));class Ve extends Ee{constructor(){super(...arguments),this._zoomLevel=0}_write(t,e,s,i){if(this._zoomLevel=i||0,null!=s)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(e.geometryType){case"esriGeometryPoint":{const s=e.readXForDisplay(),i=e.readYForDisplay();this._writePoint(t,s,i,e);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":case"esriGeometryMultipoint":{const s=e.readCentroidForDisplay();if(!s)return;const[i,o]=s.coords;this._writePoint(t,i,o,e);break}case"esriGeometryPolyline":this._writeLines(t,e)}}_createLineLabelMetric(t,e,s,i){const o=h(t),n="right"===this.evaluatedMeshParams.horizontalAlignment?-1:1,r="bottom"===this.evaluatedMeshParams.verticalAlignment?-1:1,a=this.evaluatedMeshParams.scaleInfo?.maxScale??0,c=this.evaluatedMeshParams.scaleInfo?.minScale??0;return new ut(o,e,s,n,r,a,c,i??null)}_writePoint(t,e,s,i){const o=this._getShaping();if(!o)return;const n=i.getDisplayId(),r=rt(this.evaluatedMeshParams.horizontalAlignment),a=at(this.evaluatedMeshParams.verticalAlignment),c=this.evaluatedMeshParams.scaleInfo?.maxScale??0,u=this.evaluatedMeshParams.scaleInfo?.minScale??0,l=h(i.getDisplayId()),p=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};t.metricStart(new ut(l,e,s,r,a,c,u,p)),this._writeGlyphs(t,n,e,s,o,0,p),t.metricBoxWrite(o.boundsT),t.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const t of this._references){const e=t.getBoundsInfo();if(e)return e}return null}_writeLines(t,e){const{scaleInfo:s,verticalAlignment:i}=this.evaluatedMeshParams,o=this.evaluatedMeshParams.repeatLabelDistance||128,n=this._getShaping("middle");if(!n)return;const r=(t,e,s,i)=>this._placeSubdivGlyphs(t,e,s,i),a=(n.bounds.width+o)/(1<<je);this._current={out:t,id:e.getDisplayId(),shaping:n,zoomRange:Mt(s,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null},this._verticalPlacement="bottom"===i?"above":"top"===i?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(e,r,a):this._writeCenterAlong(e,r,a)}_writeAboveAndBelowAlong(t,e,s){const{repeatLabel:i}=this.evaluatedMeshParams,{shaping:o}=this._current,n=o.bounds.halfHeight,r=t.readGeometryForDisplay();if(!r)return;const a=new mt;pt(a,r,!1,!1,"esriGeometryPolyline",1);const c=qe(new mt,a,n),h=qe(new mt,a,-n),u=ft(h,"esriGeometryPolyline",!1,!1),l=ft(c,"esriGeometryPolyline",!1,!1),p=we(l.paths,o.bounds.width),f=we(u.paths,o.bounds.width);this._current.offsetDirection="above";for(const t of p)be(t,s,e,!!i);this._current.offsetDirection="below";for(const t of f)be(t,s,e,!!i)}_writeCenterAlong(t,e,s){const{repeatLabel:i}=this.evaluatedMeshParams,{shaping:o}=this._current,n=we(t.readLegacyGeometryForDisplay().paths,o.bounds.width);for(const t of n)be(t,s,e,!!i)}_placeSubdivGlyphs(t,e,s,i){const{allowOverrun:o,labelPosition:n,repeatLabelDistance:r}=this.evaluatedMeshParams,a=this._current.zoomRange[0],c=We(e),h=this._current.shaping.bounds.width/(1<<je),u=Math.sqrt(r||Oe)/(1<<je),l=Math.min(s,i-s),p=this._current.shaping.isMultiline?Ae:Math.log2(l/(u+h/2)),f=0===e?p:Math.min(c,p),m=Math.max(a,this._zoomLevel+je-f),d=this._zoomLevel-m,y=this._current.shaping.bounds.width/2*2**d;this._current.shaping.isMultiline?0===e&&this._placeStraight(t,m):o&&d<0?this._placeStraightAlong(t,a):"parallel"===n?this._placeStraightAlong(t,m):"curved"===n&&this._placeCurved(t,m,y)}_placeStraight(t,e){const{out:s,id:i,shaping:o,referenceBounds:n}=this._current,{x:r,y:a}=t;s.metricStart(this._createLineLabelMetric(i,r,a)),s.metricBoxWrite(o.boundsT);const c=t.angle*(180/Math.PI)%360,h=(t.angle*(180/Math.PI)+180)%360;this._writeGlyphs(s,i,r,a,o,0,n,{clipAngle:c,mapAligned:!0,isLineLabel:!0,minZoom:e}),this._writeGlyphs(s,i,r,a,o,0,n,{clipAngle:h,mapAligned:!0,isLineLabel:!0,minZoom:e}),s.metricEnd()}_placeCurved(t,e,s){const{out:i,id:o}=this._current;i.metricStart(this._createLineLabelMetric(o,t.x,t.y));const n=t.clone(),r=t.angle*(180/Math.PI)%360,a=(t.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(n,e,1,r),this._placeBack(t,n,e,s,1,r),this._placeForward(t,n,e,s,1,r)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(n,e,0,a),this._placeBack(t,n,e,s,0,a),this._placeForward(t,n,e,s,0,a)),i.metricEnd()}_placeStraightAlong(t,e){const{out:s,id:i,shaping:o,zoomRange:n,referenceBounds:r}=this._current,{boxBorderLineColor:a,boxBackgroundColor:c}=this.evaluatedMeshParams,h=t.clone(),u=t.angle*(180/Math.PI)%360,l=(t.angle*(180/Math.PI)+180)%360,p=o.glyphs.length>0&&!(!a&&!c);if(s.metricStart(this._createLineLabelMetric(i,t.x,t.y)),p){const a=Math.max(e,n[0],0),c=Math.min(Ae,n[1]),h=T(F(),-t.angle),p={minZoom:a,maxZoom:c,clipAngle:u,mapAligned:!0,isLineLabel:!0},f=P(this.evaluatedMeshParams.offsetX),m=P(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const e=I(f,-1*m),[n,a]=o.shapeBackground(G(F(),h,e));s.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding);const c=2*Math.max(n.width,n.height);s.recordBounds(t.x+n.x,t.y+n.y,c,c),this._writeTextBox(s,i,t.x,t.y,a,r,p),s.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const e=I(f,m),[n,a]=o.shapeBackground(G(F(),h,e));p.clipAngle=l,s.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding);const c=2*Math.max(n.width,n.height);s.recordBounds(t.x+n.x,t.y+n.y,c,c),this._writeTextBox(s,i,t.x,t.y,a,r,p),s.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(h,e,1,u,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(h,e,0,l,!0),s.metricEnd()}_placeBack(t,e,s,i,o,n){const r=t.clone();let a=t.backwardLength+De;for(;r.prev()&&!(a>=i);)this._placeOnSegment(r,e,a,s,-1,o,n),a+=r.length+De}_placeForward(t,e,s,i,o,n){const r=t.clone();let a=t.remainingLength+De;for(;r.next()&&!(a>=i);)this._placeOnSegment(r,e,a,s,1,o,n),a+=r.length+De}_placeFirst(t,e,s,i,o=!1){const{out:n,id:r,shaping:a,zoomRange:c,referenceBounds:h}=this._current,u=a.glyphs;for(const l of u){const u=l.x>a.bounds.x?s:1-s,p=u*t.remainingLength+(1-u)*t.backwardLength,f=Math.abs(l.x+l.width/2-a.bounds.x),m=Math.max(0,this._zoomLevel+Math.log2(f/(p+De))),d=Math.max(e,o?0:m);l.maxZoom=Math.min(c[1],Ae),l.angle=t.angle+(1-s)*Math.PI,l.minZoom=Math.max(c[0],d),this._writeLineGlyph(n,r,t.x,t.y,a.bounds,l,i,h,!0),(s||this._current.offsetDirection)&&this._isVisible(l.minZoom,l.maxZoom)&&n.metricBoxWrite(l.bounds)}}_placeOnSegment(t,e,s,i,o,n,r){const{out:a,id:c,shaping:h,referenceBounds:u}=this._current,l=h.glyphs,p=t.dx/t.length,f=t.dy/t.length,m={x:t.x+s*-o*p,y:t.y+s*-o*f};for(const e of l){const l=e.x>h.bounds.x?n:1-n;if(!(l&&1===o||!l&&-1===o))continue;const p=Math.abs(e.x+e.width/2-h.bounds.x),f=Math.max(0,this._zoomLevel+Math.log2(p/s)-.1),d=Math.max(i,this._zoomLevel+Math.log2(p/(s+t.length+De)));0!==f&&(e.angle=t.angle+(1-n)*Math.PI,e.minZoom=d,e.maxZoom=f,this._writeLineGlyph(a,c,m.x,m.y,h.bounds,e,r,u,!0),(n||this._current.offsetDirection)&&this._isVisible(e.minZoom,e.maxZoom)&&a.metricBoxWrite(e.bounds))}}_writeLineGlyph(t,e,s,i,o,n,r,a,c){const h=s+o.x,u=i+o.y,l=2*(this.evaluatedMeshParams.minPixelBuffer?this.evaluatedMeshParams.minPixelBuffer/this._textMeshTransformProps.fontSize:1),p=Math.max(o.width,o.height)*l;t.recordStart(this.instanceId,this.attributeLayout,n.textureBinding),t.recordBounds(h,u,p,p);const{texcoords:f,offsets:m}=n,{fontSize:d,haloSize:y,outlineSize:k}=this._textMeshTransformProps;this._writeQuad(t,e,s,i,{texcoords:f,offsets:m,fontSize:d,haloSize:y,outlineSize:k,color:At(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:a,minZoom:Math.max(this._current.zoomRange[0],n.minZoom),maxZoom:Math.min(this._current.zoomRange[1],n.maxZoom),clipAngle:r,mapAligned:c,isLineLabel:!0}),t.recordEnd()}_isVisible(t,e){const s=Math.floor(this._zoomLevel*M)/M;return t<=s&&s<=e}}function qe(t,e,s){const{coords:i,lengths:o}=e,n=O(),r=O(),a=O(),c=O(),h=O(),u=O(),l=2;let p=0;for(let e=0;e<o.length;e++){const f=o[e];for(let e=0;e<f;e++){const o=l*(e+p-1),m=l*(e+p),d=l*(e+p+1);e>0?B(n,i[o],i[o+1]):B(n,0,0),B(r,i[m],i[m+1]),e<f-1?B(a,i[d],i[d+1]):B(a,0,0),0===e?B(c,0,0):(X(c,r,n),E(c,c),B(c,c[1],-c[0])),e===f-1?B(h,0,0):(X(h,a,r),E(h,h),B(h,h[1],-h[0])),Y(u,c,h),E(u,u);const y=u[0]*h[0]+u[1]*h[1];0!==y&&j(u,u,y),j(u,u,s),t.coords.push(r[0]+u[0],r[1]+u[1])}t.lengths.push(f),p+=f}return t}const Ze={createComputedParams:t=>t,optionalAttributes:Vt.optionalAttributes,attributes:{...Vt.attributes,bitset:{type:x.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:t,shouldScaleDash:e,isSDF:s})=>zt([[i,t],[u,e],[l,s]])},tlbr:{type:x.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:s,height:i}=t,o=e.x+z,n=e.y+z;return[o,n,o+s,n+i]}},accumulatedDistance:{type:x.UNSIGNED_SHORT,count:1,packTessellation:({distance:t})=>t},segmentDirection:{type:x.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]},offsetAlongLine:{type:x.HALF_FLOAT,count:1,pack:({offsetAlongLine:t})=>P(t)},capType:{type:x.UNSIGNED_BYTE,count:1,pack:({capType:t})=>{switch(t){case k.Butt:case"butt":return 0;case k.Square:case"square":return 1;case k.Round:case"round":return 2;default:return 0}}}}};class Ne extends Nt{constructor(t,e,s,i){super(t,e,s,i),this.vertexSpec=Ze,this._tessellationOptions.textured=!0}_write(t,e,s){const i=s??et.fromFeatureSetReaderCIM(e);if(!i)return;const{sprite:o}=this.evaluatedMeshParams;this._writeGeometry(t,e,i,o?.textureBinding)}}class He{static from(t){return"width"in t?this.fromSimpleMeshParams(t):this.fromComplexMeshParams(t)}static fromSimpleMeshParams(t){const e=new He(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects),{type:s,width:i,height:o,angle:n,alignment:r,outlineSize:a,referenceSize:c,sprite:h,overrideOutlineColor:u}=t;return e.rawWidth=P(i),e.rawHeight=P(o),e.angle=n,e.alignment=r,e.outlineSize=P(a),e.referenceSize=P(c),e.overrideOutlineColor=u,e.offsetX=P(t.offsetX),e.offsetY=P(t.offsetY),"simple"!==s||h.sdf||(e.rawWidth=h.width,e.rawHeight=h.height),e._computeSize(t,!1),e}static fromComplexMeshParams(t){const e=new He(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects);let{alignment:s,transforms:i,size:o,scaleX:n,anchorX:r,anchorY:a,angle:c,colorLocked:h,frameHeight:u,widthRatio:l,offsetX:p,offsetY:f,outlineSize:m,referenceSize:d,scaleFactor:y,sizeRatio:k,isAbsoluteAnchorPoint:g,rotateClockwise:b,scaleSymbolsProportionally:w,sprite:x}=t;if(i&&i.infos.length>0){const t=S(o,c,b,p,f,i);o=t.size,c=t.rotation,p=t.offsetX,f=t.offsetY,b=!1}y&&(o*=y,p*=y,f*=y);const M=n*(x.width/x.height);e.alignment=s,e.rawHeight=P(o),e.rawWidth=e.rawHeight*M,e.referenceSize=P(d),e.sizeRatio=k,e.sdfDecodeCoeff=(x.sdfDecodeCoeff??1)*k,e.angle=c,e.rotateClockwise=b,e.anchorX=r,e.anchorY=a,e.offsetX=P(p),e.offsetY=P(f),g&&o&&(x.sdf?e.anchorX=r/(o*l):e.anchorX=r/(o*M),e.anchorY=a/o);const z=w&&u?o/u:1;return e.outlineSize=0===m||isNaN(m)?0:P(m)*z,e.scaleSymbolsProportionally=w,e.colorLocked=h,e._computeSize(t,!0),e}constructor(t,e,s,i,o,n,r){this.sprite=t,this.color=e,this.outlineColor=s,this.minPixelBuffer=i,this.placement=o,this.scaleInfo=n,this.effects=r,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=W.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(t,e){const{sprite:s,hasSizeVV:i}=t,o=!!s.sdf,n=s.sdfPaddingRatio??.5,{rawWidth:r,rawHeight:a,sizeRatio:c,outlineSize:h}=this,u=c*(o?1/(1-n):1),l=r*u,p=a*u;if(o&&!i){const t=e&&r>a?l:r,s=a,i=h+2*1;this.computedWidth=Math.min(t+i,l),this.computedHeight=Math.min(s+i,p)}else this.computedWidth=l,this.computedHeight=p;const f=o?Math.max(s.width,s.height)/Math.max(l,p):1,m=.5*(l-this.computedWidth)*f,d=.5*(p-this.computedHeight)*f,y=s.rect.x+z+m,k=s.rect.y+z+d,g=y+s.width-2*m,b=k+s.height-2*d;this.texXmin=Math.floor(y),this.texYmin=Math.floor(k),this.texXmax=Math.ceil(g),this.texYmax=Math.ceil(b),this.computedWidth*=(this.texXmax-this.texXmin)/(g-y),this.computedHeight*=(this.texYmax-this.texYmin)/(b-k),this.anchorX*=l/this.computedWidth,this.anchorY*=p/this.computedHeight}}const $e=3.14159265359/180,Qe=128/Math.PI;function Ue(t,e){return t%=e,Math.abs(t>=0?t:t+e)}function Je(t){return Ue(t*Qe,256)}function Ke(t,e,s,i,o=!1){const n=F(),r=o?1:-1;return V(n),(e||s)&&G(n,n,[e,-s]),i&&q(n,n,r*$e*-i),n}const ts={createComputedParams:t=>He.from(t),optionalAttributes:{zoomRange:{type:x.SHORT,count:2,packPrecisionFactor:M,pack:({scaleInfo:t},{tileInfo:e})=>Mt(t,e)}},attributes:{pos:{type:x.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:x.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:x.UNSIGNED_BYTE,count:1,pack:({sprite:e,alignment:s,scaleSymbolsProportionally:i,overrideOutlineColor:o,colorLocked:n})=>{let r=0;return e.sdf&&(r|=Pt(t.bitset.isSDF)),s===W.MAP&&(r|=Pt(t.bitset.isMapAligned)),i&&(r|=Pt(t.bitset.scaleSymbolsProportionally)),o&&(r|=Pt(t.bitset.overrideOutlineColor)),n&&(r|=Pt(t.bitset.colorLocked)),r}},offset:{type:x.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({angle:t,computedWidth:e,computedHeight:s,anchorX:i,anchorY:o,offsetX:n,offsetY:r,rotateClockwise:a})=>{const c=Ke(0,n,r,-t,a),h=-(.5+i)*e,u=-(.5-o)*s,l=[h,u],p=[h+e,u],f=[h,u+s],m=[h+e,u+s];return Z(l,l,c),Z(p,p,c),Z(f,f,c),Z(m,m,c),[l,p,f,m]}}},textureUV:{type:x.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:t,texXmin:e,texYmax:s,texYmin:i})=>[[e,i],[t,i],[e,s],[t,s]]}},color:{type:x.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>At(t)},outlineColor:{type:x.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>At(t)},sizing:{type:x.UNSIGNED_BYTE,count:4,pack:({rawWidth:t,rawHeight:e,outlineSize:s,referenceSize:i})=>{const o=Math.max(t,e);return[Rt(o,128),Rt(s,128),Rt(i,128),0]}},placementAngle:{type:x.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:t})=>Je(t)},sdfDecodeCoeff:{type:x.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:t})=>t}}};class es extends ${constructor(){super(...arguments),this.vertexSpec=ts}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(t,e,s){const i=this.evaluatedMeshParams.sprite?.textureBinding,o=e.getDisplayId();t.recordStart(this.instanceId,this.attributeLayout,i);const n=this.evaluatedMeshParams.minPixelBuffer,r=Math.max(this.evaluatedMeshParams.computedWidth,n),a=Math.max(this.evaluatedMeshParams.computedHeight,n),c=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,h=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,u=this.evaluatedMeshParams.offsetX+c,l=-this.evaluatedMeshParams.offsetY+h;if(null!=this.evaluatedMeshParams.placement)this._writePlacedMarkers(t,e,s,r,a);else if(s?.nextPath()){s.nextPoint();const e=s.x,i=s.y;t.recordBounds(e+u,i+l,r,a),this._writeQuad(t,o,e,i)}else if("esriGeometryPolygon"===e.geometryType){const s=e.readCentroidForDisplay();if(!s)return;const[i,n]=s.coords;t.recordBounds(i+u,n+l,r,a),this._writeQuad(t,o,i,n)}else if("esriGeometryPoint"===e.geometryType){const s=e.readXForDisplay(),i=e.readYForDisplay();t.recordBounds(s+u,i+l,r,a),this._writeQuad(t,o,s,i)}else{const s=e.readGeometryForDisplay();s?.forEachVertex(((e,s)=>{t.recordBounds(e+u,s+l,r,a),Math.abs(e)>dt||Math.abs(s)>dt||this._writeQuad(t,o,e,s)}))}t.recordEnd()}_writePlacedMarkers(t,e,s,i,o){const n=s??et.fromFeatureSetReaderCIM(e)?.clone();if(!n)return;const r=-1,a=Me.getPlacement(n,r,this.evaluatedMeshParams.placement,P(1),t.id,K());if(!a)return;const c=e.getDisplayId();let h=a.next();const u=this.evaluatedMeshParams.offsetX,l=-this.evaluatedMeshParams.offsetY;for(;null!=h;){const e=h.tx,s=-h.ty;if(Math.abs(e)>dt||Math.abs(s)>dt){h=a.next();continue}const n=-h.getAngle();t.recordBounds(e+u,s+l,i,o),this._writeQuad(t,c,e,s,n),h=a.next()}}_writeQuad(t,e,s,i,o){const n=t.vertexCount(),r=null==o?null:{placementAngle:o};this._writeVertex(t,e,s,i,r),t.indexWrite(n+0),t.indexWrite(n+1),t.indexWrite(n+2),t.indexWrite(n+1),t.indexWrite(n+3),t.indexWrite(n+2)}}function ss(t){return t instanceof is?t:"object"==typeof t&&"type"in t?as[t.type].hydrate(t):new os(t)}class is{constructor(t){this.inputs=t}encode(){const t=[];for(const e of this.inputs)t.push(...e.encode());return t.push(...this.instructions),t}}class os extends is{constructor(t){super([]),this.value=t}simplify(){return this}get instructions(){if(Array.isArray(this.value)){const[t,e,s,i]=this.value;return null!=i?p.vector4.encode([t,e||0,s||0,i]):p.vector3.encode([t,e||0,s||0])}return p.scalar.encode(this.value)}}class ns extends is{constructor(t,e){super([e]),this._config=t,this._parent=e}static hydrate(t){return new ns(t,ss(t.parent))}simplify(){if(this._config.relativeTranslation||this._config.absoluteScale)return this;const t=this._parent.simplify();if(!(t instanceof os))return this;const[e,s,i,o]=t.value,n=this._config.translation.from[0],r=this._config.translation.from[1],a=this._config.rotation.from,c=this._config.scale.from;if(n===this._config.translation.to[0]&&r===this._config.translation.to[1]&&a===this._config.rotation.to&&c===this._config.scale.to){const t=i+a,h=o*c,u=Math.sin(i),l=Math.cos(i);return new os([l*o*n-u*o*r+e,u*o*n+l*o*r+s,t,h])}return new ns(this._config,t)}get instructions(){return p.animatedTransform.encode(this._config)}}class rs extends is{constructor(t,e){super([e]),this._config=t,this._parent=e}static hydrate(t){return new rs(t,ss(t.parent))}simplify(){const t=this._parent.simplify();if(!(t instanceof os))return this;const[e,s,i,o]=t.value,n=this._config.color.from[0],r=this._config.color.from[1],a=this._config.color.from[2];let c=this._config.color.from[3];const h=this._config.opacity.from;return n===this._config.color.to[0]&&r===this._config.color.to[1]&&a===this._config.color.to[2]&&c===this._config.color.to[3]&&h===this._config.opacity.to?(c*=h,new os([e*n,s*r,i*a,o*c])):new rs(this._config,t)}get instructions(){return p.animatedColor.encode(this._config)}}const as={AnimatedTransform:ns,AnimatedColor:rs};function cs(t){return us(t.map((t=>ps(t))).map((t=>ss(t).simplify())))}function hs(t){const e=[];return e.push(t.transform),e.push(t.fromColor),e.push(t.toColor),e.push(t.colorMix),e.push(t.toOpacity),e.push(t.opacityMix),e}function us(t){const e=[],s=[];let i=0;for(const o of t){const n=[...o.encode(),...p.ret.encode()];e.push([i+t.length,0,0,0]),s.push(...n),i+=n.length}return[...e,...s]}async function ls(t,e){const s=t;let i;if("number"==typeof s||"string"==typeof s||"boolean"==typeof s)i=s;else if(Array.isArray(s))i=await Promise.all(s.map((t=>ls(t,e))));else if("object"==typeof s)if("valueExpressionInfo"in s){const{valueExpressionInfo:t}=s,{expression:o}=t;i={...s,computed:await e.createComputedField({expression:o})}}else{i={};for(const t in s)i[t]=await ls(s[t],e)}return i}function ps(t,e,s){function i(t){if(!("computed"in t))return t;let i=t.computed.readWithDefault(e,s,[255*t.defaultValue[0],255*t.defaultValue[1],255*t.defaultValue[2],t.defaultValue[3]]);if("string"==typeof i){const t=m.fromString(i);t&&(i=[t.r,t.g,t.b,t.a])}return i}const o=t;let n;if("number"==typeof o||"string"==typeof o||"boolean"==typeof o)n=o;else if(Array.isArray(o))n=o.map((t=>ps(t,e,s)));else if("object"==typeof o)if("type"in o&&null!=o.type&&"Process"===o.type)switch(o.op){case"ArcadeColor":{const t=ps(o.value,e,s);fs(Array.isArray(t)&&4===t.length);n=[t[0]/255,t[1]/255,t[2]/255,t[3]]}break;case"Transparency":{const t=ps(o.value,e,s);fs("number"==typeof t),n=1-t/100}break;case"Divide":{const t=ps(o.left,e,s);fs("number"==typeof t);const i=ps(o.right,e,s);fs("number"==typeof i),n=t/i}break;case"Random":{const t=ps(o.seed,e,s),i=ps(o.min,e,s),r=ps(o.max,e,s),a=e.getObjectId(),c=yt(a||0);n=i+kt(c,t)*(r-i)}}else if("computed"in o)n=i(o);else{n={};for(const t in o)n[t]=ps(o[t],e,s)}return n}function fs(t){if(!t)throw new Error("Assertion failed.")}class ms extends gt{constructor(t){super(),this._value=t}resize(t){}read(t,e){return this._value}readWithDefault(t,e,s){return this._value}referencesScale(){return!1}referencesGeometry(){return!1}}const ds=()=>d.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function ys(t,e,s=!1){const{defaultValue:i,valueExpressionInfo:o,value:n}=e;if(o){const{expression:n}=o,r=await t.createComputedField({expression:n},s);return r?{...e,computed:r,defaultValue:i}:null}return{...e,computed:new ms(n),defaultValue:i}}async function ks(t,e){const{valueExpressionInfo:s}=e,{expression:i}=s,o=await t.createComputedField({expression:i});return o?{...e,computed:o}:null}function gs(t){return"object"==typeof t&&null!=t&&(!(!("valueExpressionInfo"in t)||!t.valueExpressionInfo)||"type"in t&&"Process"===t.type&&"op"in t&&"Random"===t.op)}function bs(t){if(Array.isArray(t))for(const e of t)if(bs(e))return!0;if("object"==typeof t){if(gs(t))return!0;for(const e in t){if(bs(t[e]))return!0}}return!1}class ws{static async create(t,e,s){const i={},o=new Map,n=new Map,r=new Map,a=new Map,c=new Map,h=new Map;for(const u in s){const l=s[u];if(null!=l&&"object"==typeof l)if(Array.isArray(l)){if("object"==typeof l[0])throw new Error(`InternalError: Cannot handle ${u}. Nested array params are not supported`);i[u]=l}else if("valueExpressionInfo"in l){if(l.value){i[u]=l.value;continue}const e=await ks(t,l);if(!e){i[u]=l.defaultValue;continue}o.set(u,e),i[u]=null}else switch(l.type){case"cim-effect-infos":if(l.effectInfos.some((t=>t.overrides.length))){n.set(u,{effects:await Promise.all(l.effectInfos.map((async e=>{const s=e.overrides.map((e=>ys(t,e)));return{effect:e.effect,compiledOverrides:(await Promise.all(s)).filter(N)}})))});break}i[u]=l.effectInfos.map((t=>t.effect));break;case"cim-marker-placement-param":l.overrides.length&&r.set(u,{placementInfo:l,compiledOverrides:(await Promise.all(l.overrides.map((e=>ys(t,e))))).filter(N)}),i[u]=l.placement;break;case"text-rasterization-param":{if(l.overrides.length){const e=l.overrides.map((e=>ys(t,e,l.useLegacyLabelEvaluationRules)));a.set(u,{compiledOverrides:(await Promise.all(e)).filter(N),rasterizationParam:l,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:l.resource};i[u]=await e.fetchResourceImmediate(s)??null;break}case"sprite-rasterization-param":{if(l.overrides.length){const e=l.overrides.map((e=>ys(t,e)));a.set(u,{compiledOverrides:(await Promise.all(e)).filter(N),rasterizationParam:l,objectIdToResourceId:new Map});continue}if("animated"===l.resource.type){a.set(u,{compiledOverrides:[],rasterizationParam:l,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:l.resource};i[u]=await e.fetchResourceImmediate(s)??null;break}case"cim-marker-transform-param":{const{params:e}=l;if(bs(e)){const s={compiledMarkerInfos:[]};await Promise.all(e.map((async e=>{const i={props:{}};for(const s in e)if(gs(e[s])){const o=await ks(t,e[s]);i.compiledExpressionMap||(i.compiledExpressionMap=new Map);const n=i.compiledExpressionMap;o&&n.set(s,o)}else i.props[s]=e[s];s.compiledMarkerInfos.push(i)}))),c.set(u,s)}else i[u]={type:"cim-marker-transform-info",infos:e};break}case"animation-params":{const{params:s}=l,o=hs(s);if(bs(o)){const e=await Promise.all(o.map((e=>ls(e,t))));h.set(u,{params:e,propertyIdToResourceId:new Map,key:u})}else{const t=cs(o),s=await e.fetchResourceImmediate({type:"animation-info",resource:t});null!=s&&"sprite"===s.type&&(i[u]={dataRow:s.rect.y,dataColumn:s.rect.x})}break}default:i[u]=l}else i[u]=l}return new ws(s,i,o,n,r,a,c,h)}constructor(t,e,s,i,o,n,r,a){this.inputMeshParams=t,this._resolvedMeshParams=e,this._dynamicProperties=s,this._dynamicEffectProperties=i,this._dynamicPlacementProperties=o,this._dynamicAsyncProperties=n,this._dynamicTransformProperties=r,this._dynamicAsyncAnimations=a,this.evaluator=t=>t}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(t,e,s){for(const i of this._dynamicAsyncProperties.values()){const o=H(i.rasterizationParam.resource);"animated"===i.rasterizationParam.resource.type&&i.rasterizationParam.resource.randomizeStartTime&&(o.primitiveName="__RESERVED__PRIMITIVE__NAME__",o.startGroup=yt(e.getObjectId()||0));for(const{primitiveName:t,propertyName:n,computed:r,defaultValue:a,valueExpressionInfo:c}of i.compiledOverrides)try{const c="animated"===i.rasterizationParam.resource.type?o.primitiveName:t;lt(o,c,n,r,e,s,a)}catch(e){ds().errorOnce(new y("invalid-arcade-expression",`Encountered an error when evaluating the arcade expression '${c?.expression}' (primitive: '${t}', property: '${n}')`,e))}const n=t.enqueueRequest({type:"cim-rasterization-info",resource:o});i.objectIdToResourceId.set(e.getObjectId(),n)}for(const i of this._dynamicAsyncAnimations.values()){const o=i.params.map((t=>ps(t,e,s))).map(ss).map((t=>t.simplify())),n=us(o),r=t.enqueueRequest({type:"animation-info",resource:n});i.propertyIdToResourceId.set(e.getObjectId()+"."+i.key,r)}}evaluateMeshParams(t,e,s){for(const[t,i]of this._dynamicProperties.entries())this._resolvedMeshParams[t]=i.computed.readWithDefault(e,s,i.defaultValue);for(const[t,i]of this._dynamicPlacementProperties.entries())for(const{computed:o,defaultValue:n,propertyName:r}of i.compiledOverrides){const a=o.readWithDefault(e,s,n);i.placementInfo.placement[r]=a,this._resolvedMeshParams[t]=i.placementInfo.placement}for(const[t,i]of this._dynamicEffectProperties.entries())for(const o of i.effects){for(const{computed:t,defaultValue:i,propertyName:n}of o.compiledOverrides){const r=t.readWithDefault(e,s,i);o.effect[n]=r}this._resolvedMeshParams[t]=i.effects.map((t=>t.effect))}for(const[t,i]of this._dynamicTransformProperties.entries()){const o={type:"cim-marker-transform-info",infos:[]};for(const t of i.compiledMarkerInfos){const i={...t.props};if(t.compiledExpressionMap)for(const[o,n]of t.compiledExpressionMap){const t=n.computed.readWithDefault(e,s,n.defaultValue);i[o]="number"==typeof t||"boolean"==typeof t?t:n.defaultValue}o.infos.push(i)}this._resolvedMeshParams[t]=o}for(const[s,i]of this._dynamicAsyncProperties.entries()){const o=i.objectIdToResourceId.get(e.getObjectId());if(null==o)continue;const n=t.getResource(o);this._resolvedMeshParams[s]=n}for(const[s,i]of this._dynamicAsyncAnimations.entries()){const o=i.propertyIdToResourceId.get(e.getObjectId()+"."+s);if(null==o)continue;const n=t.getResource(o);this._resolvedMeshParams[s]={dataRow:n.rect.y,dataColumn:n.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}}const xs={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:x.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:x.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:x.UNSIGNED_BYTE,count:1,pack:t=>0},offset:{type:x.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:t})=>{const e=P(t),s=-e/2,i=-e/2;return[[s,i],[s+e,i],[s,i+e],[s+e,i+e]]}}},texCoords:{type:x.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:x.UNSIGNED_BYTE,count:2,pack:({size:t})=>[t,t]},referenceSize:{type:x.UNSIGNED_BYTE,count:1,pack:({size:t})=>P(t)},zoomRange:{type:x.UNSIGNED_BYTE,count:2,pack:({scaleInfo:t},{tileInfo:e})=>Mt(t,e)}}};class Ms extends ${constructor(){super(...arguments),this.vertexSpec=xs}_write(t,e){const s=e.getDisplayId(),i=this.evaluatedMeshParams.minPixelBuffer,o=Math.max(P(this.evaluatedMeshParams.size),i);let n,r;if("esriGeometryPoint"===e.geometryType)n=e.readXForDisplay(),r=e.readYForDisplay();else{const t=e.readCentroidForDisplay();if(!t)return;n=t?.coords[0],r=t?.coords[1]}t.recordStart(this.instanceId,this.attributeLayout),t.recordBounds(n,r,o,o);const a=t.vertexCount();this._writeVertex(t,s,n,r),t.indexWrite(a+0),t.indexWrite(a+1),t.indexWrite(a+2),t.indexWrite(a+1),t.indexWrite(a+3),t.indexWrite(a+2),t.recordEnd()}}class Ps{async createMeshWriter(t,e,s,i){const o=this._getMeshWriter(i.techniqueType),n=await ws.create(t,e,i.inputParams),r=new o(i.id,n,i.optionalAttributes,s);return await r.loadDependencies(),r}_getMeshWriter(t){switch(t){case f.Fill:return Bt;case f.DotDensity:return It;case f.ComplexFill:return Ot;case f.PatternFill:return Et;case f.OutlineFill:return Ut;case f.PatternOutlineFill:return ae;case f.ComplexOutlineFill:return ie;case f.Marker:return es;case f.PieChart:return Ms;case f.Text:return Ee;case f.Line:return Nt;case f.TexturedLine:return Ne;case f.Heatmap:return he;case f.Label:return Ve;case f.AnimatedMarker:return Tt;default:throw new Error("Internal Error: Mesh writer not in the registry")}}}export{Ps as j,ms as r};
//# sourceMappingURL=p-59e47154.js.map