import{n as t}from"./p-d97e7de8.js";import{t as s}from"./p-4c2ef9f4.js";import{h as i,y as h,al as n,am as e,an as o,ao as a,ap as r,aq as c,ar as l,a0 as u,a2 as d,as as m,at as f,au as p,av as g,aw as w,ax as v,ay as M,az as _,aA as b,aB as y,aC as x,aD as S,aE as k,aF as C,aG as $,aH as L,aI as z,af as B,aJ as P}from"./p-3013819f.js";import{t as R}from"./p-59429ce9.js";import{u as T,O as E,Q as F}from"./p-b362a32c.js";import{t as D}from"./p-721433ed.js";import{a as V}from"./p-595ce045.js";const j={shaders:{vertexShader:t("bitBlit/bitBlit.vert"),fragmentShader:t("bitBlit/bitBlit.frag")},attributes:new Map([["a_pos",0],["a_tex",1]])};const q={shaders:{vertexShader:t("stencil/stencil.vert"),fragmentShader:t("stencil/stencil.frag")},attributes:new Map([["a_pos",0]])};const I={shaders:{vertexShader:t("highlight/textured.vert"),fragmentShader:t("highlight/highlight.frag")},attributes:new Map([["a_position",0],["a_texcoord",1]])},N={shaders:{vertexShader:t("highlight/textured.vert"),fragmentShader:t("highlight/blur.frag")},attributes:new Map([["a_position",0],["a_texcoord",1]])};const U=i("esri-2d-profiler");class Z{constructor(t,i){if(this._events=new h,this._entries=new Map,this._timings=new s(10),this._currentContainer=null,this._currentPass=null,this._currentBrush=null,this._currentSummary=null,!U)return;this._ext=R(t.gl,{}),this._debugOutput=i;const n=t.gl;if(!this.enableCommandLogging)return;let e;for(e in n)if("function"==typeof n[e]){const t=n[e],s=e.includes("draw");n[e]=(...i)=>(this._events.emit("command",{container:this._currentContainer,pass:this._currentPass,brush:this._currentBrush,method:e,args:i,isDrawCommand:s}),this._currentSummary&&(this._currentSummary.commands++,s&&this._currentSummary.drawCommands++),t.apply(n,i))}}get enableCommandLogging(){return!("object"==typeof U&&U.disableCommands)}recordContainerStart(t){U&&(this._currentContainer=t)}recordContainerEnd(){U&&(this._currentContainer=null)}recordPassStart(t){U&&(this._currentPass=t,this._initSummary())}recordPassEnd(){U&&(this._currentPass=null,this._emitSummary())}recordBrushStart(t){U&&(this._currentBrush=t)}recordBrushEnd(){U&&(this._currentBrush=null)}recordStart(t){if(U&&null!=this._ext){if(this._entries.has(t)){const s=this._entries.get(t),i=this._ext.resultAvailable(s.query),h=this._ext.disjoint();if(i&&!h){const i=this._ext.getResult(s.query)/1e6;let h=0;if(null!=this._timings.enqueue(i)){const t=this._timings.entries,s=t.length;let i=0;for(const s of t)i+=s;h=i/s}const n=i.toFixed(2),e=h?h.toFixed(2):"--";this.enableCommandLogging?(console.groupCollapsed(`Frame report for ${t}, ${n} ms (${e} last 10 avg)\n${s.commandsLen} Commands (${s.drawCommands} draw)`),console.log("RenderPass breakdown: "),console.table(s.summaries),console.log("Commands: ",s.commands),console.groupEnd()):console.log(`Frame report for ${t}, ${n} ms (${e} last 10 avg)`),this._debugOutput.innerHTML=`${n} (${e})`}for(const t of s.handles)t.remove();this._ext.deleteQuery(s.query),this._entries.delete(t)}const s={name:t,query:this._ext.createQuery(),commands:[],commandsLen:0,drawCommands:0,summaries:[],handles:[]};this.enableCommandLogging&&(s.handles.push(this._events.on("command",(t=>{s.commandsLen++,s.commands.push(t),t.isDrawCommand&&s.drawCommands++}))),s.handles.push(this._events.on("summary",(t=>{s.summaries.push(t)})))),this._ext.beginTimeElapsed(s.query),this._entries.set(t,s)}}recordEnd(t){U&&null!=this._ext&&this._entries.has(t)&&this._ext.endTimeElapsed()}_initSummary(){this.enableCommandLogging&&(this._currentSummary={container:this._currentContainer,pass:this._currentPass,drawCommands:0,commands:0})}_emitSummary(){this.enableCommandLogging&&this._currentSummary&&this._events.emit("summary",this._currentSummary)}}const A=1,G=0,O=1,X=2;class Y{constructor(t,s,i){this._debugMap=new Map,this._width=t*i,this._height=s*i,this._pixelRatio=i;const h=Math.ceil(this._width/A),n=Math.ceil(this._height/A);this._cols=h,this._rows=n,this._cells=D.create(h*n)}insertMetrics(t){this._markMetrics(t)}hasCollision(t){let s=0;for(const{computedX:i,computedY:h,width:n,height:e}of t.bounds){const t=(n+T)*this._pixelRatio,o=(e+T)*this._pixelRatio;switch(this._collide(i,h,t,o)){case X:return X;case O:s++}}return s===t.bounds.length?O:G}getCellId(t,s){return t+s*this._cols}has(t){return this._cells.has(t)}hasRange(t,s){return this._cells.hasRange(t,s)}set(t){this._cells.set(t)}setRange(t,s){this._cells.setRange(t,s)}_collide(t,s,i,h){const e=t-i/2,o=s-h/2,a=e+i,r=o+h;if(a<0||r<0||e>this._width||o>this._height)return O;const c=n(Math.floor(e/A),0,this._cols),l=n(Math.floor(o/A),0,this._rows),u=n(Math.ceil(a/A),0,this._cols),d=n(Math.ceil(r/A),0,this._rows);for(let t=l;t<=d;t++)for(let s=c;s<=u;s++){const i=this.getCellId(s,t);if(this.has(i))return X}return G}_mark(t,s,i,h,e){const o=t-i/2,a=s-h/2,r=o+i,c=a+h,l=n(Math.floor(o/A),0,this._cols),u=n(Math.floor(a/A),0,this._rows),d=n(Math.ceil(r/A),0,this._cols),m=n(Math.ceil(c/A),0,this._rows);for(let t=u;t<=m;t++)for(let s=l;s<=d;s++){const i=this.getCellId(s,t);this._debugMap.set(i,e),this.set(i)}return!1}_markMetrics(t){for(const{computedX:s,computedY:i,width:h,height:n}of t.bounds){const e=(h+T)*this._pixelRatio,o=(n+T)*this._pixelRatio;this._mark(s,i,e,o,t.entityTexel)}}}const H=254,J=255,K=0;function Q(t,s){const i=t.children.slice();i.sort(((t,s)=>t.tileAge-s.tileAge)),i.forEach((t=>{null!=t.labelMetrics&&t.isReady&&s(t,t.labelMetrics)}))}function W(t,s){return(!t.minScale||t.minScale>=s)&&(!t.maxScale||t.maxScale<=s)}class tt{run(t,s,h,n){const e=[];for(let s=t.length-1;s>=0;s--){const i=t[s];i.labelingCollisionInfos?.length&&e.push(...i.labelingCollisionInfos)}i("esri-2d-update-debug")&&e.length&&console.debug("CollisionEngine.run"),this._transformMetrics(e),this._runCollision(e,s,h,n);for(const t of e)t.container.requestRender()}_runCollision(t,s,i,h){const[n,e]=s.state.size,o=new Y(n,e,s.pixelRatio);for(const{container:s,deconflictionEnabled:n,visible:e}of t){const t=s.attributeView;n?e?(this._prepare(s),this._collideVisible(o,s,i,h),this._collideInvisible(o,s)):Q(s,((s,i)=>{for(const s of i)t.setLabelMinZoom(s.entityTexel,J)})):Q(s,((s,h)=>{for(const s of h)W(s,i)?(t.setLabelMinZoom(s.entityTexel,K),e&&o.insertMetrics(s)):t.setLabelMinZoom(s.entityTexel,H)}))}}_isFiltered(t,s,i){const h=s.getFilterFlags(t),n=!i.hasFilter||!!(h&E),e=null==i.featureEffect||i.featureEffect.excludedLabelsVisible||!!(h&F);return!(n&&e)}_prepare(t){const s=t.attributeView,i=new Set;Q(t,((h,n)=>{for(const h of n){const n=h.entityTexel;if(i.has(n))continue;if(i.add(n),this._isFiltered(n,s,t.layerView)){s.setLabelMinZoom(n,H);continue}s.getLabelMinZoom(n)!==K?s.setLabelMinZoom(n,J):s.setLabelMinZoom(n,K)}}))}_collideVisible(t,s,i,h){const n=s.attributeView,e=new Set;Q(s,((s,o)=>{for(let a=0;a<o.length;a++){const r=o[a].entityTexel;if(e.has(r))continue;if(s.key.level!==h){n.setLabelMinZoom(r,H),e.add(r);continue}if(!W(o[a],i)){n.setLabelMinZoom(r,H),e.add(r);continue}if(0!==n.getLabelMinZoom(r)){e.add(r);continue}let c=!1,l=!0;const u=a;let d=a;for(;d<o.length;d++){const s=o[d];if(s.entityTexel!==r)break;if(c)continue;switch(t.hasCollision(s)){case O:break;case X:c=!0,l=!1;break;case G:l=!1}}if(!c)for(let s=u;s<d;s++)t.insertMetrics(o[s]);a=d-1,l||(e.add(r),n.setLabelMinZoom(r,c?H:K))}}))}_collideInvisible(t,s){const i=s.attributeView,h=new Set;Q(s,((s,n)=>{for(let s=0;s<n.length;s++){const e=n[s].entityTexel;if(h.has(e))continue;if(i.getLabelMinZoom(e)!==J){h.add(e);continue}let o=!1,a=!0;const r=s;let c=s;for(;c<n.length;c++){const s=n[c];if(s.entityTexel!==e)break;if(o)continue;switch(t.hasCollision(s)){case O:break;case X:o=!0,a=!1;break;case G:a=!1}}if(!o)for(let s=r;s<c;s++)t.insertMetrics(n[s]);s=c-1,a||(h.add(e),i.setLabelMinZoom(e,o?J:K))}}))}_transformMetrics(t){for(const{container:s,geometryType:i,vvEvaluators:h}of t)Q(s,((t,n)=>{const e=s.attributeView,o=t.transforms.labelMat2d;o[4]=Math.round(o[4]),o[5]=Math.round(o[5]);const a="polyline"===i;for(const t of n){const{entityTexel:s,anchorX:i,anchorY:n}=t;let r=t.referenceBounds?.size??0;const c=h[0];if(null!=c){const t=c(e.getVVSize(s));r=isNaN(t)||null==t||t===1/0?r:t}const l=t.directionX*(r/2),u=t.directionY*(r/2);for(const s of t.bounds){let t=i,h=n;if(a){let i=t+s.x+l,n=h+s.y+u;i=o[0]*i+o[2]*n+o[4],n=o[1]*i+o[3]*n+o[5],s.computedX=Math.floor(i),s.computedY=Math.floor(n)}else{t=o[0]*i+o[2]*n+o[4],h=o[1]*i+o[3]*n+o[5];const e=t+s.x+l,a=h+s.y+u;s.computedX=e,s.computedY=a}}}}))}}const st=32;let it=class extends e{constructor(t){super(t),this._lastUpdate=0,this.collisionEngine=new tt,this.lastUpdateId=-1,this.updateRequested=!1,this.view=null}get updating(){return i("esri-2d-log-updating")&&console.log(`Updating LabelManager ${this.updateRequested}:\n-> updateRequested: ${this.updateRequested}`),this.updateRequested}update(t){const s=performance.now();s-this._lastUpdate>=st?(this._lastUpdate=s,this.doUpdate(t)):this.requestUpdate()}viewChange(){this.requestUpdate()}requestUpdate(){this.updateRequested||(this.updateRequested=!0,this.view?.requestUpdate())}processUpdate(t){this.updateRequested&&(this.updateRequested=!1,this.update(t))}doUpdate(t){const s=this.view;if(s)try{const i=t.state.scale,h=s.featuresTilingScheme.getClosestInfoForScale(i).level;this.collisionEngine.run(s.allLayerViews.items,t,i,h)}catch(t){}}};o([a()],it.prototype,"updateRequested",void 0),o([a()],it.prototype,"updating",null),o([a()],it.prototype,"view",void 0),it=o([r("esri.views.2d.LabelManager")],it);const ht="esri-zoom-box",nt={container:`${ht}__container`,overlay:`${ht}__overlay`,background:`${ht}__overlay-background`,box:`${ht}__outline`},et={zoom:"Shift",counter:"Ctrl"};let ot=class extends e{constructor(t){super(t),this._container=null,this._overlay=null,this._backgroundShape=null,this._boxShape=null,this._box={x:0,y:0,width:0,height:0},this._rafId=null,this._redraw=this._redraw.bind(this)}destroy(){this.view=null}set view(t){this.removeAllHandles(),this._destroyOverlay(),this._set("view",t),t&&this.addHandles([t.on("drag",[et.zoom],(t=>this._handleDrag(t,1)),c.INTERNAL),t.on("drag",[et.zoom,et.counter],(t=>this._handleDrag(t,-1)),c.INTERNAL)])}_start(){this._createContainer(),this._createOverlay(),this.navigation.begin()}_update(t,s,i,h){this._box.x=t,this._box.y=s,this._box.width=i,this._box.height=h,this._rafId||(this._rafId=requestAnimationFrame(this._redraw))}_end(t,s,i,h,n){const e=this.view,o=e.toMap(l(t+.5*i,s+.5*h));let a=Math.max(i/e.width,h/e.height);-1===n&&(a=1/a),this._destroyOverlay(),this.navigation.end(),e.goTo({center:o,scale:e.scale*a})}_updateBox(t,s,i,h){const n=this._boxShape;n.setAttributeNS(null,"x",""+t),n.setAttributeNS(null,"y",""+s),n.setAttributeNS(null,"width",""+i),n.setAttributeNS(null,"height",""+h),n.setAttributeNS(null,"class",nt.box)}_updateBackground(t,s,i,h){this._backgroundShape.setAttributeNS(null,"d",this._toSVGPath(t,s,i,h,this.view.width,this.view.height))}_createContainer(){const t=document.createElement("div");t.className=nt.container,this.view.root.appendChild(t),this._container=t}_createOverlay(){const t=this.view.width,s=this.view.height,i=document.createElementNS("http://www.w3.org/2000/svg","path");i.setAttributeNS(null,"d","M 0 0 L "+t+" 0 L "+t+" "+s+" L 0 "+s+" Z"),i.setAttributeNS(null,"class",nt.background);const h=document.createElementNS("http://www.w3.org/2000/svg","rect"),n=document.createElementNS("http://www.w3.org/2000/svg","svg");n.setAttributeNS("http://www.w3.org/2000/xmlns/","xmlns:xlink","http://www.w3.org/1999/xlink"),n.setAttributeNS(null,"class",nt.overlay),n.appendChild(i),n.appendChild(h),this._container.appendChild(n),this._backgroundShape=i,this._boxShape=h,this._overlay=n}_destroyOverlay(){this._container&&this._container.parentNode&&this._container.parentNode.removeChild(this._container),this._container=this._backgroundShape=this._boxShape=this._overlay=null}_toSVGPath(t,s,i,h,n,e){const o=t+i,a=s+h;return"M 0 0 L "+n+" 0 L "+n+" "+e+" L 0 "+e+" ZM "+t+" "+s+" L "+t+" "+a+" L "+o+" "+a+" L "+o+" "+s+" Z"}_handleDrag(t,s){const i=t.x,h=t.y,n=t.origin.x,e=t.origin.y;let o,a,r,c;switch(i>n?(o=n,r=i-n):(o=i,r=n-i),h>e?(a=e,c=h-e):(a=h,c=e-h),t.action){case"start":this._start();break;case"update":this._update(o,a,r,c);break;case"end":this._end(o,a,r,c,s)}t.stopPropagation()}_redraw(){if(!this._rafId)return;if(this._rafId=null,!this._overlay)return;const{x:t,y:s,width:i,height:h}=this._box;this._updateBox(t,s,i,h),this._updateBackground(t,s,i,h),this._rafId=requestAnimationFrame(this._redraw)}};o([a()],ot.prototype,"navigation",void 0),o([a()],ot.prototype,"view",null),ot=o([r("esri.views.2d.navigation.ZoomBox")],ot);const at=ot;class rt{constructor(t){this._gain=t,this.lastValue=void 0,this.filteredDelta=void 0}update(t){if(this.hasLastValue()){const s=this.computeDelta(t);this._updateDelta(s)}this.lastValue=t}reset(){this.lastValue=void 0,this.filteredDelta=void 0}hasLastValue(){return void 0!==this.lastValue}hasFilteredDelta(){return void 0!==this.filteredDelta}computeDelta(t){return void 0===this.lastValue?NaN:t-this.lastValue}_updateDelta(t){void 0!==this.filteredDelta?this.filteredDelta=(1-this._gain)*this.filteredDelta+this._gain*t:this.filteredDelta=t}}class ct{constructor(t,s,i){this._initialVelocity=t,this._stopVelocity=s,this._friction=i,this._duration=Math.abs(Math.log(Math.abs(this._initialVelocity)/this._stopVelocity)/Math.log(1-this._friction))}get duration(){return this._duration}isFinished(t){return t>this.duration}get friction(){return this._friction}value(t){return this.valueFromInitialVelocity(this._initialVelocity,t)}valueDelta(t,s){const i=this.value(t);return this.value(t+s)-i}valueFromInitialVelocity(t,s){s=Math.min(s,this.duration);const i=1-this.friction;return t*(i**s-1)/Math.log(i)}}class lt extends ct{constructor(t,s,i,h,n){super(t,s,i),this._sceneVelocity=h,this.direction=n}value(t){return super.valueFromInitialVelocity(this._sceneVelocity,t)}}class ut{constructor(t=300,s=12,i=.84){this._minimumInitialVelocity=t,this._stopVelocity=s,this._friction=i,this.enabled=!0,this._time=new rt(.6),this._screen=[new rt(.4),new rt(.4)],this._scene=[new rt(.6),new rt(.6),new rt(.6)],this._tmpDirection=u()}add(t,s,i){if(this.enabled){if(this._time.hasLastValue()){if(this._time.computeDelta(i)<.015)return}this._screen[0].update(t[0]),this._screen[1].update(t[1]),this._scene[0].update(s[0]),this._scene[1].update(s[1]),this._scene[2].update(s[2]),this._time.update(i)}}reset(){this._screen[0].reset(),this._screen[1].reset(),this._scene[0].reset(),this._scene[1].reset(),this._scene[2].reset(),this._time.reset()}evaluateMomentum(){if(!this.enabled||!this._screen[0].hasFilteredDelta()||!this._time.hasFilteredDelta())return null;const t=this._screen[0].filteredDelta,s=this._screen[1].filteredDelta,i=null==t||null==s?0:Math.sqrt(t*t+s*s),h=this._time.filteredDelta,n=null==h||null==i?0:i/h;return Math.abs(n)<this._minimumInitialVelocity?null:this.createMomentum(n,this._stopVelocity,this._friction)}createMomentum(t,s,i){d(this._tmpDirection,this._scene[0].filteredDelta??0,this._scene[1].filteredDelta??0,this._scene[2].filteredDelta??0);const h=f(this._tmpDirection);h>0&&m(this._tmpDirection,this._tmpDirection,1/h);const n=this._time.filteredDelta;return new lt(t,s,i,null==n?0:h/n,this._tmpDirection)}}let dt=class extends e{constructor(t){super(t),this.animationTime=0,this.momentumEstimator=new ut(500,6,.92),this.momentum=null,this.tmpMomentum=u(),this.momentumFinished=!1,this.viewpoint=new p({targetGeometry:new g,scale:0,rotation:0}),this._previousDrag=null,w((()=>this.momentumFinished),(()=>this.navigation.stop()))}begin(t,s){this.navigation.begin(),this.momentumEstimator.reset(),this.addToEstimator(s),this._previousDrag=s}update(t,s){this.addToEstimator(s);let i=s.center.x,h=s.center.y;const n=this._previousDrag;i=n?n.center.x-i:-i,h=n?h-n.center.y:h,t.viewpoint=v(this.viewpoint,t.viewpoint,[i||0,h||0]),this._previousDrag=s}end(t,s){this.addToEstimator(s);const i=t.navigation.momentumEnabled;this.momentum=i?this.momentumEstimator.evaluateMomentum():null,this.animationTime=0,this.momentum&&this.onAnimationUpdate(t),this._previousDrag=null,this.navigation.end()}addToEstimator(t){const s=t.center.x,i=t.center.y,h=M(-s,i),n=_(-s,i,0);this.momentumEstimator.add(h,n,.001*t.timestamp)}onAnimationUpdate(t){this.navigation.animationManager?.animateContinous(t.viewpoint,((s,i)=>{const{momentum:h,animationTime:n,tmpMomentum:e}=this,o=.001*i;if(!(this.momentumFinished=!h||h.isFinished(n))){const i=h.valueDelta(n,o);m(e,h.direction,i),v(s,s,e),t.constraints.constrainByGeometry(s)}this.animationTime+=o}))}stopMomentumNavigation(){this.momentum&&(this.momentumEstimator.reset(),this.momentum=null,this.navigation.stop())}};o([a()],dt.prototype,"momentumFinished",void 0),o([a()],dt.prototype,"viewpoint",void 0),o([a()],dt.prototype,"navigation",void 0),dt=o([r("esri.views.2d.navigation.actions.Pan")],dt);const mt=dt;class ft{constructor(t=2.5,s=.01,i=.95,h=12){this._minimumInitialVelocity=t,this._stopVelocity=s,this._friction=i,this._maxVelocity=h,this.enabled=!0,this.value=new rt(.8),this.time=new rt(.3)}add(t,s){if(this.enabled&&null!=s){if(this.time.hasLastValue()){if(this.time.computeDelta(s)<.01)return;if(this.value.hasFilteredDelta()){const s=this.value.computeDelta(t);this.value.filteredDelta*s<0&&this.value.reset()}}this.time.update(s),this.value.update(t)}}reset(){this.value.reset(),this.time.reset()}evaluateMomentum(){if(!this.enabled||!this.value.hasFilteredDelta()||!this.time.hasFilteredDelta())return null;let t=this.value.filteredDelta/this.time.filteredDelta;return t=n(t,-this._maxVelocity,this._maxVelocity),Math.abs(t)<this._minimumInitialVelocity?null:this.createMomentum(t,this._stopVelocity,this._friction)}createMomentum(t,s,i){return new ct(t,s,i)}}class pt extends ft{constructor(t=3,s=.01,i=.95,h=12){super(t,s,i,h)}add(t,s){const i=this.value.lastValue;if(null!=i){let s=t-i;for(;s>Math.PI;)s-=2*Math.PI;for(;s<-Math.PI;)s+=2*Math.PI;t=i+s}super.add(t,s)}}class gt extends ct{constructor(t,s,i){super(t,s,i)}value(t){const s=super.value(t);return Math.exp(s)}valueDelta(t,s){const i=super.value(t),h=super.value(t+s)-i;return Math.exp(h)}}class wt extends ft{constructor(t=2.5,s=.01,i=.95,h=12){super(t,s,i,h)}add(t,s){super.add(Math.log(t),s)}createMomentum(t,s,i){return new gt(t,s,i)}}let vt=class extends e{constructor(t){super(t),this._animationTime=0,this._momentumFinished=!1,this._previousAngle=0,this._previousRadius=0,this._previousCenter=null,this._rotationMomentumEstimator=new pt(.6,.15,.95),this._rotationDirection=1,this._startAngle=0,this._startRadius=0,this._updateTimestamp=null,this._zoomDirection=1,this._zoomMomentumEstimator=new wt,this._zoomOnly=null,this.zoomMomentum=null,this.rotateMomentum=null,this.viewpoint=new p({targetGeometry:new g,scale:0,rotation:0}),this.addHandles(w((()=>this._momentumFinished),(()=>this.navigation.stop())))}begin(t,s){this.navigation.begin(),this._rotationMomentumEstimator.reset(),this._zoomMomentumEstimator.reset(),this._zoomOnly=null,this._previousAngle=this._startAngle=s.angle,this._previousRadius=this._startRadius=s.radius,this._previousCenter=s.center,this._updateTimestamp=null,t.constraints.rotationEnabled&&this.addToRotateEstimator(0,s.timestamp),this.addToZoomEstimator(s,1)}update(t,s){null===this._updateTimestamp&&(this._updateTimestamp=s.timestamp);const i=s.angle,h=s.radius,n=s.center,e=Math.abs(180*(i-this._startAngle)/Math.PI),o=Math.abs(h-this._startRadius),a=this._startRadius/h;if(this._previousRadius&&this._previousCenter){const r=h/this._previousRadius;let c=180*(i-this._previousAngle)/Math.PI;this._rotationDirection=c>=0?1:-1,this._zoomDirection=r>=1?1:-1,t.constraints.rotationEnabled?(null===this._zoomOnly&&s.timestamp-this._updateTimestamp>200&&(this._zoomOnly=o-e>0),null===this._zoomOnly||this._zoomOnly?c=0:this.addToRotateEstimator(i-this._startAngle,s.timestamp)):c=0,this.addToZoomEstimator(s,a),this.navigation.setViewpoint([n.x,n.y],1/r,c,[this._previousCenter.x-n.x,n.y-this._previousCenter.y])}this._previousAngle=i,this._previousRadius=h,this._previousCenter=n}end(t){this.rotateMomentum=this._rotationMomentumEstimator.evaluateMomentum(),this.zoomMomentum=this._zoomMomentumEstimator.evaluateMomentum(),this._animationTime=0,(this.rotateMomentum||this.zoomMomentum)&&this.onAnimationUpdate(t),this.navigation.end()}addToRotateEstimator(t,s){this._rotationMomentumEstimator.add(t,.001*s)}addToZoomEstimator(t,s){this._zoomMomentumEstimator.add(s,.001*t.timestamp)}canZoomIn(t){const s=t.scale,i=t.constraints.effectiveMaxScale;return 0===i||s>i}canZoomOut(t){const s=t.scale,i=t.constraints.effectiveMinScale;return 0===i||s<i}onAnimationUpdate(t){this.navigation.animationManager?.animateContinous(t.viewpoint,((s,i)=>{const h=!this.canZoomIn(t)&&this._zoomDirection>1||!this.canZoomOut(t)&&this._zoomDirection<1,n=!this.rotateMomentum||this.rotateMomentum.isFinished(this._animationTime),e=h||!this.zoomMomentum||this.zoomMomentum.isFinished(this._animationTime),o=.001*i;if(this._momentumFinished=n&&e,!this._momentumFinished){const i=this.rotateMomentum?Math.abs(this.rotateMomentum.valueDelta(this._animationTime,o))*this._rotationDirection*180/Math.PI:0;let h=this.zoomMomentum?Math.abs(this.zoomMomentum.valueDelta(this._animationTime,o)):1;const n=k(),e=k();if(this._previousCenter){b(n,this._previousCenter.x,this._previousCenter.y),y(e,t.size,t.padding),x(n,n,e);const{constraints:o,scale:a}=t,r=a*h;h<1&&!o.canZoomInTo(r)?(h=a/o.effectiveMaxScale,this.zoomMomentum=null,this.rotateMomentum=null):h>1&&!o.canZoomOutTo(r)&&(h=a/o.effectiveMinScale,this.zoomMomentum=null,this.rotateMomentum=null),S(s,t.viewpoint,h,i,n,t.size),t.constraints.constrainByGeometry(s)}}this._animationTime+=o}))}stopMomentumNavigation(){(this.rotateMomentum||this.zoomMomentum)&&(this.rotateMomentum&&(this._rotationMomentumEstimator.reset(),this.rotateMomentum=null),this.zoomMomentum&&(this._zoomMomentumEstimator.reset(),this.zoomMomentum=null),this.navigation.stop())}};o([a()],vt.prototype,"_momentumFinished",void 0),o([a()],vt.prototype,"viewpoint",void 0),o([a()],vt.prototype,"navigation",void 0),vt=o([r("esri.views.2d.navigation.actions.Pinch")],vt);const Mt=vt;const _t=k(),bt=k();let yt=class extends e{constructor(t){super(t),this._previousCenter=k(),this.viewpoint=new p({targetGeometry:new g,scale:0,rotation:0})}begin(t,s){this.navigation.begin(),b(this._previousCenter,s.center.x,s.center.y)}update(t,s){const{state:{size:i,padding:h}}=t;b(_t,s.center.x,s.center.y),C(bt,i,h),t.viewpoint=$(this.viewpoint,t.state.paddedViewState.viewpoint,L(bt,this._previousCenter,_t)),z(this._previousCenter,_t)}end(){this.navigation.end()}};o([a()],yt.prototype,"viewpoint",void 0),o([a()],yt.prototype,"navigation",void 0),yt=o([r("esri.views.2d.actions.Rotate")],yt);const xt=yt;const St=10,kt=1,Ct=new p({targetGeometry:new g}),$t=[0,0],Lt=250;let zt=class extends e{constructor(t){super(t),this._endTimer=null,this._lastEventTimestamp=null,this.animationManager=null,this.interacting=!1}initialize(){this.pan=new mt({navigation:this}),this.rotate=new xt({navigation:this}),this.pinch=new Mt({navigation:this}),this.zoomBox=new at({view:this.view,navigation:this})}destroy(){this.pan=B(this.pan),this.rotate=B(this.rotate),this.pinch=B(this.pinch),this.zoomBox=B(this.zoomBox),this.animationManager=null}begin(){this.stop(),this._set("interacting",!0)}end(){this._lastEventTimestamp=performance.now(),this._startTimer(Lt)}async zoom(t,s=this._getDefaultAnchor()){if(this.begin(),this.view.constraints.snapToZoom&&this.view.constraints.effectiveLODs)return t<1?this.zoomIn(s):this.zoomOut(s);this.setViewpoint(s,t,0,[0,0])}async zoomIn(t){const s=this.view,i=s.constraints.snapToNextScale(s.scale);return this._zoomToScale(i,t)}async zoomOut(t){const s=this.view,i=s.constraints.snapToPreviousScale(s.scale);return this._zoomToScale(i,t)}setViewpoint(t,s,i,h){this.begin(),this.view.stateManager.state.viewpoint=this._scaleRotateTranslateViewpoint(this.view.viewpoint,t,s,i,h),this.end()}setViewpointImmediate(t,s=0,i=[0,0],h=this._getDefaultAnchor()){this.view.stateManager.state.viewpoint=this._scaleRotateTranslateViewpoint(this.view.viewpoint,h,t,s,i)}continousRotateClockwise(){const t=this.view.viewpoint;this.animationManager?.animateContinous(t,(t=>{$(t,t,-kt)}))}continousRotateCounterclockwise(){const t=this.view.viewpoint;this.animationManager?.animateContinous(t,(t=>{$(t,t,kt)}))}resetRotation(){this.view.constraints.rotationEnabled&&(this.view.rotation=0)}continousPanLeft(){this._continuousPan([-St,0])}continousPanRight(){this._continuousPan([St,0])}continousPanUp(){this._continuousPan([0,St])}continousPanDown(){this._continuousPan([0,-St])}continuousPanVector({x:t,y:s}){this._continuousPan([t*St,s*St])}stop(){this.pan.stopMomentumNavigation(),this.animationManager?.stop(),this.end(),null!==this._endTimer&&(clearTimeout(this._endTimer),this._endTimer=null,this._set("interacting",!1))}_continuousPan(t){const s=this.view.viewpoint;this.animationManager?.animateContinous(s,(s=>{v(s,s,t),this.view.constraints.constrainByGeometry(s)}))}_startTimer(t){return null!==this._endTimer||(this._endTimer=setTimeout((()=>{this._endTimer=null;const t=performance.now()-(this._lastEventTimestamp??0);t<Lt?this._endTimer=this._startTimer(t):this._set("interacting",!1)}),t)),this._endTimer}_getDefaultAnchor(){const{size:t,padding:{left:s,right:i,top:h,bottom:n}}=this.view;return $t[0]=.5*(t[0]-i+s),$t[1]=.5*(t[1]-n+h),$t}async _zoomToScale(t,s=this._getDefaultAnchor()){const{view:i}=this,{constraints:h,scale:n,viewpoint:e,size:o,padding:a}=i,r=h.canZoomInTo(t),c=h.canZoomOutTo(t);if(!(t<n&&!r||t>n&&!c))return P(Ct,e,t/n,0,s,o,a),h.constrainByGeometry(Ct),i.goTo(Ct,{animate:!0,pickClosestTarget:!1})}_scaleRotateTranslateViewpoint(t,s,i,h,n){const{view:e}=this,{size:o,padding:a,constraints:r,scale:c,viewpoint:l}=e,u=c*i,d=r.canZoomInTo(u),m=r.canZoomOutTo(u);return(i<1&&!d||i>1&&!m)&&(i=1),v(l,l,n),P(t,l,i,h,s,o,a),r.constrainByGeometry(t)}};o([a()],zt.prototype,"animationManager",void 0),o([a({type:Boolean,readOnly:!0})],zt.prototype,"interacting",void 0),o([a()],zt.prototype,"pan",void 0),o([a()],zt.prototype,"pinch",void 0),o([a()],zt.prototype,"rotate",void 0),o([a()],zt.prototype,"view",void 0),o([a()],zt.prototype,"zoomBox",void 0),zt=o([r("esri.views.2d.navigation.MapViewNavigation")],zt);const Bt=zt;const Pt={shaders:{vertexShader:t("magnifier/magnifier.vert"),fragmentShader:t("magnifier/magnifier.frag")},attributes:new Map([["a_pos",0]])};function Rt(t){return V(t,Pt)}export{N as a,Rt as b,Pt as c,it as d,j as e,Bt as f,Z as n,q as r,I as t};
//# sourceMappingURL=p-b3d3ca01.js.map