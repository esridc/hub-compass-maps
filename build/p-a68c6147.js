import{r as t,p as e,oq as n,b7 as s,hx as r,q as o,_ as i,pq as a,qB as l,gZ as c,Y as u,fx as h,bZ as f,n as p,a7 as m,s as d,ah as w,ne as y,e0 as v,aZ as g,dv as x,qC as b,qD as M,qE as j,jk as T,a1 as A,lM as S,lN as F,$ as R,ao as E,qF as L,pL as O,qG as D,J as N,E as C,lT as U,af as q,a3 as I,a0 as P,qH as H,qI as B,qJ as _,l3 as $,dc as z,oO as W,az as k,bE as G,f2 as V,aW as Z,qK as J,nR as K,mI as Y,m0 as Q,qL as X,m1 as tt,qM as et,qN as nt,lS as st,nd as rt,m2 as ot,eo as it,t as at,j9 as lt,i$ as ct,w as ut,k8 as ht,c1 as ft,qO as pt,qP as mt}from"./p-aad64c9f.js";import{N as dt,z as wt,w as yt,k as vt,j as gt,d as xt}from"./p-e11049fd.js";import{r as bt,n as Mt,p as jt}from"./p-fefc46e8.js";import{b as Tt,a as At}from"./p-17b3a90f.js";import{a as St,s as Ft,g as Rt,u as Et}from"./p-5d8d2e95.js";import{e as Lt}from"./p-c0b174ee.js";import{t as Ot}from"./p-5b459e36.js";import{v as Dt,O as Nt,M as Ct}from"./p-a040372a.js";import{e as Ut}from"./p-f9e31f43.js";import{c as qt}from"./p-66c1870a.js";import{F as It,B as Pt,O as Ht,n as Bt,k as _t,g as $t,E as zt,w as Wt,h as kt,R as Gt,G as Vt}from"./p-25b70cc1.js";import{e as Zt}from"./p-88dd7081.js";import{a as Jt}from"./p-1826fadd.js";import{C as Kt}from"./p-e51694e6.js";import{e as Yt,i as Qt}from"./p-dcc79702.js";import{o as Xt,h as te,m as ee}from"./p-cde3f633.js";import{e as ne}from"./p-79c28fb7.js";import{b as se}from"./p-dfaba342.js";import{e as re,r as oe}from"./p-93091a88.js";var ie;const ae=new WeakMap;let le=0,ce=ie=class extends i{constructor(t){super(t),this.wrap="repeat"}get url(){return this._get("url")||null}set url(t){this._set("url",t),t&&this._set("data",null)}get data(){return this._get("data")||null}set data(t){this._set("data",t),t&&this._set("url",null)}writeData(t,e,n,s){if(t instanceof HTMLImageElement){const r={type:"image-element",src:a(t.src,s),crossOrigin:t.crossOrigin};e[n]=r}else if(t instanceof HTMLCanvasElement){const s={type:"canvas-element",imageData:ue(t.getContext("2d").getImageData(0,0,t.width,t.height))};e[n]=s}else if(t instanceof HTMLVideoElement){const r={type:"video-element",src:a(t.src,s),autoplay:t.autoplay,loop:t.loop,muted:t.muted,crossOrigin:t.crossOrigin,preload:t.preload};e[n]=r}else if(t instanceof ImageData){const s={type:"image-data",imageData:ue(t)};e[n]=s}}readData(t){switch(t.type){case"image-element":{const e=new Image;return e.src=t.src,e.crossOrigin=t.crossOrigin,e}case"canvas-element":{const e=he(t.imageData),n=document.createElement("canvas");return n.width=e.width,n.height=e.height,n.getContext("2d").putImageData(e,0,0),n}case"image-data":return he(t.imageData);case"video-element":{const e=document.createElement("video");return e.src=t.src,e.crossOrigin=t.crossOrigin,e.autoplay=t.autoplay,e.loop=t.loop,e.muted=t.muted,e.preload=t.preload,e}default:return}}get transparent(){const{data:t,url:e}=this;return t instanceof HTMLCanvasElement?fe(t.getContext("2d").getImageData(0,0,t.width,t.height)):t instanceof ImageData?fe(t):!(!e?.toLowerCase().endsWith(".png")&&!e?.toLocaleLowerCase().startsWith("data:image/png;"))}set transparent(t){this._overrideIfSome("transparent",t)}get contentHash(){const t="string"==typeof this.wrap?this.wrap:"object"==typeof this.wrap?`${this.wrap.horizontal}/${this.wrap.vertical}`:"",e=(e="")=>`d:${e},t:${this.transparent},w:${t}`;return null!=this.url?e(this.url):null!=this.data?this.data instanceof HTMLImageElement||this.data instanceof HTMLVideoElement?e(this.data.src):(ae.has(this.data)||ae.set(this.data,++le),e(ae.get(this.data))):e()}get memoryUsage(){let t=0;if(t+=null!=this.url?this.url.length:0,null!=this.data){const e=this.data;"data"in e?t+=e.data.byteLength:e instanceof HTMLImageElement?t+=e.naturalWidth*e.naturalHeight*3:e instanceof HTMLCanvasElement&&(t+=e.width*e.height*3)}return t}clone(){const t={url:this.url,data:this.data,wrap:this._cloneWrap()};return new ie(t)}cloneWithDeduplication(t){const e=t.get(this);if(e)return e;const n=this.clone();return t.set(this,n),n}_cloneWrap(){return"string"==typeof this.wrap?this.wrap:{horizontal:this.wrap.horizontal,vertical:this.wrap.vertical}}static from(t){return"string"==typeof t?new ie({url:t}):t instanceof HTMLImageElement||t instanceof HTMLCanvasElement||t instanceof ImageData||t instanceof HTMLVideoElement?new ie({data:t}):c(ie,t)}};function ue(t){let e="";for(let n=0;n<t.data.length;n++)e+=String.fromCharCode(t.data[n]);return{data:btoa(e),width:t.width,height:t.height}}function he(t){const e=atob(t.data),n=new Uint8ClampedArray(e.length);for(let t=0;t<e.length;t++)n[t]=e.charCodeAt(t);return l(n,t.width,t.height)}function fe(t){for(let e=3;e<t.data.length;e+=4)if(255!==t.data[e])return!0;return!1}t([e({type:String,json:{write:n}})],ce.prototype,"url",null),t([e({json:{write:{overridePolicy(){return{enabled:!this.url}}}}}),e()],ce.prototype,"data",null),t([s("data")],ce.prototype,"writeData",null),t([r("data")],ce.prototype,"readData",null),t([e({type:Boolean,json:{write:{overridePolicy(){return{enabled:this._isOverridden("transparent")}}}}})],ce.prototype,"transparent",null),t([e({json:{write:!0}})],ce.prototype,"wrap",void 0),t([e({readOnly:!0})],ce.prototype,"contentHash",null),ce=ie=t([o("esri.geometry.support.MeshTexture")],ce);const pe=ce;let me=class extends(u(i)){constructor(t){super(t),this.offset=[0,0],this.rotation=0,this.scale=[1,1]}};t([e({type:[Number],nonNullable:!0,json:{write:!0}})],me.prototype,"offset",void 0),t([e({type:Number,nonNullable:!0,json:{write:!0}})],me.prototype,"rotation",void 0),t([e({type:[Number],nonNullable:!0,json:{write:!0}})],me.prototype,"scale",void 0),me=t([o("esri.geometry.support.MeshTextureTransform")],me);const de=me;var we;let ye=we=class extends i{constructor(t){super(t),this.color=null,this.colorTexture=null,this.colorTextureTransform=null,this.normalTexture=void 0,this.normalTextureTransform=void 0,this.alphaMode="auto",this.alphaCutoff=.5,this.doubleSided=!0}clone(){return this.cloneWithDeduplication(null,new Map)}cloneWithDeduplication(t,e){const n=null!=t?t.get(this):null;if(n)return n;const s=new we(this.clonePropertiesWithDeduplication(e));return null!=t&&t.set(this,s),s}clonePropertiesWithDeduplication(t){return{color:null!=this.color?this.color.clone():null,colorTexture:this.colorTexture?.cloneWithDeduplication(t),normalTexture:this.normalTexture?.cloneWithDeduplication(t),alphaMode:this.alphaMode,alphaCutoff:this.alphaCutoff,doubleSided:this.doubleSided,colorTextureTransform:this.colorTextureTransform?.clone(),normalTextureTransform:this.normalTextureTransform?.clone()}}get memoryUsage(){return this.getMemoryUsage()}getMemoryUsage(){let t=0;return t+=null!=this.color?16:0,null!=this.colorTexture&&(t+=this.colorTexture.memoryUsage),t+=null!=this.colorTextureTransform?20:0,null!=this.normalTexture&&(t+=this.normalTexture.memoryUsage),t+=null!=this.normalTextureTransform?20:0,t}};t([e({type:h,json:{write:!0}})],ye.prototype,"color",void 0),t([e({type:pe,json:{write:!0}})],ye.prototype,"colorTexture",void 0),t([e({type:de,json:{write:!0}})],ye.prototype,"colorTextureTransform",void 0),t([e({type:pe,json:{write:!0}})],ye.prototype,"normalTexture",void 0),t([e({type:de,json:{write:!0}})],ye.prototype,"normalTextureTransform",void 0),t([e({nonNullable:!0,json:{write:!0}})],ye.prototype,"alphaMode",void 0),t([e({nonNullable:!0,json:{write:!0}})],ye.prototype,"alphaCutoff",void 0),t([e({nonNullable:!0,json:{write:!0}})],ye.prototype,"doubleSided",void 0),ye=we=t([o("esri.geometry.support.MeshMaterial")],ye);const ve=ye;var ge;let xe=ge=class extends ve{constructor(t){super(t),this.emissiveColor=null,this.emissiveTexture=null,this.emissiveTextureTransform=void 0,this.occlusionTexture=null,this.occlusionTextureTransform=void 0,this.metallic=1,this.roughness=1,this.metallicRoughnessTexture=null,this.metallicRoughnessTextureTransform=void 0}clone(){return this.cloneWithDeduplication(null,new Map)}cloneWithDeduplication(t,e){const n=null!=t?t.get(this):null;if(n)return n;const s=new ge(this.clonePropertiesWithDeduplication(e));return null!=t&&t.set(this,s),s}getMemoryUsage(){let t=super.getMemoryUsage();return t+=null!=this.emissiveColor?16:0,null!=this.emissiveTexture&&(t+=this.emissiveTexture.memoryUsage),t+=null!=this.emissiveTextureTransform?20:0,null!=this.occlusionTexture&&(t+=this.occlusionTexture.memoryUsage),t+=null!=this.occlusionTextureTransform?20:0,null!=this.metallicRoughnessTexture&&(t+=this.metallicRoughnessTexture.memoryUsage),t+=null!=this.metallicRoughnessTextureTransform?20:0,t}clonePropertiesWithDeduplication(t){return{...super.clonePropertiesWithDeduplication(t),emissiveColor:this.emissiveColor?.clone(),emissiveTexture:this.emissiveTexture?.cloneWithDeduplication(t),emissiveTextureTransform:this.emissiveTextureTransform?.clone(),occlusionTexture:this.occlusionTexture?.cloneWithDeduplication(t),occlusionTextureTransform:this.occlusionTextureTransform?.clone(),metallic:this.metallic,roughness:this.roughness,metallicRoughnessTexture:this.metallicRoughnessTexture?.cloneWithDeduplication(t),metallicRoughnessTextureTransform:this.metallicRoughnessTextureTransform?.clone()}}};t([e({type:h,json:{write:!0}})],xe.prototype,"emissiveColor",void 0),t([e({type:pe,json:{write:!0}})],xe.prototype,"emissiveTexture",void 0),t([e({type:de,json:{write:!0}})],xe.prototype,"emissiveTextureTransform",void 0),t([e({type:pe,json:{write:!0}})],xe.prototype,"occlusionTexture",void 0),t([e({type:de,json:{write:!0}})],xe.prototype,"occlusionTextureTransform",void 0),t([e({type:Number,nonNullable:!0,json:{write:!0},range:{min:0,max:1}})],xe.prototype,"metallic",void 0),t([e({type:Number,nonNullable:!0,json:{write:!0},range:{min:0,max:1}})],xe.prototype,"roughness",void 0),t([e({type:pe,json:{write:!0}})],xe.prototype,"metallicRoughnessTexture",void 0),t([e({type:de,json:{write:!0}})],xe.prototype,"metallicRoughnessTextureTransform",void 0),xe=ge=t([o("esri.geometry.support.MeshMaterialMetallicRoughness")],xe);const be=xe;var Me;let je=Me=class extends i{static from(t){return c(Me,t)}constructor(t){super(t),this.faces=null,this.material=null,this.name=void 0,this.shading="source",this.trustSourceNormals=!1}castFaces(t){return Mt(t,Uint32Array,[Uint16Array],{loggerTag:".faces=",stride:3},p.getLogger(this))}castMaterial(t){return c(t&&"object"==typeof t&&("metallic"in t||"roughness"in t||"metallicRoughnessTexture"in t)?be:ve,t)}clone(){return new Me({faces:m(this.faces),shading:this.shading,material:m(this.material),trustSourceNormals:this.trustSourceNormals,name:this.name})}cloneWithDeduplication(t,e){const n={faces:m(this.faces),shading:this.shading,material:this.material?this.material.cloneWithDeduplication(t,e):null,trustSourceNormals:this.trustSourceNormals,name:this.name};return new Me(n)}get memoryUsage(){let t=0;return null!=this.faces&&(t+=this.faces.byteLength),null!=this.material&&(t+=this.material.memoryUsage),t}};t([e({json:{write:bt}})],je.prototype,"faces",void 0),t([f("faces")],je.prototype,"castFaces",null),t([e({type:ve,json:{write:!0}})],je.prototype,"material",void 0),t([f("material")],je.prototype,"castMaterial",null),t([e({json:{write:!0}})],je.prototype,"name",void 0),t([e({type:String,json:{write:!0}})],je.prototype,"shading",void 0),t([e({type:Boolean})],je.prototype,"trustSourceNormals",void 0),je=Me=t([o("esri.geometry.support.MeshComponent")],je);const Te=je;const Ae="Mesh must be loaded before applying operations",Se="Provided component is not part of the list of components",Fe="Expected polygon to be a Polygon instance",Re="Expected location to be a Point instance";class Ee extends d{constructor(){super("invalid-input:location",Re)}}function Le(t,e,n){const s=Oe(De,t,e,n)?Nt(De):[0,0,1];return Math.abs(s[2])>Math.cos(w(80))?y.Z:Math.abs(s[1])>Math.abs(s[0])?y.Y:y.X}function Oe(t,e,n,s){const r=(t=>!Array.isArray(t[0]))(e)?(t,n)=>e[3*t+n]:(t,n)=>e[t][n],o=s?v(s)/g(s):1;return Dt(t,((t,e)=>x(t,r(e,0)*o,r(e,1)*o,r(e,2))),n)}const De=Ct();function Ne(t){const e=Ue(t.rings,t.hasZ,Pe.CCW_IS_HOLE,t.spatialReference),n=new Array;let s=0,r=0;for(const t of e.polygons){const o=t.count,i=t.index,a=M(e.position,3*i,3*o),l=t.holeIndices.map((t=>t-i)),c=Ot(Lt(a,l,3));n.push({position:a,faces:c}),s+=a.length,r+=c.length}const o=Ce(n,s,r),i=Array.isArray(o.position)?Ut(o.position,3,{originalIndices:o.faces}):Ut(o.position.buffer,6,{originalIndices:o.faces});return o.position=b(new Float64Array(i.buffer)),o.faces=i.indices,o}function Ce(t,e,n){if(1===t.length)return t[0];const s=j(e),r=new Array(n);let o=0,i=0,a=0;for(const e of t){for(let t=0;t<e.position.length;t++)s[o++]=e.position[t];for(const t of e.faces)r[i++]=t+a;a=o/3}return{position:s,faces:Ot(r)}}function Ue(t,e,n,s){const r=t.length,o=new Array(r),i=new Array(r),a=new Array(r);let l=0;for(let e=0;e<r;++e)l+=t[e].length;let c=0,u=0,h=0;const f=j(3*l);let p=0;for(let l=r-1;l>=0;l--){const m=t[l],d=n===Pe.CCW_IS_HOLE&&Ie(m,e,s);if(d&&1!==r)o[c++]=m;else{let t=m.length;for(let e=0;e<c;++e)t+=o[e].length;const n={index:p,pathLengths:new Array(c+1),count:t,holeIndices:new Array(c)};n.pathLengths[0]=m.length,m.length>0&&(a[h++]={index:p,count:m.length}),p=d?qe(m,m.length-1,-1,f,p,m.length,e):qe(m,0,1,f,p,m.length,e);for(let t=0;t<c;++t){const s=o[t];n.holeIndices[t]=p,n.pathLengths[t+1]=s.length,s.length>0&&(a[h++]={index:p,count:s.length}),p=qe(s,0,1,f,p,s.length,e)}c=0,n.count>0&&(i[u++]=n)}}for(let t=0;t<c;++t){const n=o[t];n.length>0&&(a[h++]={index:p,count:n.length}),p=qe(n,0,1,f,p,n.length,e)}return i.length=u,a.length=h,{position:f,polygons:i,outlines:a}}function qe(t,e,n,s,r,o,i){r*=3;for(let a=0;a<o;++a){const o=t[e];s[r++]=o[0],s[r++]=o[1],s[r++]=i&&o[2]?o[2]:0,e+=n}return r/3}function Ie(t,e,n){if(!e)return!T(t);const s=t.length-1;switch(Le(t,s,n)){case y.X:return!T(t,y.Y,y.Z);case y.Y:return!T(t,y.X,y.Z);case y.Z:return!T(t,y.X,y.Y)}}var Pe;!function(t){t[t.NONE=0]="NONE",t[t.CCW_IS_HOLE=1]="CCW_IS_HOLE"}(Pe||(Pe={}));function He(t,e,n,s){if(void 0!==s){A(t(),"option: geographic",{replacement:"Use mesh `vertexSpace` and spatial reference to control how operations are performed instead.",version:"4.30",warnOnce:!0});const r="local"===e.type;if(!St(e)||s===r)return n.isGeographic||n.isWebMercator&&s;t().warnOnce(`Specifying the 'geographic' parameter (${s}) for a Mesh vertex space of type "${e.type}" is not supported. This parameter will be ignored.`)}switch(e.type){case"georeferenced":return n.isGeographic;case"local":return n.isGeographic||n.isWebMercator}}const Be=()=>p.getLogger("esri.geometry.support.meshUtils.centerAt");function _e(t,e,n){if(!t.vertexAttributes?.position)return;const{vertexSpace:s}=t,r=n?.origin??t.origin,o=He(Be,s,r.spatialReference,n?.geographic);St(s)?$e(t,e,r):o?ze(t,e,r):We(t,e,r)}function $e(t,e,n){const{vertexSpace:s}=t;if(!St(s))return;const r=Ve,o=Ge;if(!qt(e,o,t.spatialReference))return void It(Be(),e.spatialReference,t.spatialReference,Ht);if(!qt(n,r,t.spatialReference)){const e=t.origin;return r[0]=e.x,r[1]=e.y,r[2]=e.z,void It(Be(),n.spatialReference,t.spatialReference,Ht)}const i=S(Ze,o,r);s.origin=F(R(),s.origin,i)}function ze(t,e,n){const s=E(n.x,n.y,n.z??0),r=Pt(t,new Tt({origin:s}));if(!r)return;const o=E(e.x,e.y,e.z??0),i=Pt({vertexAttributes:r,spatialReference:t.spatialReference,vertexSpace:new Tt({origin:o})},At.absolute);if(!i)return;const{position:a,normal:l,tangent:c}=i;t.vertexAttributes.position=a,t.vertexAttributes.normal=l,t.vertexAttributes.tangent=c,t.vertexAttributesChanged()}function We(t,e,n){const s=Ve,r=Ge;if(qt(e,r,t.spatialReference)){if(!qt(n,s,t.spatialReference)){const e=t.origin;return s[0]=e.x,s[1]=e.y,s[2]=e.z,void It(Be(),n.spatialReference,t.spatialReference,Ht)}ke(t.vertexAttributes.position,r,s),t.vertexAttributesChanged()}else It(Be(),e.spatialReference,t.spatialReference,Ht)}function ke(t,e,n){if(t)for(let s=0;s<t.length;s+=3)for(let r=0;r<3;r++)t[s+r]+=e[r]-n[r]}const Ge=R(),Ve=R(),Ze=R();function Je(t){const{spatialReference:e,vertexSpace:n,untransformedBounds:s}=t,r=L(s,Ye);if(St(n)&&t.transform&&Yt(r,r,t.transform.localMatrix),"georeferenced"===n.type){const t=n.origin;return t&&Qt(r,r,t),O(D(r),e)}const o=Jt(e),i=n.origin;if(!N(o,e)){const[t,n,s]=i;return new C({xmin:t,ymin:n,zmin:s,xmax:t,ymax:n,zmax:s,spatialReference:e})}return Kt(e,i,Ke,o),Yt(r,r,Ke),U(r,o,0,r,e,0),O(D(r),e)}const Ke=Zt(),Ye=j(24);async function Qe(t,e,n){const{source:s}=e,{loadGLTFMesh:r}=await q(import("./p-73eb21db.js"),n),o=await tn(s,n);I(n);const i=r(new P({x:0,y:0,z:0,spatialReference:t.spatialReference}),o.url,{resolveFile:Xe(o),signal:n?.signal,expectedType:o.type,unitConversionDisabled:e.unitConversionDisabled});i.then((()=>o.dispose()),(()=>o.dispose()));const{vertexAttributes:a,components:l}=await i;t.vertexAttributes=a,t.components=l}function Xe(t){const e=B(t.url);return n=>{const s=H(n,e,e),r=s?s.replace(/^ *\.\//,""):null;return(r?t.files.get(r):null)??n}}async function tn(t,e){if(Array.isArray(t)){if(!t.length)throw new d("mesh-load-external:missing-assets","There must be at least one file to load");return t[0]instanceof File?sn(t):rn(t,e)}return nn(t)}async function en(t,e){const{parts:n,assetMimeType:s,assetName:r}=t;if(1===n.length)return new fn(n[0].partUrl);const o=await t.toBlob(e);return I(e),fn.fromBlob(o,pn(r,s))}function nn(t){return fn.fromBlob(t,pn(t.name,t.type))}function sn(t){return hn(t.map((t=>({name:t.name,mimeType:t.type,source:nn(t)}))))}async function rn(t,e){const n=await _(t.map((async t=>{const n=await en(t);return I(e),{name:t.assetName,mimeType:t.assetMimeType,source:n}})));if($(e))throw n.forEach((t=>t.source.dispose())),z();return hn(n)}const on=/^model\/gltf\+json$/,an=/^model\/gltf-binary$/,ln=/\.gltf$/i,cn=/\.glb$/i;function un({mimeType:t,source:e,name:n}){return on.test(t)||ln.test(n)?{url:e.url,type:"gltf"}:an.test(t)||cn.test(n)?{url:e.url,type:"glb"}:null}function hn(t){const e=new Map;let n=null,s=null;for(const r of t){const{source:t,name:o}=r;n??=un(r),"ESRI3DO_NORM.glb"===o&&(s=un(r)),e.set(o,t.url),t.files.forEach(((t,n)=>e.set(n,t)))}const r=s??n;if(null==r)throw new d("mesh-load-external:missing-files","Missing files to load external mesh source");return new fn(r.url,(()=>t.forEach((({source:t})=>t.dispose()))),e,r.type)}class fn{constructor(t,e=(()=>{}),n=new Map,s){this.url=t,this.dispose=e,this.files=n,this.type=s}static fromBlob(t,e){const n=URL.createObjectURL(t);return new fn(n,(()=>URL.revokeObjectURL(n)),void 0,e)}}function pn(t,e){return on.test(e)||ln.test(t)?"gltf":an.test(e)||ln.test(t)?"glb":void 0}let mn=class extends W{constructor(t){super(t),this.externalSources=new k,this._explicitDisplaySource=null,this.georeferenced=!1,this.addHandles(G((()=>this.externalSources),"after-remove",(({item:t})=>{t===this._explicitDisplaySource&&(this._explicitDisplaySource=null)}),{sync:!0,onListenerRemove:()=>this._explicitDisplaySource=null}))}get displaySource(){return this._explicitDisplaySource??this._implicitDisplaySource}set displaySource(t){if(null!=t&&!Xt(t))throw new Error("Cannot use this source for display: it is not in a supported format.");this._explicitDisplaySource=t,t&&this.externalSources.every((e=>!te(e,t)))&&this.externalSources.add(t)}clearSources(){this.externalSources.removeAll()}getExternalSourcesOnService(t){return this.externalSources.items.filter((e=>ee(e,t)))}get _implicitDisplaySource(){return this.externalSources.find(Xt)}};t([e()],mn.prototype,"externalSources",void 0),t([e()],mn.prototype,"displaySource",null),t([e()],mn.prototype,"_implicitDisplaySource",null),t([e()],mn.prototype,"_explicitDisplaySource",void 0),t([e()],mn.prototype,"georeferenced",void 0),mn=t([o("esri.geometry.support.meshUtils.Metadata")],mn);function dn(){const{faceDescriptions:t,faceVertexOffsets:e,uvScales:n}=En,s=4*t.length,r=new Float64Array(3*s),o=new Float32Array(3*s),i=new Float32Array(2*s),a=new Uint32Array(2*t.length*3);let l=0,c=0,u=0,h=0;for(let s=0;s<t.length;s++){const f=t[s],p=l/3;for(const t of e)a[h++]=p+t;const m=f.corners;for(let t=0;t<4;t++){const e=m[t];let s=0;i[u++]=.25*n[t][0]+f.uvOrigin[0],i[u++]=f.uvOrigin[1]-.25*n[t][1];for(let t=0;t<3;t++)0!==f.axis[t]?(r[l++]=.5*f.axis[t],o[c++]=f.axis[t]):(r[l++]=.5*e[s++],o[c++]=0)}}return{position:r,normal:o,uv:i,faces:a}}function wn(t,e){const n=t.components[0],s=n.faces,r=Ln[e],o=6*r,i=new Array(6),a=new Array(s.length-6);let l=0,c=0;for(let t=0;t<s.length;t++)t>=o&&t<o+6?i[l++]=s[t]:a[c++]=s[t];if(null!=t.vertexAttributes.uv){const e=new Float32Array(t.vertexAttributes.uv),n=4*r*2,s=[0,1,1,1,1,0,0,0];for(let t=0;t<s.length;t++)e[n+t]=s[t];t.vertexAttributes.uv=e}return t.components=[new Te({faces:i,material:n.material}),new Te({faces:a})],t}function yn(t=0){const e=Math.round(8*2**t),n=2*e,s=(e-1)*(n+1)+2*n,r=new Float64Array(3*s),o=new Float32Array(3*s),i=new Float32Array(2*s),a=new Uint32Array(3*((e-1)*n*2));let l=0,c=0,u=0,h=0;for(let t=0;t<=e;t++){const s=t/e*Math.PI+.5*Math.PI,f=Math.cos(s),p=Math.sin(s);On[2]=p;const m=0===t||t===e,d=m?n-1:n;for(let s=0;s<=d;s++){const p=s/d*2*Math.PI;On[0]=-Math.sin(p)*f,On[1]=Math.cos(p)*f;for(let t=0;t<3;t++)r[l]=.5*On[t],o[l]=On[t],++l;i[c++]=(s+(m?.5:0))/n,i[c++]=t/e,0!==t&&s!==n&&(t!==e&&(a[u++]=h,a[u++]=h+1,a[u++]=h-n),1!==t&&(a[u++]=h,a[u++]=h-n,a[u++]=h-n-1)),h++}}return{position:r,normal:o,uv:i,faces:a}}function vn(t=0){const e=5,n=Math.round(16*2**t),s=(e-1)*(n+1)+2*n,r=new Float64Array(3*s),o=new Float32Array(3*s),i=new Float32Array(2*s),a=new Uint32Array(3*(4*n));let l=0,c=0,u=0,h=0,f=0;for(let t=0;t<=e;t++){const s=0===t||t===e,p=t<=1||t>=e-1,m=2===t||4===t,d=s?n-1:n;for(let w=0;w<=d;w++){const y=w/d*2*Math.PI,v=s?0:.5;On[0]=v*Math.sin(y),On[1]=v*-Math.cos(y),On[2]=t<=2?.5:-.5;for(let e=0;e<3;e++)r[l++]=On[e],o[c++]=p?2===e?t<=1?1:-1:0:2===e?0:On[e]/v;i[u++]=(w+(s?.5:0))/n,i[u++]=t<=1?1*t/3:t<=3?1*(t-2)/3+1/3:1*(t-4)/3+2/3,m||0===t||w===n||(t!==e&&(a[h++]=f,a[h++]=f+1,a[h++]=f-n),1!==t&&(a[h++]=f,a[h++]=f-n,a[h++]=f-n-1)),f++}}return{position:r,normal:o,uv:i,faces:a}}function gn(t,e){const n="number"==typeof e?e:null!=e?e.width:1,s="number"==typeof e?e:null!=e?e.height:1;switch(t){case"up":case"down":return{width:n,depth:s};case"north":case"south":return{width:n,height:s};case"east":case"west":return{depth:n,height:s}}}function xn(t){const e=Tn.facingAxisOrderSwap[t],n=Tn.position,s=Tn.normal,r=new Float64Array(n.length),o=new Float32Array(s.length);let i=0;for(let t=0;t<4;t++){const t=i;for(let a=0;a<3;a++){const l=e[a],c=Math.abs(l)-1,u=l>=0?1:-1;r[i]=n[t+c]*u,o[i]=s[t+c]*u,i++}}return{position:r,normal:o,uv:new Float32Array(Tn.uv),faces:new Uint32Array(Tn.faces),isPlane:!0}}const bn=1,Mn=2,jn=3,Tn={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[jn,bn,Mn],west:[-jn,-bn,Mn],north:[-bn,jn,Mn],south:[bn,-jn,Mn],up:[bn,Mn,jn],down:[bn,-Mn,-jn]}};function An(t,e,n){t.isPlane||Sn(t),Rn(t,Fn(n?.size,n?.unit,e.spatialReference));const s=Ft(e,n),r=e.spatialReference.isGeographic?Ft(e):s,o=Pt({vertexAttributes:t,vertexSpace:r,spatialReference:e.spatialReference},s,{allowBufferReuse:!0});return{vertexAttributes:new jt({...o,uv:t.uv}),vertexSpace:s,components:[new Te({faces:t.faces,material:n?.material||null})],spatialReference:e.spatialReference}}function Sn(t){for(let e=0;e<t.position.length;e+=3)t.position[e+2]+=.5}function Fn(t,e,n){const s=Bt(e,n);if(null==t&&1===s)return null;if(null==t)return[s,s,s];if("number"==typeof t){const e=t*s;return[e,e,e]}return[null!=t.width?t.width*s:s,null!=t.depth?t.depth*s:s,null!=t.height?t.height*s:s]}function Rn(t,e){if(null!=e){Dn[0]=e[0],Dn[4]=e[1],Dn[8]=e[2];for(let e=0;e<t.position.length;e+=3){for(let n=0;n<3;n++)On[n]=t.position[e+n];V(On,On,Dn);for(let n=0;n<3;n++)t.position[e+n]=On[n]}if(e[0]!==e[1]||e[1]!==e[2]){Dn[0]=1/e[0],Dn[4]=1/e[1],Dn[8]=1/e[2];for(let e=0;e<t.normal.length;e+=3){for(let n=0;n<3;n++)On[n]=t.normal[e+n];V(On,On,Dn),Z(On,On);for(let n=0;n<3;n++)t.normal[e+n]=On[n]}}}}const En={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},Ln={south:0,east:1,north:2,west:3,up:4,down:5},On=R(),Dn=ne();const Nn=()=>p.getLogger("esri.geometry.support.meshUtils.rotate");function Cn(t,e,n){if(!t.vertexAttributes?.position||0===e[3])return;const{spatialReference:s,vertexSpace:r}=t,o=n?.origin??t.origin,i=n?.geographic,a=He(Nn,r,s,i);Rt(t)?Un(t,e,o):a?qn(t,e,o):In(t,e,o)}function Un(t,e,n){t.transform??=new dt;const{vertexSpace:s,transform:r,spatialReference:o}=t,[i,a,l]=s.origin,c=new P({x:i,y:a,z:l,spatialReference:o}),u=Hn;if(c.equals(n))x(u,0,0,0);else if(!_t(u,n,t))return void It(Nn(),n.spatialReference,o,Ht);se(kn,yt(e),wt(e));const h=J(Bn,kn,Y,K,u),{localMatrix:f}=r,p=Q(Bn,h,f);r.scale=X(R(),p),tt(p,p,et(Hn,r.scale));const m=r.rotationAxis;r.rotation=vt(p),0===r.rotationAngle&&(r.rotationAxis=m),r.translation=nt(R(),p)}function qn(t,e,n){const s=t.spatialReference,r=Jt(s),o=Wn;if(!qt(n,o,r)&&(It(Nn(),n.spatialReference,r,"Falling back to mesh origin"),!qt(t.origin,o,r)))return void It(Nn(),t.origin.spatialReference,r);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,l=t.vertexAttributes.tangent,c=new Float64Array(i.length),u=null!=a?new Float32Array(a.length):null,h=null!=l?new Float32Array(l.length):null;Kt(r,o,$n,r),st(zn,$n);const f=_n;V(yt(_n),yt(e),zn),f[3]=e[3],$t(i,s,c,r)&&(null==a||null==u||zt(a,i,s,c,r,u))&&(null==l||null==h||Wt(l,i,s,c,r,h))?(Pn(c,f,3,o),kt(c,r,i,s)&&(null==a||null==u||(Pn(u,f,3),Gt(u,i,s,c,r,a)))&&(null==l||null==h||(Pn(h,f,4),Vt(h,i,s,c,r,l)))?t.vertexAttributesChanged():It(Nn(),r,s)):It(Nn(),s,r)}function In(t,e,n){const s=Wn;if(!qt(n,s,t.spatialReference)){const e=t.origin;return s[0]=e.x,s[1]=e.y,s[2]=e.z,void It(Nn(),n.spatialReference,t.spatialReference,Ht)}Pn(t.vertexAttributes.position,e,3,s),Pn(t.vertexAttributes.normal,e,3),Pn(t.vertexAttributes.tangent,e,4),t.vertexAttributesChanged()}function Pn(t,e,n,s=Y){if(null!=t){rt($n,wt(e),yt(e));for(let e=0;e<t.length;e+=n){for(let n=0;n<3;n++)Hn[n]=t[e+n]-s[n];ot(Hn,Hn,$n);for(let n=0;n<3;n++)t[e+n]=Hn[n]+s[n]}}}const Hn=R(),Bn=Zt(),_n=gt(),$n=Zt(),zn=ne(),Wn=R(),kn=re();const Gn=()=>p.getLogger("esri.geometry.support.meshUtils.scale");function Vn(t,e,n){if(!t.vertexAttributes?.position)return;const{vertexSpace:s,spatialReference:r}=t,o=n?.origin??t.origin,i=n?.geographic,a=He(Gn,s,r,i);Rt(t)?Zn(t,e,o):a?Jn(t,e,o):Kn(t,e,o)}function Zn(t,e,n){t.transform??=new dt;const{vertexSpace:s,transform:r,spatialReference:o}=t,[i,a,l]=s.origin,c=new P({x:i,y:a,z:l,spatialReference:o}),u=Qn;if(c.equals(n))x(u,0,0,0);else if(!_t(u,n,t))return void It(Gn(),n.spatialReference,o,Ht);const h=x(Xn,e,e,e),f=J(ts,oe,Y,h,u),{localMatrix:p}=r,m=Q(ts,f,p);r.scale=X(R(),m),tt(m,m,et(Qn,r.scale));const d=r.rotationAxis;r.rotation=vt(m),0===r.rotationAngle&&(r.rotationAxis=d),r.translation=nt(R(),m)}function Jn(t,e,n){const s=t.spatialReference,r=Jt(s),o=es;if(!qt(n,o,r)&&(It(Gn(),n.spatialReference,r,"Falling back to mesh origin"),!qt(t.origin,o,r)))return void It(Gn(),t.origin.spatialReference,r);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,l=t.vertexAttributes.tangent,c=new Float64Array(i.length),u=null!=a?new Float32Array(a.length):null,h=null!=l?new Float32Array(l.length):null;$t(i,s,c,r)&&(null==a||null==u||zt(a,i,s,c,r,u))&&(null==l||null==h||Wt(l,i,s,c,r,h))?(Yn(c,e,o),kt(c,r,i,s)&&(null==a||null==u||Gt(u,i,s,c,r,a))&&(null==l||null==h||Vt(h,i,s,c,r,l))?t.vertexAttributesChanged():It(Gn(),r,s)):It(Gn(),s,r)}function Kn(t,e,n){const s=es;if(!qt(n,s,t.spatialReference)){const e=t.origin;return s[0]=e.x,s[1]=e.y,s[2]=e.z,void It(Gn(),n.spatialReference,t.spatialReference,Ht)}Yn(t.vertexAttributes.position,e,s),t.vertexAttributesChanged()}function Yn(t,e,n=Y){if(t)for(let s=0;s<t.length;s+=3){for(let e=0;e<3;e++)Qn[e]=t[s+e]-n[e];it(Qn,Qn,e);for(let e=0;e<3;e++)t[s+e]=Qn[e]+n[e]}}const Qn=R(),Xn=R(),ts=Zt(),es=R();var ns;const ss="esri.geometry.Mesh";function rs(){return p.getLogger(ss)}const os={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:At,local:Tt}};let is=ns=class extends(at.LoadableMixin(lt(ct))){constructor(t){super(t),this.components=null,this.vertexSpace=new At,this.transform=null,this.metadata=new mn,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new jt,this.type="mesh"}initialize(){(0===this.metadata.externalSources.length||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.addHandles(ut((()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map((t=>t.clone()))})),(()=>this._clearSources()),{once:!0,sync:!0}))}))}get hasExtent(){return this.loaded?this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0):null!=this.metadata.displaySource?.extent}get _transformedExtent(){const{spatialReference:t,vertexSpace:e}=this,n=this;return Je({get transform(){return n.transform},vertexSpace:e,spatialReference:t,untransformedBounds:this._untransformedBounds})}get _untransformedBounds(){const{vertexAttributes:{position:t},components:e}=this;return 0===t.length||0===e?.length?ht(mt):D(t)}get origin(){const t=Et(this.vertexSpace,this.spatialReference);if(null!=t)return t;const{center:e,zmin:n}=this._transformedExtent;return new P({x:e.x,y:e.y,z:n,spatialReference:this.spatialReference})}get extent(){return this.loaded||null==this.metadata?.displaySource?.extent?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(t){this._checkIfLoaded("addComponent()")&&(this.components||(this.components=[]),this.components.push(Te.from(t)),this.notifyChange("components"))}removeComponent(t){if(this._checkIfLoaded("removeComponent()")){if(this.components){const e=this.components.indexOf(t);if(-1!==e)return this.components.splice(e,1),void this.notifyChange("components")}rs().error("removeComponent()",Se)}}rotate(t,e,n,s){return xt(t,e,n,as),Cn(this,as,s),this}offset(t,e,n){if(!this._checkIfLoaded("offset()"))return this;const{vertexSpace:s,vertexAttributes:r}=this,o=r?.position;if(!o)return this;if(St(s)){const[r,o,i]=s.origin;s.origin=E(r+t,o+e,i+n)}else{for(let s=0;s<o.length;s+=3)o[s]+=t,o[s+1]+=e,o[s+2]+=n;this.vertexAttributesChanged()}return this}scale(t,e){return this._checkIfLoaded("scale()")?(Vn(this,t,e),this):this}centerAt(t,e){return this._checkIfLoaded("centerAt()")?(_e(this,t,e),this):this}load(t){const{metadata:{displaySource:e}}=this;return e&&this.addResolvingPromise(Qe(this,e,t)),Promise.resolve(this)}addExternalSources(t){this.metadata.externalSources.addMany(t)}updateDisplaySource(t){this.metadata.displaySource=t}clone(){return this.cloneAndModifyVertexAttributes(this.vertexAttributes.clone(),this.vertexSpace.clone(),{preserveMetadata:!0})}cloneAndModifyVertexAttributes(t,e,n){let s=null;if(this.components){const t=new Map,e=new Map;s=this.components.map((n=>n.cloneWithDeduplication(t,e)))}const r={components:s,spatialReference:this.spatialReference,vertexAttributes:t,vertexSpace:e,transform:this.transform?.clone()??null,metadata:n?.preserveMetadata?this.metadata.clone():new mn};return new ns(r)}cloneShallow(){return new ns({components:this.components,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(t){const[{toBinaryGLTF:e}]=await Promise.all([import("./p-f8f210a5.js"),this.load(t)]);return I(t),await e(this,t)}get memoryUsage(){let t=0;if(t+=this.vertexAttributes.memoryUsage,null!=this.components)for(const e of this.components)t+=e.memoryUsage;return t}_clearSources(){this.metadata.clearSources()}_checkIfLoaded(t){return!!this.loaded||(rs().error(t,Ae),!1)}static createBox(t,e){if(!(t instanceof P))return rs().error(".createBox()",Re),null;const n=new ns(An(dn(),t,e));return e?.imageFace&&"all"!==e.imageFace?wn(n,e.imageFace):n}static createSphere(t,e){return t instanceof P?new ns(An(yn(e?.densificationFactor||0),t,e)):(rs().error(".createSphere()",Re),null)}static createCylinder(t,e){return t instanceof P?new ns(An(vn(e?.densificationFactor||0),t,e)):(rs().error(".createCylinder()",Re),null)}static createPlane(t,e){if(!(t instanceof P))return rs().error(".createPlane()",Re),null;const n=e?.facing??"up",s=gn(n,e?.size);return new ns(An(xn(n),t,{...e,size:s}))}static createFromPolygon(t,e){if(!(t instanceof ft))return rs().error(".createFromPolygon()",Fe),null;const n=Ne(t);return new ns({vertexAttributes:new jt({position:n.position}),components:[new Te({faces:n.faces,shading:"flat",material:e?.material??null})],spatialReference:t.spatialReference,vertexSpace:new At})}static async createFromGLTF(t,e,n){if(!(t instanceof P)){const t=new Ee;throw rs().error(".createfromGLTF()",t.message),t}const{loadGLTFMesh:s}=await q(import("./p-73eb21db.js"),n);return new ns(await s(t,e,n))}static async createFromFiles(t,e,n){pt(rs(),"`Mesh.createFromFiles` is deprecated in favor of 'SceneLayer.convertMesh'",{replacement:"SceneLayer.convertMesh",version:"4.29"});const s=t=>rs().error(".createFromFiles()",t.message);if(!(t instanceof P)){const t=new Ee;throw s(t),t}if(!n?.layer)throw new d("invalid:no-layer","SceneLayer required for file to mesh conversion.");return n.layer.convertMesh(e,{location:t,...n})}static createWithExternalSource(t,e,n){const s=n?.extent??null,{spatialReference:r}=t,o=n?.transform?.clone()??new dt,i=Ft(t,n),a=n?.unitConversionDisabled,l={source:e,extent:s,unitConversionDisabled:a},c=new mn;return c.externalSources.push(l),new ns({metadata:c,transform:o,vertexSpace:i,spatialReference:r})}static createIncomplete(t,e){const{spatialReference:n}=t,s=e?.transform?.clone()??new dt,r=Ft(t,e),o=new ns({transform:s,vertexSpace:r,spatialReference:n});return o.addResolvingPromise(Promise.reject(new d("mesh-incomplete","Mesh resources are not complete"))),o}};t([e({type:[Te],json:{write:!0}})],is.prototype,"components",void 0),t([e({nonNullable:!0,types:os,constructOnly:!0,json:{write:!0}})],is.prototype,"vertexSpace",void 0),t([e({type:dt,json:{write:!0}})],is.prototype,"transform",void 0),t([e({constructOnly:!0})],is.prototype,"metadata",void 0),t([e()],is.prototype,"hasExtent",null),t([e()],is.prototype,"_transformedExtent",null),t([e()],is.prototype,"_untransformedBounds",null),t([e()],is.prototype,"origin",null),t([e({readOnly:!0,json:{read:!1}})],is.prototype,"extent",null),t([e({readOnly:!0,json:{read:!1,write:!0,default:!0}})],is.prototype,"hasZ",void 0),t([e({readOnly:!0,json:{read:!1,write:!0,default:!1}})],is.prototype,"hasM",void 0),t([e({type:jt,nonNullable:!0,json:{write:!0}})],is.prototype,"vertexAttributes",void 0),is=ns=t([o(ss)],is);const as=gt(),ls=is;export{ls as $,de as c,Te as f,be as m,pe as w};
//# sourceMappingURL=p-a68c6147.js.map