import{kM as e,oG as t,kN as s,kU as i,kV as r,kW as a,kX as o,o4 as n,oe as l,od as h,iP as p,kc as d,P as c,oC as u,pM as m,jb as y,aG as g,U as b,E as f,G as v,of as j,oK as w,s as x,di as S,r as I,p as k,oU as T,hx as M,b7 as E,iV as F,k_ as R,q,ps as G}from"./p-aad64c9f.js";import{m as L,f as P,t as O}from"./p-9bb3ed3d.js";import{t as U}from"./p-a250b290.js";import"./p-2af77f97.js";import"./p-dad6a156.js";import"./p-d5a66c42.js";import"./p-07c8b3b5.js";import"./p-1062e8df.js";import"./p-4e60756f.js";import"./p-21ce5524.js";import"./p-aff89b86.js";import"./p-da522976.js";import"./p-d492d39b.js";import"./p-c783c054.js";import"./p-875cbb57.js";let V=class extends(e(t(s(L(P(i(r(a(o(n(l(h(p))))))))))))){constructor(...e){super(...e),this._exportImageParameters=new d({layer:this}),this.dateFieldsTimeZone=null,this.datesInUnknownTimezone=!1,this.dpi=96,this.gdbVersion=null,this.imageFormat="png24",this.imageMaxHeight=2048,this.imageMaxWidth=2048,this.imageTransparency=!0,this.isReference=null,this.labelsVisible=!1,this.operationalLayerType="ArcGISMapServiceLayer",this.preferredTimeZone=null,this.sourceJSON=null,this.sublayers=null,this.type="map-image",this.url=null}normalizeCtorArgs(e,t){return"string"==typeof e?{url:e,...t}:e}load(e){const t=null!=e?e.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Map Service"]},e).catch(c).then((()=>this._fetchService(t)))),Promise.resolve(this)}destroy(){this._exportImageParameters.destroy()}readImageFormat(e,t){const s=t.supportedImageFormatTypes;return s&&s.includes("PNG32")?"png32":"png24"}writeSublayers(e,t,s,i){if(!this.loaded||!e)return;const r=e.slice().reverse().flatten((({sublayers:e})=>e&&e.toArray().reverse())).toArray();let a=!1;const o=G(i.origin);if(this.capabilities?.operations.supportsExportMap&&this.capabilities?.exportMap?.supportsDynamicLayers)if(o===u.PORTAL_ITEM){const e=this.createSublayersForOrigin("service").sublayers;a=m(r,e,u.SERVICE)}else if(o>u.PORTAL_ITEM){const e=this.createSublayersForOrigin("portal-item");a=m(r,e.sublayers,G(e.origin))}const n=[],l={writeSublayerStructure:a,...i};let h=a||this.hasVisibleLayersForOrigin(o);r.forEach((e=>{const t=e.write({},l);n.push(t),h=h||"user"===e.originOf("visible")}));n.some((e=>Object.keys(e).length>1))&&(t.layers=n),h&&(t.visibleLayers=r.filter((e=>e.visible)).map((e=>e.id)))}createExportImageParameters(e,t,s,i){const r=i?.pixelRatio||1;e&&this.version>=10&&(e=e.clone().shiftCentralMeridian()),this._exportImageParameters.floors=i?.floors??null,this._exportImageParameters.scale=y({extent:e,width:t})*r;const a=this._exportImageParameters.toJSON(),o=!i?.rotation||this.version<10.3?{}:{rotation:-i.rotation},n=e?.spatialReference,l=g(n);a.dpi*=r;const h={};if(i?.timeExtent){const{start:e,end:t}=i.timeExtent.toJSON();h.time=e&&t&&e===t?""+e:`${e??"null"},${t??"null"}`}else this.timeInfo&&!this.timeInfo.hasLiveData&&(h.time="null,null");return{bbox:e&&e.xmin+","+e.ymin+","+e.xmax+","+e.ymax,bboxSR:l,imageSR:l,size:t+","+s,...a,...o,...h}}async fetchImage(e,t,s,i){const{data:r}=await this._fetchImage("image",e,t,s,i);return r}async fetchImageBitmap(e,t,s,i){const{data:r,url:a}=await this._fetchImage("blob",e,t,s,i);return U(r,a,i?.signal)}async fetchRecomputedExtents(e={}){const t={...e,query:{returnUpdates:!0,f:"json",...this.customParameters,token:this.apiKey}},{data:s}=await b(this.url,t),{extent:i,fullExtent:r,timeExtent:a}=s,o=i||r;return{fullExtent:o&&f.fromJSON(o),timeExtent:a&&v.fromJSON({start:a[0],end:a[1]})}}loadAll(){return j(this,(e=>{e(this.allSublayers),e(this.subtables)}))}serviceSupportsSpatialReference(e){return w(this,e)}async _fetchImage(e,t,s,i,r){const a={responseType:e,signal:r?.signal??null,query:{...this.parsedUrl.query,...this.createExportImageParameters(t,s,i,r),f:"image",...this.refreshParameters,...this.customParameters,token:this.apiKey}},o=this.parsedUrl.path+"/export";if(null!=a.query?.dynamicLayers&&!this.capabilities?.exportMap?.supportsDynamicLayers)throw new x("mapimagelayer:dynamiclayer-not-supported",`service ${this.url} doesn't support dynamic layers, which is required to be able to change the sublayer's order, rendering, labeling or source.`,{query:a.query});try{const{data:e}=await b(o,a);return{data:e,url:o}}catch(e){if(S(e))throw e;throw new x("mapimagelayer:image-fetch-error",`Unable to load image: ${o}`,{error:e})}}async _fetchService(e){if(this.sourceJSON)return void this.read(this.sourceJSON,{origin:"service",url:this.parsedUrl});const{data:t,ssl:s}=await b(this.parsedUrl.path,{query:{f:"json",...this.parsedUrl.query,...this.customParameters,token:this.apiKey},signal:e});s&&(this.url=this.url.replace(/^http:/i,"https:")),this.sourceJSON=t,this.read(t,{origin:"service",url:this.parsedUrl})}hasVisibleLayersForOrigin(e){return!(null==e||!this.sublayersSourceJSON[e]?.visibleLayers)}};I([k(T("dateFieldsTimeReference"))],V.prototype,"dateFieldsTimeZone",void 0),I([k({type:Boolean})],V.prototype,"datesInUnknownTimezone",void 0),I([k()],V.prototype,"dpi",void 0),I([k()],V.prototype,"gdbVersion",void 0),I([k()],V.prototype,"imageFormat",void 0),I([M("imageFormat",["supportedImageFormatTypes"])],V.prototype,"readImageFormat",null),I([k({json:{origins:{service:{read:{source:"maxImageHeight"}}}}})],V.prototype,"imageMaxHeight",void 0),I([k({json:{origins:{service:{read:{source:"maxImageWidth"}}}}})],V.prototype,"imageMaxWidth",void 0),I([k()],V.prototype,"imageTransparency",void 0),I([k({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],V.prototype,"isReference",void 0),I([k({json:{read:!1,write:!1}})],V.prototype,"labelsVisible",void 0),I([k({type:["ArcGISMapServiceLayer"]})],V.prototype,"operationalLayerType",void 0),I([k({json:{read:!1,write:!1}})],V.prototype,"popupEnabled",void 0),I([k(T("preferredTimeReference"))],V.prototype,"preferredTimeZone",void 0),I([k()],V.prototype,"sourceJSON",void 0),I([k({json:{write:{ignoreOrigin:!0}}})],V.prototype,"sublayers",void 0),I([E("sublayers",{layers:{type:[O]},visibleLayers:{type:[F]}})],V.prototype,"writeSublayers",null),I([k({type:["show","hide","hide-children"]})],V.prototype,"listMode",void 0),I([k({json:{read:!1},readOnly:!0,value:"map-image"})],V.prototype,"type",void 0),I([k(R)],V.prototype,"url",void 0),V=I([q("esri.layers.MapImageLayer")],V);const A=V;export default A;
//# sourceMappingURL=p-a113e7b4.js.map