const t=2;class s{constructor(t=[],s=[],e=!1){this.lengths=t??[],this.coords=s??[],this.hasIndeterminateRingOrder=e}static fromRect(t){const[e,i,r,h]=t,n=r-e,o=h-i;return new s([5],[e,i,n,0,0,o,-n,0,0,-o])}get isPoint(){return 0===this.lengths.length}get maxLength(){return Math.max(...this.lengths)}get size(){return this.lengths.reduce(((t,s)=>t+s))}forEachVertex(s){let e=0;this.lengths.length||s(this.coords[0],this.coords[1]);for(let i=0;i<this.lengths.length;i++){const r=this.lengths[i];for(let i=0;i<r;i++){s(this.coords[t*(i+e)],this.coords[t*(i+e)+1])}e+=r}}deltaDecode(){const t=this.clone(),{coords:s,lengths:e}=t;let i=0;for(const t of e){for(let e=1;e<t;e++)s[2*(i+e)]+=s[2*(i+e)-2],s[2*(i+e)+1]+=s[2*(i+e)-1];i+=t}return t}clone(e){if(0===this.lengths.length)return new s([],[this.coords[0],this.coords[1]]);const i=(0===this.lengths.length?1:this.lengths.reduce(((t,s)=>t+s)))*t,r=this.coords.slice(0,i);return e?(e.set(r),new s(this.lengths,e,this.hasIndeterminateRingOrder)):new s(Array.from(this.lengths),Array.from(r),this.hasIndeterminateRingOrder)}}export{s as e};
//# sourceMappingURL=p-94b15954.js.map