import{e as t}from"./p-38ec0f4e.js";import{H as n}from"./p-c67db40b.js";import{e as r}from"./p-c99b552a.js";import{C as e}from"./p-8567e6fe.js";import{t as o}from"./p-89242a33.js";import{i6 as s,i7 as c,a2 as i,i8 as a,i9 as f,ia as u,ib as l,ic as h,id as d,ie as p,a0 as w,M as g,al as m,ig as y,bh as A}from"./p-028496e2.js";function M(t,n=0){const r=t.stride;return Array.from(t.fields.keys()).map((e=>{const s=t.fields.get(e),c=s.constructor.ElementCount,i=I(s.constructor.ElementType),a=s.offset,f=!(!s.optional||!s.optional.glNormalized);return new o(e,c,i,a,r,f,n)}))}function I(t){const n=S[t];if(n)return n;throw new Error("BufferType not supported in WebGL")}const S={u8:e.UNSIGNED_BYTE,u16:e.UNSIGNED_SHORT,u32:e.UNSIGNED_INT,i8:e.BYTE,i16:e.SHORT,i32:e.INT,f32:e.FLOAT};const b=n().vec3f(r.POSITION).u16(r.COMPONENTINDEX),B=n().vec2u8(r.SIDENESS);M(B);const j=n().vec3f(r.POSITION0).vec3f(r.POSITION1).vec2i16(r.NORMALCOMPRESSED).u16(r.COMPONENTINDEX).u8(r.VARIANTOFFSET,{glNormalized:!0}).u8(r.VARIANTSTROKE).u8(r.VARIANTEXTENSION,{glNormalized:!0}),v=n().vec3f(r.POSITION0).vec3f(r.POSITION1).vec2i16(r.NORMALCOMPRESSED).vec2i16(r.NORMAL2COMPRESSED).u16(r.COMPONENTINDEX).u8(r.VARIANTOFFSET,{glNormalized:!0}).u8(r.VARIANTSTROKE).u8(r.VARIANTEXTENSION,{glNormalized:!0});const N=-1;var F;function L(t,n,r,e=G){const o=t.vertices.position,u=t.vertices.componentIndex,l=g(e.anglePlanar),h=g(e.angleSignificantEdge),d=Math.cos(h),p=Math.cos(l),w=T.edge,m=w.position0,y=w.position1,A=w.faceNormal0,M=w.faceNormal1,I=x(t),S=D(t),b=S.length/4,B=n.allocate(b);let j=0;const v=b,F=r.allocate(v);let L=0,C=0,H=0;const K=s(0,b),O=new Float32Array(b);O.forEach(((t,n,r)=>{o.getVec(S[4*n],m),o.getVec(S[4*n+1],y),r[n]=c(m,y)})),K.sort(((t,n)=>O[n]-O[t]));const P=new Array,W=new Array;for(let t=0;t<b;t++){const e=K[t],s=O[e],c=S[4*e],h=S[4*e+1],g=S[4*e+2],b=S[4*e+3],v=b===N;if(o.getVec(c,m),o.getVec(h,y),v)i(A,I[3*g],I[3*g+1],I[3*g+2]),a(M,A),w.componentIndex=u.get(c),w.cosAngle=f(A,M);else{if(i(A,I[3*g],I[3*g+1],I[3*g+2]),i(M,I[3*b],I[3*b+1],I[3*b+2]),w.componentIndex=u.get(c),w.cosAngle=f(A,M),z(w,p))continue;w.cosAngle<-.9999&&a(M,A)}C+=s,H++,v||U(w,d)?(n.write(B,j++,w),P.push(s)):E(w,l)&&(r.write(F,L++,w),W.push(s))}const k=new Float32Array(P.reverse()),q=new Float32Array(W.reverse());return{regular:{instancesData:n.trim(B,j),lodInfo:{lengths:k}},silhouette:{instancesData:r.trim(F,L),lodInfo:{lengths:q}},averageEdgeLength:C/H}}function U(t,n){return t.cosAngle<n}function z(t,n){return t.cosAngle>n}function E(t,n){const r=l(t.cosAngle),e=T.fwd,o=T.ortho;h(e,t.position1,t.position0);return r*(f(u(o,t.faceNormal0,t.faceNormal1),e)>0?-1:1)>n}function D(t){const n=t.faces.length/3,r=t.faces,e=t.neighbors;let o=0;for(let t=0;t<n;t++){const n=e[3*t],s=e[3*t+1],c=e[3*t+2],i=r[3*t],a=r[3*t+1],f=r[3*t+2];o+=n===N||i<a?1:0,o+=s===N||a<f?1:0,o+=c===N||f<i?1:0}const s=new Int32Array(4*o);let c=0;for(let t=0;t<n;t++){const n=e[3*t],o=e[3*t+1],i=e[3*t+2],a=r[3*t],f=r[3*t+1],u=r[3*t+2];(n===N||a<f)&&(s[c++]=a,s[c++]=f,s[c++]=t,s[c++]=n),(o===N||f<u)&&(s[c++]=f,s[c++]=u,s[c++]=t,s[c++]=o),(i===N||u<a)&&(s[c++]=u,s[c++]=a,s[c++]=t,s[c++]=i)}return s}function x(t){const n=t.faces.length/3,r=t.vertices.position,e=t.faces,o=C.v0,s=C.v1,c=C.v2,i=new Float32Array(3*n);for(let t=0;t<n;t++){const n=e[3*t],a=e[3*t+1],f=e[3*t+2];r.getVec(n,o),r.getVec(a,s),r.getVec(f,c),d(s,s,o),d(c,c,o),u(o,s,c),p(o,o),i[3*t]=o[0],i[3*t+1]=o[1],i[3*t+2]=o[2]}return i}!function(t){t[t.SOLID=0]="SOLID",t[t.SKETCH=1]="SKETCH"}(F||(F={}));const T={edge:{position0:w(),position1:w(),faceNormal0:w(),faceNormal1:w(),componentIndex:0,cosAngle:0},ortho:w(),fwd:w()},C={v0:w(),v1:w(),v2:w()},G={anglePlanar:4,angleSignificantEdge:35};function H(t,n,r){const e=n/3,o=new Uint32Array(r+1),s=new Uint32Array(r+1),c=(t,n)=>{t<n?o[t+1]++:s[n+1]++};for(let n=0;n<e;n++){const r=t[3*n],e=t[3*n+1],o=t[3*n+2];c(r,e),c(e,o),c(o,r)}let i=0,a=0;for(let t=0;t<r;t++){const n=o[t+1],r=s[t+1];o[t+1]=i,s[t+1]=a,i+=n,a+=r}const f=new Uint32Array(6*e),u=o[r],l=(t,n,r)=>{if(t<n){const e=o[t+1]++;f[2*e]=n,f[2*e+1]=r}else{const e=s[n+1]++;f[2*u+2*e]=t,f[2*u+2*e+1]=r}};for(let n=0;n<e;n++){const r=t[3*n],e=t[3*n+1],o=t[3*n+2];l(r,e,n),l(e,o,n),l(o,r,n)}const h=(t,n)=>{const r=2*t,e=n-t;for(let t=1;t<e;t++){const n=f[r+2*t],e=f[r+2*t+1];let o=t-1;for(;o>=0&&f[r+2*o]>n;o--)f[r+2*o+2]=f[r+2*o],f[r+2*o+3]=f[r+2*o+1];f[r+2*o+2]=n,f[r+2*o+3]=e}};for(let t=0;t<r;t++)h(o[t],o[t+1]),h(u+s[t],u+s[t+1]);const d=new Int32Array(3*e),p=(n,r)=>n===t[3*r]?0:n===t[3*r+1]?1:n===t[3*r+2]?2:-1,w=(t,n)=>{const r=p(t,n);d[3*n+r]=-1},g=(t,n,r,e)=>{const o=p(t,n);d[3*n+o]=e;const s=p(r,e);d[3*e+s]=n};for(let t=0;t<r;t++){let n=o[t];const r=o[t+1];let e=s[t];const c=s[t+1];for(;n<r&&e<c;){const r=f[2*n],o=f[2*u+2*e];r===o?(g(t,f[2*n+1],o,f[2*u+2*e+1]),n++,e++):r<o?(w(t,f[2*n+1]),n++):(w(o,f[2*u+2*e+1]),e++)}for(;n<r;)w(t,f[2*n+1]),n++;for(;e<c;){w(f[2*u+2*e],f[2*u+2*e+1]),e++}}return d}function K(t,n,r,e,o,s=2){const c=1/(Math.abs(r)+Math.abs(e)+Math.abs(o)),i=r*c,a=e*c,f=o<=0?(i>=0?1:-1)*(1-Math.abs(a)):i,u=o<=0?(a>=0?1:-1)*(1-Math.abs(i)):a,l=n*s;t[l]=O(f),t[l+1]=O(u)}function O(t){return m(Math.round(32767*t),-32767,32767)}class P{updateSettings(t){this.settings=t,this._edgeHashFunction=t.reducedPrecision?Q:J}write(t,n,r){const e=this._edgeHashFunction(r);_.seed=e;const o=_.getIntRange(0,255),s=_.getIntRange(0,this.settings.variants-1),c=.7,i=_.getFloat(),a=255*(.5*X(-(1-Math.min(i/c,1))+Math.max(0,i-c)/(1-c),1.2)+.5);t.position0.setVec(n,r.position0),t.position1.setVec(n,r.position1),t.componentIndex.set(n,r.componentIndex),t.variantOffset.set(n,o),t.variantStroke.set(n,s),t.variantExtension.set(n,a)}trim(t,n){return t.slice(0,n)}}const W=new Float32Array(6),k=new Uint32Array(W.buffer),q=new Uint32Array(1);function J(t){const n=W;n[0]=t.position0[0],n[1]=t.position0[1],n[2]=t.position0[2],n[3]=t.position1[0],n[4]=t.position1[1],n[5]=t.position1[2],q[0]=5381;for(let t=0;t<k.length;t++)q[0]=31*q[0]+k[t];return q[0]}function Q(t){const n=W;n[0]=V(t.position0[0]),n[1]=V(t.position0[1]),n[2]=V(t.position0[2]),n[3]=V(t.position1[0]),n[4]=V(t.position1[1]),n[5]=V(t.position1[2]),q[0]=5381;for(let t=0;t<k.length;t++)q[0]=31*q[0]+k[t];return q[0]}const R=1e4;function V(t){return Math.round(t*R)/R}function X(t,n){const r=t<0?-1:1;return Math.abs(t)**n*r}class Y{constructor(){this._commonWriter=new P}updateSettings(t){this._commonWriter.updateSettings(t)}allocate(t){return j.createBuffer(t)}write(t,n,r){this._commonWriter.write(t,n,r),y($,r.faceNormal0,r.faceNormal1),p($,$);const{typedBuffer:e,typedBufferStride:o}=t.normalCompressed;K(e,n,$[0],$[1],$[2],o)}trim(t,n){return this._commonWriter.trim(t,n)}}Y.Layout=j,Y.glLayout=M(j,1);class Z{constructor(){this._commonWriter=new P}updateSettings(t){this._commonWriter.updateSettings(t)}allocate(t){return v.createBuffer(t)}write(t,n,r){this._commonWriter.write(t,n,r);{const{typedBuffer:e,typedBufferStride:o}=t.normalCompressed;K(e,n,r.faceNormal0[0],r.faceNormal0[1],r.faceNormal0[2],o)}{const{typedBuffer:e,typedBufferStride:o}=t.normal2Compressed;K(e,n,r.faceNormal1[0],r.faceNormal1[1],r.faceNormal1[2],o)}}trim(t,n){return this._commonWriter.trim(t,n)}}Z.Layout=v,Z.glLayout=M(v,1);const $=w(),_=new A;function tt(t){const n=nt(t.data,t.skipDeduplicate,t.indices,t.indicesLength);return et.updateSettings(t.writerSettings),ot.updateSettings(t.writerSettings),L(n,et,ot)}function nt(n,r,e,o){if(r){const t=H(e,o,n.count);return new rt(e,o,t,n)}const s=t(n.buffer,n.stride/4,{originalIndices:e,originalIndicesLength:o}),c=H(s.indices,o,s.uniqueCount);return{faces:s.indices,facesLength:s.indices.length,neighbors:c,vertices:b.createView(s.buffer)}}class rt{constructor(t,n,r,e){this.faces=t,this.facesLength=n,this.neighbors=r,this.vertices=e}}const et=new Y,ot=new Z,st=n().vec3f(r.POSITION0).vec3f(r.POSITION1),ct=n().vec3f(r.POSITION0).vec3f(r.POSITION1).u16(r.COMPONENTINDEX);export{b as I,L as a,st as d,tt as f,ct as m,nt as u};
//# sourceMappingURL=p-c0e7fc06.js.map