import{cB as t,av as r,jQ as s}from"./p-3013819f.js";import{u as e,f as n,W as a,E as i,a as o,D as l,R as c,b as u,s as m}from"./p-dd344c44.js";import{m as p,S as f,L as d,h}from"./p-0ad1433d.js";import{R as y,i as x}from"./p-3809040a.js";import{M as P,T as b,e as j}from"./p-e7f8bbfb.js";import"./p-3b51db5e.js";class w{convertVectorFieldData(t){const r=e.fromJSON(t.pixelBlock),s=n(r,t.type);return Promise.resolve(null!=s?s.toJSON():null)}computeStatisticsHistograms(t){const r=e.fromJSON(t.pixelBlock),s=p(r);return Promise.resolve(s)}async decode(t){const r=await f(t.data,t.options);return r&&r.toJSON()}symbolize(r){r.pixelBlock=e.fromJSON(r.pixelBlock),r.extent=r.extent?t.fromJSON(r.extent):null;const s=this.symbolizer.symbolize(r);return Promise.resolve(null!=s?s.toJSON():null)}async updateSymbolizer(t){this.symbolizer=d.fromJSON(t.symbolizerJSON),t.histograms&&"rasterStretch"===this.symbolizer?.rendererJSON.type&&(this.symbolizer.rendererJSON.histograms=t.histograms)}async updateRasterFunction(t){this.rasterFunction=y(t.rasterFunctionJSON)}async process(s){const n=this.rasterFunction.process({extent:t.fromJSON(s.extent),primaryPixelBlocks:s.primaryPixelBlocks.map((t=>null!=t?e.fromJSON(t):null)),primaryPixelSizes:s.primaryPixelSizes?.map((t=>null!=t?r.fromJSON(t):null)),primaryRasterIds:s.primaryRasterIds});return null!=n?n.toJSON():null}stretch(t){const r=this.symbolizer.simpleStretch(e.fromJSON(t.srcPixelBlock),t.stretchParams);return Promise.resolve(r?.toJSON())}estimateStatisticsHistograms(t){const r=h(e.fromJSON(t.srcPixelBlock));return Promise.resolve(r)}split(t){const r=a(e.fromJSON(t.srcPixelBlock),t.tileSize,t.maximumPyramidLevel??0,!1===t.useBilinear);return r&&r.forEach(((t,s)=>{r.set(s,t?.toJSON())})),Promise.resolve(r)}clipTile(t){const r=e.fromJSON(t.pixelBlock),s=i({...t,pixelBlock:r});return Promise.resolve(s?.toJSON())}async mosaicAndTransform(t){const r=t.srcPixelBlocks.map((t=>t?new e(t):null)),s=o(r,t.srcMosaicSize,{blockWidths:t.blockWidths,alignmentInfo:t.alignmentInfo,clipOffset:t.clipOffset,clipSize:t.clipSize});let n,a=s;return t.coefs&&(a=l(s,t.destDimension,t.coefs,t.sampleSpacing,t.interpolation)),t.projectDirections&&t.gcsGrid&&(n=c(t.destDimension,t.gcsGrid),a=u(a,t.isUV?"vector-uv":"vector-magdir",n)),{pixelBlock:a?.toJSON(),localNorthDirections:n}}async createFlowMesh(t,r){const s={data:new Float32Array(t.flowData.buffer),mask:new Uint8Array(t.flowData.maskBuffer),width:t.flowData.width,height:t.flowData.height},{vertexData:e,indexData:n}=await m(t.meshType,t.simulationSettings,s,r.signal);return{result:{vertexBuffer:e.buffer,indexBuffer:n.buffer},transferList:[e.buffer,n.buffer]}}async getProjectionOffsetGrid(r){const e=t.fromJSON(r.projectedExtent),n=t.fromJSON(r.srcBufferExtent);let a=null;r.datumTransformationSteps&&(a=new s({steps:r.datumTransformationSteps})),(r.includeGCSGrid||P(e.spatialReference,n.spatialReference,a))&&await b();const i=r.rasterTransform?x(r.rasterTransform):null;return j({...r,projectedExtent:e,srcBufferExtent:n,datumTransformation:a,rasterTransform:i})}}export default w;
//# sourceMappingURL=p-5231c5b1.js.map