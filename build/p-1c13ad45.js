import{G as n}from"./p-3c20266a.js";import{hydratedAdapter as e}from"./p-386e90ef.js";import"./p-028496e2.js";import"./p-3b51db5e.js";function t(n){return Array.isArray(n)?n[0].spatialReference:n&&n.spatialReference}function r(e){return n.extendedSpatialReferenceInfo(e)}function u(r,u){return n.clip(e,t(r),r,u)}function i(r,u){return n.cut(e,t(r),r,u)}function o(r,u){return n.contains(e,t(r),r,u)}function s(r,u){return n.crosses(e,t(r),r,u)}function c(r,u,i){return n.distance(e,t(r),r,u,i)}function a(r,u){return n.equals(e,t(r),r,u)}function f(r,u){return n.intersects(e,t(r),r,u)}function l(r,u){return n.touches(e,t(r),r,u)}function p(r,u){return n.within(e,t(r),r,u)}function d(r,u){return n.disjoint(e,t(r),r,u)}function w(r,u){return n.overlaps(e,t(r),r,u)}function h(r,u,i){return n.relate(e,t(r),r,u,i)}function m(r){return n.isSimple(e,t(r),r)}function g(r){return n.simplify(e,t(r),r)}function x(r,u=!1){return n.convexHull(e,t(r),r,u)}function y(r,u){return n.difference(e,t(r),r,u)}function j(r,u){return n.symmetricDifference(e,t(r),r,u)}function A(r,u){return n.intersect(e,t(r),r,u)}function D(r,u=null){return n.union(e,t(r),r,u)}function S(r,u,i,o,s,c){return n.offset(e,t(r),r,u,i,o,s,c)}function b(r,u,i,o=!1){return n.buffer(e,t(r),r,u,i,o)}function L(r,u,i,o,s,c){return n.geodesicBuffer(e,t(r),r,u,i,o,s,c)}function R(r,u,i=!0){return n.nearestCoordinate(e,t(r),r,u,i)}function T(r,u){return n.nearestVertex(e,t(r),r,u)}function V(r,u,i,o){return n.nearestVertices(e,t(r),r,u,i,o)}function v(n){return"xmin"in n?"center"in n?n.center:null:"x"in n?n:"extent"in n?n.extent?.center??null:null}function z(e,t,r){if(null==e)throw new M;const u=e.spatialReference;if(null==(r=r??v(e)))throw new M;const i=e.constructor.fromJSON(n.rotate(e,t,r));return i.spatialReference=u,i}function E(e,t){if(null==e)throw new M;const r=e.spatialReference;if(null==(t=t??v(e)))throw new M;const u=e.constructor.fromJSON(n.flipHorizontal(e,t));return u.spatialReference=r,u}function H(e,t){if(null==e)throw new M;const r=e.spatialReference;if(null==(t=t??v(e)))throw new M;const u=e.constructor.fromJSON(n.flipVertical(e,t));return u.spatialReference=r,u}function I(r,u,i,o){return n.generalize(e,t(r),r,u,i,o)}function q(r,u,i){return n.densify(e,t(r),r,u,i)}function B(r,u,i,o=0){return n.geodesicDensify(e,t(r),r,u,i,o)}function C(r,u){return n.planarArea(e,t(r),r,u)}function G(r,u){return n.planarLength(e,t(r),r,u)}function P(r,u,i){return n.geodesicArea(e,t(r),r,u,i)}function k(r,u,i){return n.geodesicLength(e,t(r),r,u,i)}function F(r,u){return n.intersectLinesToPoints(e,t(r),r,u)}function J(e,t){n.changeDefaultSpatialReferenceTolerance(e,t)}function K(e){n.clearDefaultSpatialReferenceTolerance(e)}class M extends Error{constructor(){super("Illegal Argument Exception")}}export{b as buffer,J as changeDefaultSpatialReferenceTolerance,K as clearDefaultSpatialReferenceTolerance,u as clip,o as contains,x as convexHull,s as crosses,i as cut,q as densify,y as difference,d as disjoint,c as distance,a as equals,r as extendedSpatialReferenceInfo,E as flipHorizontal,H as flipVertical,I as generalize,P as geodesicArea,L as geodesicBuffer,B as geodesicDensify,k as geodesicLength,A as intersect,F as intersectLinesToPoints,f as intersects,m as isSimple,R as nearestCoordinate,T as nearestVertex,V as nearestVertices,S as offset,w as overlaps,C as planarArea,G as planarLength,h as relate,z as rotate,g as simplify,j as symmetricDifference,l as touches,D as union,p as within};
//# sourceMappingURL=p-1c13ad45.js.map