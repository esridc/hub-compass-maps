import{h as t}from"./p-3013819f.js";import{s as r}from"./p-9a9a9a0b.js";import{g as e}from"./p-5bd0bced.js";import{P as n}from"./p-5dea0c0d.js";import"./p-3b51db5e.js";import"./p-1ed893a0.js";import"./p-53be785a.js";import"./p-10315be7.js";import"./p-5f148c96.js";import"./p-71ed4ac4.js";import"./p-a276ccf5.js";import"./p-9b885976.js";import"./p-897991e6.js";import"./p-7020cf1b.js";class o{async createIndex(t,e){const n=new Array;if(!t.vertexAttributes?.position)return new r;const o=this._createMeshData(t),s=null!=e?await e.invoke("createIndexThread",o,{transferList:n}):this.createIndexThread(o).result;return this._createPooledRBush().fromJSON(s)}createIndexThread(t){const r=new Float64Array(t.position),e=this._createPooledRBush();return t.components?this._createIndexComponentsThread(e,r,t.components.map((t=>new Uint32Array(t)))):this._createIndexAllThread(e,r)}_createIndexAllThread(t,r){const e=new Array(r.length/9);let n=0;for(let t=0;t<r.length;t+=9)e[n++]=s(r,t,t+3,t+6);return t.load(e),{result:t.toJSON()}}_createIndexComponentsThread(t,r,e){let n=0;for(const t of e)n+=t.length/3;const o=new Array(n);let a=0;for(const t of e)for(let e=0;e<t.length;e+=3)o[a++]=s(r,3*t[e],3*t[e+1],3*t[e+2]);return t.load(o),{result:t.toJSON()}}_createMeshData(t){const r=(e(t.vertexSpace)?n({position:t.vertexAttributes.position,normal:null,tangent:null},t.vertexSpace,t.transform,t.spatialReference).position:t.vertexAttributes.position).buffer;return!t.components||t.components.some((t=>!t.faces))?{position:r}:{position:r,components:t.components.map((t=>t.faces))}}_createPooledRBush(){return new r(9,t("esri-csp-restrictions")?t=>t:[".minX",".minY",".maxX",".maxY"])}}function s(t,r,e,n){return{minX:Math.min(t[r],t[e],t[n]),maxX:Math.max(t[r],t[e],t[n]),minY:Math.min(t[r+1],t[e+1],t[n+1]),maxY:Math.max(t[r+1],t[e+1],t[n+1]),p0:[t[r],t[r+1],t[r+2]],p1:[t[e],t[e+1],t[e+2]],p2:[t[n],t[n+1],t[n+2]]}}export default o;
//# sourceMappingURL=p-4f5ef1eb.js.map