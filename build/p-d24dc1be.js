import{cI as t,bt as e}from"./p-028496e2.js";import{y as r}from"./p-043c51d6.js";import{i as n,a as o}from"./p-b7771a23.js";import{n as a,s as i}from"./p-f251e1c8.js";import"./p-a6f5fa00.js";import"./p-7849ca2a.js";import"./p-3b51db5e.js";import"./p-dce44f2c.js";import"./p-b7285ab4.js";import"./p-10315be7.js";import"./p-5f148c96.js";import"./p-897991e6.js";import"./p-3d529d8e.js";import"./p-1a2f7254.js";import"./p-c99b552a.js";import"./p-d6e149e3.js";import"./p-063c1865.js";import"./p-a59232d1.js";var s,c;!function(t){t[t.None=0]="None",t[t.Int16=1]="Int16",t[t.Int32=2]="Int32"}(s||(s={})),function(t){t[t.Replace=0]="Replace",t[t.Outside=1]="Outside",t[t.Inside=2]="Inside",t[t.Finished=3]="Finished"}(c||(c={}));function f(){return u||(u=new Promise((t=>import("./p-26273eea.js").then((t=>t.i)).then((({default:e})=>{const r=e({locateFile:l,onRuntimeInitialized:()=>t(r)});delete r.then})))).catch((t=>{throw t}))),u}function l(e){return t(`esri/libs/i3s/${e}`)}let u;var p,m,d,y,w;!function(t){t[t.Unmodified=0]="Unmodified",t[t.Culled=1]="Culled",t[t.NotChecked=2]="NotChecked"}(p||(p={})),function(t){t[t.Unmodified=0]="Unmodified",t[t.PotentiallyModified=1]="PotentiallyModified",t[t.Culled=2]="Culled",t[t.Unknown=3]="Unknown",t[t.NotChecked=4]="NotChecked"}(m||(m={}));!function(t){t[t.Unknown=0]="Unknown",t[t.Uncached=1]="Uncached",t[t.Cached=2]="Cached"}(d||(d={})),function(t){t[t.None=0]="None",t[t.MaxScreenThreshold=1]="MaxScreenThreshold",t[t.ScreenSpaceRelative=2]="ScreenSpaceRelative",t[t.RemovedFeatureDiameter=3]="RemovedFeatureDiameter",t[t.DistanceRangeFromDefaultCamera=4]="DistanceRangeFromDefaultCamera"}(y||(y={})),function(t){t[t.Hole=0]="Hole",t[t.Leaf=1]="Leaf"}(w||(w={}));async function j(t){U=await O();const e=[t.geometryBuffer];return{result:C(U,t,e),transferList:e}}async function b(t){U=await O();const e=[t.geometryBuffer],{geometryBuffer:r}=t,n=r.byteLength,o=U._malloc(n),a=new Uint8Array(U.HEAPU8.buffer,o,n);a.set(new Uint8Array(r));const i=U.dracoDecompressPointCloudData(o,a.byteLength);if(U._free(o),i.error.length>0)throw new Error(`i3s.wasm: ${i.error}`);const s=i.featureIds?.length>0?i.featureIds.slice():null,c=i.positions.slice();return s&&e.push(s.buffer),e.push(c.buffer),{result:{positions:c,featureIds:s},transferList:e}}async function A(t){await O(),S(t);const e={buffer:t.buffer};return{result:e,transferList:[e.buffer]}}async function F(t){await O(),R(t)}async function g(t){U=await O(),U.setLegacySchema(t.context,t.jsonSchema)}async function h(t){const{localMatrix:a,origin:i,positions:s,vertexSpace:c,localMode:f}=t,l=e.fromJSON(t.inSpatialReference),u=e.fromJSON(t.outSpatialReference);let p;if("georeferenced"===c.type&&null==c.origin){const[{projectBuffer:t},{initializeProjection:e}]=await Promise.all([import("./p-028496e2.js").then((function(t){return t.o2})),import("./p-028496e2.js").then((function(t){return t.o3}))]);await e(l,u),p=new Float64Array(s.length),t(s,l,0,p,u,0,p.length/3)}else{const t="georeferenced"===c.type?n.fromJSON(c):o.fromJSON(c),{project:e}=await import("./p-058cca94.js").then((function(t){return t.g}));p=r(e({positions:s,transform:a?{localMatrix:a}:void 0,vertexSpace:t,inSpatialReference:l,outSpatialReference:u,localMode:f}))}const m=p.length,[d,y,w]=i;for(let t=0;t<m;t+=3)p[t]-=d,p[t+1]-=y,p[t+2]-=w;return{result:{projected:p,original:s},transferList:[p.buffer,s.buffer]}}async function x({normalMatrix:t,normals:e}){const r=new Float32Array(e.length);return a(r,e,t),i(r,r),{result:{transformed:r,original:e},transferList:[r.buffer,e.buffer]}}function v(t){I(t)}let M,U;function R(t){if(!U)return;const e=t.modifications,r=U._malloc(8*e.length),n=new Float64Array(U.HEAPU8.buffer,r,e.length);for(let t=0;t<e.length;++t)n[t]=e[t];U.setModifications(t.context,r,e.length,t.isGeodetic),U._free(r)}function C(t,e,r){const{context:n,localOrigin:o,globalTrafo:a,mbs:i,obbData:c,elevationOffset:f,geometryBuffer:l,geometryDescriptor:u,indexToVertexProjector:p,vertexToRenderProjector:m}=e,d=t._malloc(l.byteLength),y=33,w=t._malloc(y*Float64Array.BYTES_PER_ELEMENT),j=new Uint8Array(t.HEAPU8.buffer,d,l.byteLength);j.set(new Uint8Array(l));const b=new Float64Array(t.HEAPU8.buffer,w,y);L(b,o);let A=b.byteOffset+3*b.BYTES_PER_ELEMENT,F=new Float64Array(b.buffer,A);L(F,a),A+=16*b.BYTES_PER_ELEMENT,F=new Float64Array(b.buffer,A),L(F,i),A+=4*b.BYTES_PER_ELEMENT,c&&(F=new Float64Array(b.buffer,A),L(F,c));const g=u,h={isDraco:!1,isLegacy:!1,color:e.layouts.some((t=>t.some((t=>"color"===t.name)))),normal:e.needNormals&&e.layouts.some((t=>t.some((t=>"normalCompressed"===t.name)))),uv0:e.layouts.some((t=>t.some((t=>"uv0"===t.name)))),uvRegion:e.layouts.some((t=>t.some((t=>"uvRegion"===t.name)))),featureIndex:g.featureIndex},x=t.process(n,!!e.obbData,d,j.byteLength,g,h,w,f,p,m,e.normalReferenceFrame);if(t._free(w),t._free(d),x.error.length>0)throw new Error(`i3s.wasm: ${x.error}`);if(x.discarded)return null;const v=x.componentOffsets.length>0?x.componentOffsets.slice():null,M=x.featureIds.length>0?x.featureIds.slice():null,U=x.anchorIds.length>0?Array.from(x.anchorIds):null,R=x.anchors.length>0?Array.from(x.anchors):null,C=x.interleavedVertedData.slice().buffer,D=x.indicesType===s.Int16?new Uint16Array(x.indices.buffer,x.indices.byteOffset,x.indices.byteLength/2).slice():new Uint32Array(x.indices.buffer,x.indices.byteOffset,x.indices.byteLength/4).slice(),S=x.positions.slice(),I=x.positionIndicesType===s.Int16?new Uint16Array(x.positionIndices.buffer,x.positionIndices.byteOffset,x.positionIndices.byteLength/2).slice():new Uint32Array(x.positionIndices.buffer,x.positionIndices.byteOffset,x.positionIndices.byteLength/4).slice(),P={layout:e.layouts[0],interleavedVertexData:C,indices:D,hasColors:x.hasColors,hasModifications:x.hasModifications,positionData:{data:S,indices:I}};return M&&r.push(M.buffer),v&&r.push(v.buffer),r.push(C),r.push(D.buffer),r.push(S.buffer),r.push(I.buffer),{componentOffsets:v,featureIds:M,anchorIds:U,anchors:R,transformedGeometry:P,obb:x.obb}}function D(t){return 0===t?m.Unmodified:1===t?m.PotentiallyModified:2===t?m.Culled:m.Unknown}function S(t){if(!U)return;const{context:e,buffer:r}=t,n=U._malloc(r.byteLength),o=r.byteLength/Float64Array.BYTES_PER_ELEMENT,a=new Float64Array(U.HEAPU8.buffer,n,o),i=new Float64Array(r);a.set(i),U.filterOBBs(e,n,o),i.set(a),U._free(n)}function I(t){U&&0===U.destroy(t)&&(U=null)}function L(t,e){for(let r=0;r<e.length;++r)t[r]=e[r]}async function P(){U||await O()}function O(){return U?Promise.resolve(U):(M||(M=f().then((t=>(U=t,M=null,U)))),M)}const N={transform:(t,e)=>U&&C(U,t,e),destroy:I};export{v as destroyContext,b as dracoDecompressPointCloudData,A as filterObbsForModifications,S as filterObbsForModificationsSync,P as initialize,D as interpretObbModificationResults,j as process,h as project,g as setLegacySchema,F as setModifications,R as setModificationsSync,N as test,x as transformNormals};
//# sourceMappingURL=p-d24dc1be.js.map