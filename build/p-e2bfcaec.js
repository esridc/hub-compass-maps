import{cp as t,iv as e,mO as n,a0 as s,an as r,ao as o,kY as i,fv as a,fx as l,ap as c,dG as u,lF as h,fw as f,dE as p,c3 as m,e7 as d,s as w,g as y,a as g,M as v,k2 as x,b4 as b,dQ as j,a2 as A,hE as T,cB as M,mP as F,mQ as S,gn as R,id as N,ig as $,dD as P,W as E,av as C,mR as L,mS as D,mT as U,hB as k,V as O,k_ as I,dK as _,ec as z,gv as H,ie as W,is as B,it as V,mU as G,mV as Q,iF as K,iG as X,mW as Y,iH as Z,mX as q,mY as J,iz as tt,k1 as et,as as nt,dh as st,fp as rt,fl as ot,ah as it,az as at,aN as lt,mZ as ct}from"./p-3013819f.js";import{G as ut,c as ht,Q as ft,I as pt,V as mt,_ as dt,d as wt,A as yt,y as gt,k as vt,O as xt,j as bt,h as jt,E as At,a as Tt,b as Mt,e as Ft,w as St}from"./p-5dea0c0d.js";import{c as Rt}from"./p-c60ccdaa.js";import{i as Nt,a as $t}from"./p-1ed893a0.js";import{g as Pt,p as Et,u as Ct,h as Lt,l as Dt}from"./p-5bd0bced.js";import{i as Ut}from"./p-508fdb0a.js";import{e as kt,a as Ot,t as It}from"./p-a276ccf5.js";import{t as _t}from"./p-2e59108c.js";import{e as zt}from"./p-c887d4a8.js";import{X as Ht,F as Wt,E as Bt}from"./p-1f7d3618.js";import"./p-37592f90.js";import{e as Vt}from"./p-5f148c96.js";import"./p-894e6a6a.js";import"./p-c99b552a.js";import{u as Gt,y as Qt,h as Kt}from"./p-4fb66b05.js";import{e as Xt}from"./p-10315be7.js";import{I as Yt}from"./p-9b885976.js";import{e as Zt,o as qt}from"./p-897991e6.js";import{a as Jt,R as te}from"./p-71ed4ac4.js";function ee(s,r,o,i){if(t(s.spatialReference,o)){ne[0]=s.x,ne[1]=s.y;const t=s.z;return ne[2]=t??i??0,e(ne,s.spatialReference,0,r,o,0,1)}const a=n(s,o);return!!a&&(r[0]=a?.x,r[1]=a?.y,r[2]=a?.z??i??0,!0)}const ne=s();var se;const re=new WeakMap;let oe=0,ie=se=class extends u{constructor(t){super(t),this.wrap="repeat"}get url(){return this._get("url")||null}set url(t){this._set("url",t),t&&this._set("data",null)}get data(){return this._get("data")||null}set data(t){this._set("data",t),t&&this._set("url",null)}writeData(t,e,n,s){if(t instanceof HTMLImageElement){const r={type:"image-element",src:h(t.src,s),crossOrigin:t.crossOrigin};e[n]=r}else if(t instanceof HTMLCanvasElement){const s=t.getContext("2d").getImageData(0,0,t.width,t.height),r={type:"canvas-element",imageData:this._encodeImageData(s)};e[n]=r}else if(t instanceof HTMLVideoElement){const r={type:"video-element",src:h(t.src,s),autoplay:t.autoplay,loop:t.loop,muted:t.muted,crossOrigin:t.crossOrigin,preload:t.preload};e[n]=r}else if(t instanceof ImageData){const s={type:"image-data",imageData:this._encodeImageData(t)};e[n]=s}}readData(t){switch(t.type){case"image-element":{const e=new Image;return e.src=t.src,e.crossOrigin=t.crossOrigin,e}case"canvas-element":{const e=this._decodeImageData(t.imageData),n=document.createElement("canvas");return n.width=e.width,n.height=e.height,n.getContext("2d").putImageData(e,0,0),n}case"image-data":return this._decodeImageData(t.imageData);case"video-element":{const e=document.createElement("video");return e.src=t.src,e.crossOrigin=t.crossOrigin,e.autoplay=t.autoplay,e.loop=t.loop,e.muted=t.muted,e.preload=t.preload,e}default:return}}get transparent(){const t=this.data,e=this.url;if(t instanceof HTMLCanvasElement)return this._imageDataContainsTransparent(t.getContext("2d").getImageData(0,0,t.width,t.height));if(t instanceof ImageData)return this._imageDataContainsTransparent(t);if(e){const t=e.substr(e.length-4,4).toLowerCase(),n=e.substr(0,15).toLocaleLowerCase();if(".png"===t||"data:image/png;"===n)return!0}return!1}set transparent(t){this._overrideIfSome("transparent",t)}get contentHash(){const t="string"==typeof this.wrap?this.wrap:"object"==typeof this.wrap?`${this.wrap.horizontal}/${this.wrap.vertical}`:"",e=(e="")=>`d:${e},t:${this.transparent},w:${t}`;return null!=this.url?e(this.url):null!=this.data?this.data instanceof HTMLImageElement||this.data instanceof HTMLVideoElement?e(this.data.src):(re.has(this.data)||re.set(this.data,++oe),e(re.get(this.data))):e()}get memoryUsage(){let t=0;if(t+=null!=this.url?this.url.length:0,null!=this.data){const e=this.data;"data"in e?t+=e.data.byteLength:e instanceof HTMLImageElement?t+=e.naturalWidth*e.naturalHeight*3:e instanceof HTMLCanvasElement&&(t+=e.width*e.height*3)}return t}clone(){const t={url:this.url,data:this.data,wrap:this._cloneWrap()};return new se(t)}cloneWithDeduplication(t){const e=t.get(this);if(e)return e;const n=this.clone();return t.set(this,n),n}_cloneWrap(){return"string"==typeof this.wrap?this.wrap:{horizontal:this.wrap.horizontal,vertical:this.wrap.vertical}}_encodeImageData(t){let e="";for(let n=0;n<t.data.length;n++)e+=String.fromCharCode(t.data[n]);return{data:btoa(e),width:t.width,height:t.height}}_decodeImageData(t){const e=atob(t.data),n=new Uint8ClampedArray(e.length);for(let t=0;t<e.length;t++)n[t]=e.charCodeAt(t);return Rt(n,t.width,t.height)}_imageDataContainsTransparent(t){for(let e=3;e<t.data.length;e+=4)if(255!==t.data[e])return!0;return!1}static from(t){return"string"==typeof t?new se({url:t}):t instanceof HTMLImageElement||t instanceof HTMLCanvasElement||t instanceof ImageData||t instanceof HTMLVideoElement?new se({data:t}):f(se,t)}};r([o({type:String,json:{write:i}})],ie.prototype,"url",null),r([o({json:{write:{overridePolicy(){return{enabled:!this.url}}}}}),o()],ie.prototype,"data",null),r([a("data")],ie.prototype,"writeData",null),r([l("data")],ie.prototype,"readData",null),r([o({type:Boolean,json:{write:{overridePolicy(){return{enabled:this._isOverridden("transparent")}}}}})],ie.prototype,"transparent",null),r([o({json:{write:!0}})],ie.prototype,"wrap",void 0),r([o({readOnly:!0})],ie.prototype,"contentHash",null),ie=se=r([c("esri.geometry.support.MeshTexture")],ie);const ae=ie;let le=class extends(p(u)){constructor(t){super(t),this.offset=[0,0],this.rotation=0,this.scale=[1,1]}};r([o({type:[Number],nonNullable:!0,json:{write:!0}})],le.prototype,"offset",void 0),r([o({type:Number,nonNullable:!0,json:{write:!0}})],le.prototype,"rotation",void 0),r([o({type:[Number],nonNullable:!0,json:{write:!0}})],le.prototype,"scale",void 0),le=r([c("esri.geometry.support.MeshTextureTransform")],le);const ce=le;var ue;let he=ue=class extends u{constructor(t){super(t),this.color=null,this.colorTexture=null,this.colorTextureTransform=null,this.normalTexture=void 0,this.normalTextureTransform=void 0,this.alphaMode="auto",this.alphaCutoff=.5,this.doubleSided=!0}clone(){return this.cloneWithDeduplication(null,new Map)}cloneWithDeduplication(t,e){const n=null!=t?t.get(this):null;if(n)return n;const s=new ue(this.clonePropertiesWithDeduplication(e));return null!=t&&t.set(this,s),s}clonePropertiesWithDeduplication(t){return{color:null!=this.color?this.color.clone():null,colorTexture:this.colorTexture?.cloneWithDeduplication(t),normalTexture:this.normalTexture?.cloneWithDeduplication(t),alphaMode:this.alphaMode,alphaCutoff:this.alphaCutoff,doubleSided:this.doubleSided,colorTextureTransform:this.colorTextureTransform?.clone(),normalTextureTransform:this.normalTextureTransform?.clone()}}get memoryUsage(){return this.getMemoryUsage()}getMemoryUsage(){let t=0;return t+=null!=this.color?16:0,null!=this.colorTexture&&(t+=this.colorTexture.memoryUsage),t+=null!=this.colorTextureTransform?20:0,null!=this.normalTexture&&(t+=this.normalTexture.memoryUsage),t+=null!=this.normalTextureTransform?20:0,t}};r([o({type:m,json:{write:!0}})],he.prototype,"color",void 0),r([o({type:ae,json:{write:!0}})],he.prototype,"colorTexture",void 0),r([o({type:ce,json:{write:!0}})],he.prototype,"colorTextureTransform",void 0),r([o({type:ae,json:{write:!0}})],he.prototype,"normalTexture",void 0),r([o({type:ce,json:{write:!0}})],he.prototype,"normalTextureTransform",void 0),r([o({nonNullable:!0,json:{write:!0}})],he.prototype,"alphaMode",void 0),r([o({nonNullable:!0,json:{write:!0}})],he.prototype,"alphaCutoff",void 0),r([o({nonNullable:!0,json:{write:!0}})],he.prototype,"doubleSided",void 0),he=ue=r([c("esri.geometry.support.MeshMaterial")],he);const fe=he;var pe;let me=pe=class extends fe{constructor(t){super(t),this.emissiveColor=null,this.emissiveTexture=null,this.emissiveTextureTransform=void 0,this.occlusionTexture=null,this.occlusionTextureTransform=void 0,this.metallic=1,this.roughness=1,this.metallicRoughnessTexture=null,this.metallicRoughnessTextureTransform=void 0}clone(){return this.cloneWithDeduplication(null,new Map)}cloneWithDeduplication(t,e){const n=null!=t?t.get(this):null;if(n)return n;const s=new pe(this.clonePropertiesWithDeduplication(e));return null!=t&&t.set(this,s),s}getMemoryUsage(){let t=super.getMemoryUsage();return t+=null!=this.emissiveColor?16:0,null!=this.emissiveTexture&&(t+=this.emissiveTexture.memoryUsage),t+=null!=this.emissiveTextureTransform?20:0,null!=this.occlusionTexture&&(t+=this.occlusionTexture.memoryUsage),t+=null!=this.occlusionTextureTransform?20:0,null!=this.metallicRoughnessTexture&&(t+=this.metallicRoughnessTexture.memoryUsage),t+=null!=this.metallicRoughnessTextureTransform?20:0,t}clonePropertiesWithDeduplication(t){return{...super.clonePropertiesWithDeduplication(t),emissiveColor:this.emissiveColor?.clone(),emissiveTexture:this.emissiveTexture?.cloneWithDeduplication(t),emissiveTextureTransform:this.emissiveTextureTransform?.clone(),occlusionTexture:this.occlusionTexture?.cloneWithDeduplication(t),occlusionTextureTransform:this.occlusionTextureTransform?.clone(),metallic:this.metallic,roughness:this.roughness,metallicRoughnessTexture:this.metallicRoughnessTexture?.cloneWithDeduplication(t),metallicRoughnessTextureTransform:this.metallicRoughnessTextureTransform?.clone()}}};r([o({type:m,json:{write:!0}})],me.prototype,"emissiveColor",void 0),r([o({type:ae,json:{write:!0}})],me.prototype,"emissiveTexture",void 0),r([o({type:ce,json:{write:!0}})],me.prototype,"emissiveTextureTransform",void 0),r([o({type:ae,json:{write:!0}})],me.prototype,"occlusionTexture",void 0),r([o({type:ce,json:{write:!0}})],me.prototype,"occlusionTextureTransform",void 0),r([o({type:Number,nonNullable:!0,json:{write:!0},range:{min:0,max:1}})],me.prototype,"metallic",void 0),r([o({type:Number,nonNullable:!0,json:{write:!0},range:{min:0,max:1}})],me.prototype,"roughness",void 0),r([o({type:ae,json:{write:!0}})],me.prototype,"metallicRoughnessTexture",void 0),r([o({type:ce,json:{write:!0}})],me.prototype,"metallicRoughnessTextureTransform",void 0),me=pe=r([c("esri.geometry.support.MeshMaterialMetallicRoughness")],me);const de=me;var we;let ye=we=class extends u{constructor(t){super(t),this.color=null,this.position=new Float64Array(0),this.uv=null,this.normal=null,this.tangent=null}castColor(t){return ve(t,Uint8Array,[Uint8ClampedArray],{loggerTag:".color=",stride:4},w.getLogger(this))}castPosition(t){t&&t instanceof Float32Array&&w.getLogger(this).warn(".position=","Setting position attribute from a Float32Array may cause precision problems. Consider storing data in a Float64Array or a regular number array");return ve(t,Float64Array,[Float32Array],{loggerTag:".position=",stride:3},w.getLogger(this))}castUv(t){return ve(t,Float32Array,[Float64Array],{loggerTag:".uv=",stride:2},w.getLogger(this))}castNormal(t){return ve(t,Float32Array,[Float64Array],{loggerTag:".normal=",stride:3},w.getLogger(this))}castTangent(t){return ve(t,Float32Array,[Float64Array],{loggerTag:".tangent=",stride:4},w.getLogger(this))}clone(){const t={position:y(this.position),uv:y(this.uv),normal:y(this.normal),tangent:y(this.tangent),color:y(this.color)};return new we(t)}clonePositional(){const t={position:y(this.position),normal:y(this.normal),tangent:y(this.tangent),uv:this.uv,color:this.color};return new we(t)}get memoryUsage(){let t=0;return t+=this.position.byteLength,null!=this.uv&&(t+=this.uv.byteLength),null!=this.normal&&(t+=this.normal.byteLength),null!=this.tangent&&(t+=this.tangent.byteLength),null!=this.color&&(t+=this.color.byteLength),t}};function ge(t,e,n,s){const{loggerTag:r,stride:o}=e;return t.length%o!=0?(s.error(r,`Invalid array length, expected a multiple of ${o}`),new n([])):t}function ve(t,e,n,s,r){if(!t)return t;if(t instanceof e)return ge(t,s,e,r);for(const o of n)if(t instanceof o)return ge(new e(t),s,e,r);if(Array.isArray(t))return ge(new e(t),s,e,r);{const s=n.map((t=>`'${t.name}'`));return r.error(`Failed to set property, expected one of ${s}, but got ${t.constructor.name}`),new e([])}}function xe(t,e,n){e[n]=be(t)}function be(t){const e=new Array(t.length);for(let n=0;n<t.length;n++)e[n]=t[n];return e}r([o({json:{write:xe}})],ye.prototype,"color",void 0),r([d("color")],ye.prototype,"castColor",null),r([o({nonNullable:!0,json:{write:xe}})],ye.prototype,"position",void 0),r([d("position")],ye.prototype,"castPosition",null),r([o({json:{write:xe}})],ye.prototype,"uv",void 0),r([d("uv")],ye.prototype,"castUv",null),r([o({json:{write:xe}})],ye.prototype,"normal",void 0),r([d("normal")],ye.prototype,"castNormal",null),r([o({json:{write:xe}})],ye.prototype,"tangent",void 0),r([d("tangent")],ye.prototype,"castTangent",null),ye=we=r([c("esri.geometry.support.MeshVertexAttributes")],ye);var je;let Ae=je=class extends u{static from(t){return f(je,t)}constructor(t){super(t),this.faces=null,this.material=null,this.name=void 0,this.shading="source",this.trustSourceNormals=!1}castFaces(t){return ve(t,Uint32Array,[Uint16Array],{loggerTag:".faces=",stride:3},w.getLogger(this))}castMaterial(t){return f(t&&"object"==typeof t&&("metallic"in t||"roughness"in t||"metallicRoughnessTexture"in t)?de:fe,t)}clone(){return new je({faces:y(this.faces),shading:this.shading,material:y(this.material),trustSourceNormals:this.trustSourceNormals,name:this.name})}cloneWithDeduplication(t,e){const n={faces:y(this.faces),shading:this.shading,material:this.material?this.material.cloneWithDeduplication(t,e):null,trustSourceNormals:this.trustSourceNormals,name:this.name};return new je(n)}get memoryUsage(){let t=0;return null!=this.faces&&(t+=this.faces.byteLength),null!=this.material&&(t+=this.material.memoryUsage),t}};r([o({json:{write:!0}})],Ae.prototype,"faces",void 0),r([d("faces")],Ae.prototype,"castFaces",null),r([o({type:fe,json:{write:!0}})],Ae.prototype,"material",void 0),r([d("material")],Ae.prototype,"castMaterial",null),r([o()],Ae.prototype,"name",void 0),r([o({type:String,json:{write:!0}})],Ae.prototype,"shading",void 0),r([o({type:Boolean})],Ae.prototype,"trustSourceNormals",void 0),Ae=je=r([c("esri.geometry.support.MeshComponent")],Ae);const Te=Ae;const Me="Mesh must be loaded before applying operations",Fe="Provided component is not part of the list of components",Se="Expected polygon to be a Polygon instance",Re="Expected location to be a Point instance";class Ne extends g{constructor(){super("invalid-input:location",Re)}}function $e(t,e,n,s){const r=(t=>!Array.isArray(t[0]))(e)?(t,n)=>e[3*t+n]:(t,n)=>e[t][n],o=s?b(s)/j(s):1;return Ht(t,((t,e)=>A(t,r(e,0)*o,r(e,1)*o,r(e,2))),n)}function Pe(t,e,n){const s=$e(Ee,t,e,n)?Wt(Ee):[0,0,1];return Math.abs(s[2])>Math.cos(v(80))?x.Z:Math.abs(s[1])>Math.abs(s[0])?x.Y:x.X}const Ee=Bt();function Ce(t){const e=De(t.rings,t.hasZ,Oe.CCW_IS_HOLE,t.spatialReference),n=new Array;let s=0,r=0;for(const t of e.polygons){const o=t.count,i=t.index,a=Ot(e.position,3*i,3*o),l=t.holeIndices.map((t=>t-i)),c=_t(Ut(a,l,3));n.push({position:a,faces:c}),s+=a.length,r+=c.length}const o=Le(n,s,r),i=Array.isArray(o.position)?zt(o.position,3,{originalIndices:o.faces}):zt(o.position.buffer,6,{originalIndices:o.faces});return o.position=kt(new Float64Array(i.buffer)),o.faces=i.indices,o}function Le(t,e,n){if(1===t.length)return t[0];const s=It(e),r=new Array(n);let o=0,i=0,a=0;for(const e of t){for(let t=0;t<e.position.length;t++)s[o++]=e.position[t];for(const t of e.faces)r[i++]=t+a;a=o/3}return{position:s,faces:_t(r)}}function De(t,e,n,s){const r=t.length,o=new Array(r),i=new Array(r),a=new Array(r);let l=0,c=0,u=0,h=0;for(let e=0;e<r;++e)h+=t[e].length;const f=It(3*h);let p=0;for(let h=r-1;h>=0;h--){const m=t[h],d=n===Oe.CCW_IS_HOLE&&ke(m,e,s);if(d&&1!==r)o[l++]=m;else{let t=m.length;for(let e=0;e<l;++e)t+=o[e].length;const n={index:p,pathLengths:new Array(l+1),count:t,holeIndices:new Array(l)};n.pathLengths[0]=m.length,m.length>0&&(a[u++]={index:p,count:m.length}),p=d?Ue(m,m.length-1,-1,f,p,m.length,e):Ue(m,0,1,f,p,m.length,e);for(let t=0;t<l;++t){const s=o[t];n.holeIndices[t]=p,n.pathLengths[t+1]=s.length,s.length>0&&(a[u++]={index:p,count:s.length}),p=Ue(s,0,1,f,p,s.length,e)}l=0,n.count>0&&(i[c++]=n)}}for(let t=0;t<l;++t){const n=o[t];n.length>0&&(a[u++]={index:p,count:n.length}),p=Ue(n,0,1,f,p,n.length,e)}return i.length=c,a.length=u,{position:f,polygons:i,outlines:a}}function Ue(t,e,n,s,r,o,i){r*=3;for(let a=0;a<o;++a){const o=t[e];s[r++]=o[0],s[r++]=o[1],s[r++]=i?o[2]:0,e+=n}return r/3}function ke(t,e,n){if(e){const e=t.length-1,s=Pe(t,e,n);if(s===x.X)return!T(t,x.Y,x.Z);if(s===x.Y)return!T(t,x.X,x.Z)}return!T(t,x.X,x.Y)}var Oe;!function(t){t[t.NONE=0]="NONE",t[t.CCW_IS_HOLE=1]="CCW_IS_HOLE"}(Oe||(Oe={}));function Ie([t,e,n,s,r,o],i,a,l){_e??=new Float64Array(24);const c=_e;return c[0]=t,c[1]=e,c[2]=n,c[3]=t,c[4]=r,c[5]=n,c[6]=s,c[7]=r,c[8]=n,c[9]=s,c[10]=e,c[11]=n,c[12]=t,c[13]=e,c[14]=o,c[15]=t,c[16]=r,c[17]=o,c[18]=s,c[19]=r,c[20]=o,c[21]=s,c[22]=e,c[23]=o,ut({positions:c,transform:i,vertexSpace:a,inSpatialReference:l,outSpatialReference:l,outPositions:c}),He(c,l)}let _e=null;function ze(t){if(0===t.length)return F;const e=R([Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,-Number.POSITIVE_INFINITY,-Number.POSITIVE_INFINITY,-Number.POSITIVE_INFINITY]);return S(e,t),e}function He(t,e){const[n,s,r,o,i,a]=ze(t);return new M({xmin:n,ymin:s,zmin:r,xmax:o,ymax:i,zmax:a,spatialReference:e})}const We="esri.geometry.support.meshUtils.centerAt";function Be(t,e,n){if(!t.vertexAttributes?.position)return;const{vertexSpace:s}=t,r=n?.origin??t.anchor,o=n?.geographic,i=ht(We,s,r.spatialReference,o);Pt(s)?Ve(t,e,r):i?Ge(t,e,r):Qe(t,e,r)}function Ve(t,e,n){const{vertexSpace:r}=t;if(!Pt(r))return;const o=Ye,i=Xe;if(!ee(e,i,t.spatialReference))return void w.getLogger(We).error(`Failed to project centerAt location (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`);if(!ee(n,o,t.spatialReference)){const e=t.origin;o[0]=e.x,o[1]=e.y,o[2]=e.z,w.getLogger(We).error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}const a=N(Ze,i,o);r.origin=$(s(),r.origin,a)}function Ge(t,e,n){const s=ft(t.vertexAttributes,n),{position:r,normal:o,tangent:i}=pt(s,e,!1);t.vertexAttributes.position=r,t.vertexAttributes.normal=o,t.vertexAttributes.tangent=i,t.vertexAttributesChanged()}function Qe(t,e,n){const s=Ye,r=Xe;if(ee(e,r,t.spatialReference)){if(!ee(n,s,t.spatialReference)){const e=t.origin;s[0]=e.x,s[1]=e.y,s[2]=e.z,w.getLogger(We).error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}Ke(t.vertexAttributes.position,r,s),t.vertexAttributesChanged()}else w.getLogger(We).error(`Failed to project centerAt location (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}function Ke(t,e,n){if(t)for(let s=0;s<t.length;s+=3)for(let r=0;r<3;r++)t[s+r]+=e[r]-n[r]}const Xe=s(),Ye=s(),Ze=s();async function qe(t,e,n){const{source:s}=e,{loadGLTFMesh:r}=await P(import("./p-20cd3b33.js"),n),o=await tn(s,n);E(n);const i=r(new C({x:0,y:0,z:0,spatialReference:t.spatialReference}),o.url,{resolveFile:Je(o),signal:n?.signal,expectedType:o.type});i.then((()=>o.dispose()),(()=>o.dispose()));const{vertexAttributes:a,components:l}=await i;t.vertexAttributes=a,t.components=l}function Je(t){const e=D(t.url);return n=>{const s=L(n,e,e),r=s?s.replace(/^ *\.\//,""):null;return(r?t.files.get(r):null)??n}}async function tn(t,e){if(Array.isArray(t)){if(!t.length)throw new g("mesh-load-external:missing-assets","There must be at least one file to load");return t[0]instanceof File?sn(t):rn(t,e)}return nn(t)}async function en(t,e){const{parts:n,assetMimeType:s,assetName:r}=t;if(1===n.length)return new hn(n[0].partUrl);const o=await t.toBlob(e);return E(e),hn.fromBlob(o,fn(r,s))}function nn(t){return hn.fromBlob(t,fn(t.name,t.type))}function sn(t){return un(t.map((t=>({name:t.name,mimeType:t.type,source:nn(t)}))))}async function rn(t,e){const n=await U(t.map((async t=>{const n=await en(t);return E(e),{name:t.assetName,mimeType:t.assetMimeType,source:n}})));if(k(e))throw n.forEach((t=>t.source.dispose())),O();return un(n)}const on=/^model\/gltf\+json$/,an=/^model\/gltf-binary$/,ln=/\.gltf$/i,cn=/\.glb$/i;function un(t){const e=new Map;let n,s=null;for(const{name:r,mimeType:o,source:i}of t)null===s&&(on.test(o)||ln.test(r)?(s=i.url,n="gltf"):(an.test(o)||cn.test(r))&&(s=i.url,n="glb")),e.set(r,i.url),i.files.forEach(((t,n)=>e.set(n,t)));if(null==s)throw new g("mesh-load-external:missing-files","Missing files to load external mesh source");return new hn(s,(()=>t.forEach((({source:t})=>t.dispose()))),e,n)}class hn{constructor(t,e=(()=>{}),n=new Map,s){this.url=t,this.dispose=e,this.files=n,this.type=s}static fromBlob(t,e){const n=URL.createObjectURL(t);return new hn(n,(()=>URL.revokeObjectURL(n)),void 0,e)}}function fn(t,e){return on.test(e)||ln.test(t)?"gltf":an.test(e)||ln.test(t)?"glb":void 0}let pn=class extends I{constructor(){super(),this.externalSources=new _,this._explicitDisplaySource=null,this.addHandles(z((()=>this.externalSources),"after-remove",(({item:t})=>{t===this._explicitDisplaySource&&(this._explicitDisplaySource=null)}),{sync:!0,onListenerRemove:()=>this._explicitDisplaySource=null}))}get displaySource(){return this._explicitDisplaySource??this._implicitDisplaySource}set displaySource(t){if(null!=t&&!Gt(t))throw new Error("Cannot use this source for display: it is not in a supported format.");this._explicitDisplaySource=t,t&&this.externalSources.every((e=>!Qt(e,t)))&&this.externalSources.add(t)}clearSources(){this.externalSources.removeAll()}getExternalSourcesOnService(t){return this.externalSources.items.filter((e=>Kt(e,t)))}get _implicitDisplaySource(){return this.externalSources.find(Gt)}};r([o()],pn.prototype,"externalSources",void 0),r([o()],pn.prototype,"displaySource",null),r([o()],pn.prototype,"_implicitDisplaySource",null),r([o()],pn.prototype,"_explicitDisplaySource",void 0),pn=r([c("esri.geometry.support.meshUtils.Metadata")],pn);function mn(){const{faceDescriptions:t,faceVertexOffsets:e,uvScales:n}=Rn,s=4*t.length,r=new Float64Array(3*s),o=new Float32Array(3*s),i=new Float32Array(2*s),a=new Uint32Array(2*t.length*3);let l=0,c=0,u=0,h=0;for(let s=0;s<t.length;s++){const f=t[s],p=l/3;for(const t of e)a[h++]=p+t;const m=f.corners;for(let t=0;t<4;t++){const e=m[t];let s=0;i[u++]=.25*n[t][0]+f.uvOrigin[0],i[u++]=f.uvOrigin[1]-.25*n[t][1];for(let t=0;t<3;t++)0!==f.axis[t]?(r[l++]=.5*f.axis[t],o[c++]=f.axis[t]):(r[l++]=.5*e[s++],o[c++]=0)}}return{position:r,normal:o,uv:i,faces:a}}function dn(t,e){const n=t.components[0],s=n.faces,r=Nn[e],o=6*r,i=new Array(6),a=new Array(s.length-6);let l=0,c=0;for(let t=0;t<s.length;t++)t>=o&&t<o+6?i[l++]=s[t]:a[c++]=s[t];if(null!=t.vertexAttributes.uv){const e=new Float32Array(t.vertexAttributes.uv),n=4*r*2,s=[0,1,1,1,1,0,0,0];for(let t=0;t<s.length;t++)e[n+t]=s[t];t.vertexAttributes.uv=e}return t.components=[new Te({faces:i,material:n.material}),new Te({faces:a})],t}function wn(t=0){const e=Math.round(8*2**t),n=2*e,s=(e-1)*(n+1)+2*n,r=new Float64Array(3*s),o=new Float32Array(3*s),i=new Float32Array(2*s),a=new Uint32Array(3*((e-1)*n*2));let l=0,c=0,u=0,h=0;for(let t=0;t<=e;t++){const s=t/e*Math.PI+.5*Math.PI,f=Math.cos(s),p=Math.sin(s);$n[2]=p;const m=0===t||t===e,d=m?n-1:n;for(let s=0;s<=d;s++){const p=s/d*2*Math.PI;$n[0]=-Math.sin(p)*f,$n[1]=Math.cos(p)*f;for(let t=0;t<3;t++)r[l]=.5*$n[t],o[l]=$n[t],++l;i[c++]=(s+(m?.5:0))/n,i[c++]=t/e,0!==t&&s!==n&&(t!==e&&(a[u++]=h,a[u++]=h+1,a[u++]=h-n),1!==t&&(a[u++]=h,a[u++]=h-n,a[u++]=h-n-1)),h++}}return{position:r,normal:o,uv:i,faces:a}}function yn(t=0){const e=5,n=Math.round(16*2**t),s=(e-1)*(n+1)+2*n,r=new Float64Array(3*s),o=new Float32Array(3*s),i=new Float32Array(2*s),a=new Uint32Array(3*(4*n));let l=0,c=0,u=0,h=0,f=0;for(let t=0;t<=e;t++){const s=0===t||t===e,p=t<=1||t>=e-1,m=2===t||4===t,d=s?n-1:n;for(let w=0;w<=d;w++){const y=w/d*2*Math.PI,g=s?0:.5;$n[0]=g*Math.sin(y),$n[1]=g*-Math.cos(y),$n[2]=t<=2?.5:-.5;for(let e=0;e<3;e++)r[l++]=$n[e],o[c++]=p?2===e?t<=1?1:-1:0:2===e?0:$n[e]/g;i[u++]=(w+(s?.5:0))/n,i[u++]=t<=1?1*t/3:t<=3?1*(t-2)/3+1/3:1*(t-4)/3+2/3,m||0===t||w===n||(t!==e&&(a[h++]=f,a[h++]=f+1,a[h++]=f-n),1!==t&&(a[h++]=f,a[h++]=f-n,a[h++]=f-n-1)),f++}}return{position:r,normal:o,uv:i,faces:a}}function gn(t,e){const n="number"==typeof e?e:null!=e?e.width:1,s="number"==typeof e?e:null!=e?e.height:1;switch(t){case"up":case"down":return{width:n,depth:s};case"north":case"south":return{width:n,height:s};case"east":case"west":return{depth:n,height:s}}}function vn(t){const e=An.facingAxisOrderSwap[t],n=An.position,s=An.normal,r=new Float64Array(n.length),o=new Float32Array(s.length);let i=0;for(let t=0;t<4;t++){const t=i;for(let a=0;a<3;a++){const l=e[a],c=Math.abs(l)-1,u=l>=0?1:-1;r[i]=n[t+c]*u,o[i]=s[t+c]*u,i++}}return{position:r,normal:o,uv:new Float32Array(An.uv),faces:new Uint32Array(An.faces),isPlane:!0}}const xn=1,bn=2,jn=3,An={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[jn,xn,bn],west:[-jn,-xn,bn],north:[-xn,jn,bn],south:[xn,-jn,bn],up:[xn,bn,jn],down:[xn,-bn,-jn]}};function Tn(t,e,n){t.isPlane||Mn(t),Sn(t,Fn(n?.size,n?.unit,e.spatialReference));const{vertexAttributes:s,vertexSpace:r,transform:o}=mt(t,e,{vertexSpace:n?.vertexSpace,geographic:n?.geographic});return{vertexAttributes:new ye({...s,uv:t.uv}),vertexSpace:r,transform:o,components:[new Te({faces:t.faces,material:n?.material||null})],spatialReference:e.spatialReference}}function Mn(t){for(let e=0;e<t.position.length;e+=3)t.position[e+2]+=.5}function Fn(t,e,n){const s=dt(e,n);if(null==t&&1===s)return null;if(null==t)return[s,s,s];if("number"==typeof t){const e=t*s;return[e,e,e]}return[null!=t.width?t.width*s:s,null!=t.depth?t.depth*s:s,null!=t.height?t.height*s:s]}function Sn(t,e){if(null!=e){Pn[0]=e[0],Pn[4]=e[1],Pn[8]=e[2];for(let e=0;e<t.position.length;e+=3){for(let n=0;n<3;n++)$n[n]=t.position[e+n];H($n,$n,Pn);for(let n=0;n<3;n++)t.position[e+n]=$n[n]}if(e[0]!==e[1]||e[1]!==e[2]){Pn[0]=1/e[0],Pn[4]=1/e[1],Pn[8]=1/e[2];for(let e=0;e<t.normal.length;e+=3){for(let n=0;n<3;n++)$n[n]=t.normal[e+n];H($n,$n,Pn),W($n,$n);for(let n=0;n<3;n++)t.normal[e+n]=$n[n]}}}}const Rn={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},Nn={south:0,east:1,north:2,west:3,up:4,down:5},$n=s(),Pn=Xt();function En(t,e,{vertexSpace:n,spatialReference:s}){if("georeferenced"===n.type){const r=t;if(!ee(e,r,s))return!1;const{origin:o}=n;return N(t,r,o),!0}const r=Jt(s),o=t;if(!ee(e,o,r))return!1;const{origin:i}=n,a=Cn;if(!te(s,i,a,r))return!1;const l=B(Cn,a);return null!=l&&(V(t,o,l),!0)}const Cn=Vt();const Ln="esri.geometry.support.meshUtils.rotate";function Dn(t,e,n){if(!t.vertexAttributes?.position||0===e[3])return;const{spatialReference:s,vertexSpace:r}=t,o=n?.origin??t.anchor,i=n?.geographic,a=ht(Ln,r,s,i);Et(t)?Un(t,e,o):a?kn(t,e,o):On(t,e,o)}function Un(t,e,n){t.transform??=new wt;const{vertexSpace:r,transform:o,spatialReference:i}=t,[a,l,c]=r.origin,u=new C({x:a,y:l,z:c,spatialReference:i}),h=_n;if(u.equals(n))A(h,0,0,0);else if(!En(h,n,t))return void w.getLogger(Ln).error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh (wkid:${i.wkid}) ${r.type} vertex space. Projection may be possible after calling projection.load().`);Yt(Gn,gt(e),yt(e));const f=G(zn,Gn,K,Q,h),{localMatrix:p}=o,m=X(zn,f,p);o.scale=Y(s(),m),Z(m,m,q(_n,o.scale)),o.rotation=vt(m),o.translation=J(s(),m)}function kn(t,e,n){const s=t.spatialReference,r=Jt(s),o=Vn;ee(n,o,r)||ee(t.origin,o,r);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,l=t.vertexAttributes.tangent,c=new Float64Array(i.length),u=null!=a?new Float32Array(a.length):null,h=null!=l?new Float32Array(l.length):null;te(r,o,Wn,r),tt(Bn,Wn);const f=Hn;H(gt(Hn),gt(e),Bn),f[3]=e[3],xt(i,s,c),null!=a&&null!=u&&bt(a,i,c,s,u),null!=l&&null!=h&&jt(l,i,c,s,h),In(c,f,3,o),At(c,i,s),null!=a&&null!=u&&(In(u,f,3),Tt(u,i,c,s,a)),null!=l&&null!=h&&(In(h,f,4),Mt(h,i,c,s,l)),t.vertexAttributesChanged()}function On(t,e,n){const s=Vn;if(!ee(n,s,t.spatialReference)){const e=t.origin;s[0]=e.x,s[1]=e.y,s[2]=e.z,w.getLogger(Ln).error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}In(t.vertexAttributes.position,e,3,s),In(t.vertexAttributes.normal,e,3),In(t.vertexAttributes.tangent,e,4),t.vertexAttributesChanged()}function In(t,e,n,s=K){if(null!=t){et(Wn,yt(e),gt(e));for(let e=0;e<t.length;e+=n){for(let n=0;n<3;n++)_n[n]=t[e+n]-s[n];V(_n,_n,Wn);for(let n=0;n<3;n++)t[e+n]=_n[n]+s[n]}}}const _n=s(),zn=Vt(),Hn=Ft(),Wn=Vt(),Bn=Xt(),Vn=s(),Gn=Zt();const Qn="esri.geometry.support.meshUtils.scale";function Kn(t,e,n){if(!t.vertexAttributes?.position)return;const{vertexSpace:s,spatialReference:r}=t,o=n?.origin??t.anchor,i=n?.geographic,a=ht(Qn,s,r,i);Et(t)?Xn(t,e,o):a?Yn(t,e,o):Zn(t,e,o)}function Xn(t,e,n){t.transform??=new wt;const{vertexSpace:r,transform:o,spatialReference:i}=t,[a,l,c]=r.origin,u=new C({x:a,y:l,z:c,spatialReference:i}),h=Jn;if(u.equals(n))A(h,0,0,0);else if(!En(h,n,t))return void w.getLogger(Qn).error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh (wkid:${i.wkid}) ${r.type} vertex space. Projection may be possible after calling projection.load().`);const f=A(ts,e,e,e),p=G(es,qt,K,f,h),{localMatrix:m}=o,d=X(es,p,m);o.scale=Y(s(),d),Z(d,d,q(Jn,o.scale)),o.rotation=vt(d),o.translation=J(s(),d)}function Yn(t,e,n){const s=t.spatialReference,r=Jt(s),o=ns;ee(n,o,r)||ee(t.origin,o,r);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,l=t.vertexAttributes.tangent,c=new Float64Array(i.length),u=null!=a?new Float32Array(a.length):null,h=null!=l?new Float32Array(l.length):null;xt(i,s,c),null!=a&&null!=u&&bt(a,i,c,s,u),null!=l&&null!=h&&jt(l,i,c,s,h),qn(c,e,o),At(c,i,s),null!=a&&null!=u&&Tt(u,i,c,s,a),null!=l&&null!=h&&Mt(h,i,c,s,l),t.vertexAttributesChanged()}function Zn(t,e,n){const s=ns;if(!ee(n,s,t.spatialReference)){const e=t.origin;s[0]=e.x,s[1]=e.y,s[2]=e.z,w.getLogger(Qn).error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}qn(t.vertexAttributes.position,e,s),t.vertexAttributesChanged()}function qn(t,e,n=K){if(t)for(let s=0;s<t.length;s+=3){for(let e=0;e<3;e++)Jn[e]=t[s+e]-n[e];nt(Jn,Jn,e);for(let e=0;e<3;e++)t[s+e]=Jn[e]+n[e]}}const Jn=s(),ts=s(),es=Vt(),ns=s();var ss;const rs="esri.geometry.Mesh";function os(){return w.getLogger(rs)}const is={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:Nt,local:$t}};let as=ss=class extends(st.LoadableMixin(rt(ot))){constructor(t){super(t),this.components=null,this.vertexSpace=new Nt,this.transform=null,this.metadata=new pn,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new ye,this.type="mesh"}initialize(){(0===this.metadata.externalSources.length||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.addHandles(it((()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map((t=>t.clone()))})),(()=>this._clearSources()),{once:!0,sync:!0}))}))}get hasExtent(){return this.loaded?this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0):null!=this.metadata.displaySource?.extent}get _transformedExtent(){const{components:t,spatialReference:e,vertexAttributes:n,vertexSpace:s}=this,r=n.position;if(0===r.length||t&&0===t.length)return new M({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:e});if(Pt(s)){const{_untransformedBounds:t,transform:n}=this;return Ie(t,n,s,e)}return He(r,e)}get _untransformedBounds(){return ze(this.vertexAttributes.position)}get anchor(){const t=Ct(this.vertexSpace,this.spatialReference);if(null!=t)return t;const{center:e,zmin:n}=this._transformedExtent;return new C({x:e.x,y:e.y,z:n,spatialReference:this.spatialReference})}get origin(){const t=Ct(this.vertexSpace,this.spatialReference);return null!=t?t:this._transformedExtent.center}get extent(){return this.loaded||null==this.metadata?.displaySource?.extent?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(t){this._checkIfLoaded("addComponent()")&&(this.components||(this.components=[]),this.components.push(Te.from(t)),this.notifyChange("components"))}removeComponent(t){if(this._checkIfLoaded("removeComponent()")){if(this.components){const e=this.components.indexOf(t);if(-1!==e)return this.components.splice(e,1),void this.notifyChange("components")}os().error("removeComponent()",Fe)}}rotate(t,e,n,s){return St(t,e,n,ls),Dn(this,ls,s),this}offset(t,e,n){if(!this._checkIfLoaded("offset()"))return this;const{vertexSpace:s,vertexAttributes:r}=this,o=r?.position;if(!o)return this;if(Pt(s)){const[r,o,i]=s.origin;s.origin=at(r+t,o+e,i+n)}else{for(let s=0;s<o.length;s+=3)o[s]+=t,o[s+1]+=e,o[s+2]+=n;this.vertexAttributesChanged()}return this}scale(t,e){return this._checkIfLoaded("scale()")?(Kn(this,t,e),this):this}centerAt(t,e){return this._checkIfLoaded("centerAt()")?(Be(this,t,e),this):this}load(t){const{metadata:{displaySource:e}}=this;return e&&this.addResolvingPromise(qe(this,e,t)),Promise.resolve(this)}addExternalSources(t){this.metadata.externalSources.addMany(t)}updateDisplaySource(t){this.metadata.displaySource=t}clone(){return this.cloneWithVertexSpace(this.vertexSpace.clone())}cloneWithVertexSpace(t){let e=null;if(this.components){const t=new Map,n=new Map;e=this.components.map((e=>e.cloneWithDeduplication(t,n)))}const n={components:e,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),vertexSpace:t,transform:this.transform?.clone()??null,metadata:this.metadata.clone()};return new ss(n)}cloneShallow(){return new ss({components:this.components,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(t){const e=import("./p-d16994bd.js"),n=this.load(),s=await Promise.all([e,n]),{toBinaryGLTF:r}=s[0];return r(this,t)}get memoryUsage(){let t=0;if(t+=this.vertexAttributes.memoryUsage,null!=this.components)for(const e of this.components)t+=e.memoryUsage;return t}_clearSources(){this.metadata.clearSources()}_checkIfLoaded(t){return!!this.loaded||(os().error(t,Me),!1)}static createBox(t,e){if(!(t instanceof C))return os().error(".createBox()",Re),null;const n=new ss(Tn(mn(),t,e));return e?.imageFace&&"all"!==e.imageFace?dn(n,e.imageFace):n}static createSphere(t,e){return t instanceof C?new ss(Tn(wn(e?.densificationFactor||0),t,e)):(os().error(".createSphere()",Re),null)}static createCylinder(t,e){return t instanceof C?new ss(Tn(yn(e?.densificationFactor||0),t,e)):(os().error(".createCylinder()",Re),null)}static createPlane(t,e){if(!(t instanceof C))return os().error(".createPlane()",Re),null;const n=e?.facing??"up",s=gn(n,e?.size);return new ss(Tn(vn(n),t,{...e,size:s}))}static createFromPolygon(t,e){if(!(t instanceof lt))return os().error(".createFromPolygon()",Se),null;const n=Ce(t);return new ss({vertexAttributes:new ye({position:n.position}),components:[new Te({faces:n.faces,shading:"flat",material:e?.material??null})],spatialReference:t.spatialReference,vertexSpace:new Nt})}static async createFromGLTF(t,e,n){if(!(t instanceof C)){const t=new Ne;throw os().error(".createfromGLTF()",t.message),t}const{loadGLTFMesh:s}=await P(import("./p-20cd3b33.js"),n);return new ss(await s(t,e,n))}static async createFromFiles(t,e,n){ct(os(),"`Mesh.createFromFiles` is deprecated in favor of 'SceneLayer.convertMesh'",{replacement:"SceneLayer.convertMesh",version:"4.29"});const s=t=>os().error(".createFromFiles()",t.message);if(!(t instanceof C)){const t=new Ne;throw s(t),t}if(!n?.layer)throw new g("invalid:no-layer","SceneLayer required for file to mesh conversion.");return n.layer.convertMesh(e,{location:t,...n})}static createWithExternalSource(t,e,n){const s=n?.extent??null,{x:r,y:o,z:i,spatialReference:a}=t,l=n?.transform?.clone()??new wt,c=at(r,o,i??0),u=Lt(n?.vertexSpace??Dt(a),c),h={source:e,extent:s},f=new pn;return f.externalSources.push(h),new ss({metadata:f,transform:l,vertexSpace:u,spatialReference:a})}static createIncomplete(t,e){const{x:n,y:s,z:r,spatialReference:o}=t,i=e?.transform?.clone()??new wt,a=at(n,s,r??0),l=Lt(e?.vertexSpace??Dt(o),a),c=new ss({transform:i,vertexSpace:l,spatialReference:o});return c.addResolvingPromise(Promise.reject(new g("mesh-incomplete","Mesh resources are not complete"))),c}};r([o({type:[Te],json:{write:!0}})],as.prototype,"components",void 0),r([o({nonNullable:!0,types:is,constructOnly:!0,json:{write:!0}})],as.prototype,"vertexSpace",void 0),r([o({type:wt,json:{write:!0}})],as.prototype,"transform",void 0),r([o({constructOnly:!0})],as.prototype,"metadata",void 0),r([o()],as.prototype,"hasExtent",null),r([o()],as.prototype,"_transformedExtent",null),r([o()],as.prototype,"_untransformedBounds",null),r([o()],as.prototype,"anchor",null),r([o()],as.prototype,"origin",null),r([o({readOnly:!0,json:{read:!1}})],as.prototype,"extent",null),r([o({readOnly:!0,json:{read:!1,write:!0,default:!0}})],as.prototype,"hasZ",void 0),r([o({readOnly:!0,json:{read:!1,write:!0,default:!1}})],as.prototype,"hasM",void 0),r([o({type:ye,nonNullable:!0,json:{write:!0}})],as.prototype,"vertexAttributes",void 0),as=ss=r([c(rs)],as);const ls=Ft(),cs=as;export{cs as $,ae as a,ce as c,Te as h,ye as l,de as m};
//# sourceMappingURL=p-e2bfcaec.js.map