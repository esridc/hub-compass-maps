import{ag as t,ah as n,ai as s,aj as r,ak as a,al as o,am as i,r as e,p as l,q as u,_ as c,$ as h,an as p,ao as f,ap as m,aq as d,ar as b,as as j}from"./p-aad64c9f.js";import{e as x}from"./p-88dd7081.js";import{b as N,x as g,v}from"./p-dfaba342.js";import{e as w}from"./p-93091a88.js";function y(t=z){return[t[0],t[1],t[2],t[3]]}function M(n,s,r=y()){return t(k(r),n),r[3]=s,r}function A(t,n=y()){const s=i(B,t);return _(n,o(v(n,s))),n}function q(t,n,s=y()){return N(B,k(t),$(t)),N(C,k(n),$(n)),g(B,C,B),_(s,o(v(k(s),B)))}function I(t,n,o,i=y()){return M(s,t,D),M(r,n,E),M(a,o,F),q(D,E,D),q(D,F,i),i}function k(t){return t}function T(t){return t[3]}function $(t){return n(t[3])}function _(t,n){return t[3]=n,t}const z=[0,0,1,0],B=w(),C=w(),D=y(),E=y(),F=y();var G;let H=G=class extends c{constructor(t){super(t),this.translation=h(),this.rotationAxis=p(z),this.rotationAngle=0,this.scale=f(1,1,1)}get rotation(){return M(this.rotationAxis,this.rotationAngle)}set rotation(t){this.rotationAxis=m(k(t)),this.rotationAngle=T(t)}get localMatrix(){const t=x();return N(J,k(this.rotation),$(this.rotation)),d(t,J,this.translation,this.scale),t}get localMatrixInverse(){return b(x(),this.localMatrix)}equals(t){return this===t||null!=t&&j(this.localMatrix,t.localMatrix)}clone(){const t={translation:m(this.translation),rotationAxis:m(this.rotationAxis),rotationAngle:this.rotationAngle,scale:m(this.scale)};return new G(t)}};e([l({type:[Number],nonNullable:!0,json:{write:!0}})],H.prototype,"translation",void 0),e([l({type:[Number],nonNullable:!0,json:{write:!0}})],H.prototype,"rotationAxis",void 0),e([l({type:Number,nonNullable:!0,json:{write:!0}})],H.prototype,"rotationAngle",void 0),e([l({type:[Number],nonNullable:!0,json:{write:!0}})],H.prototype,"scale",void 0),e([l()],H.prototype,"rotation",null),e([l()],H.prototype,"localMatrix",null),e([l()],H.prototype,"localMatrixInverse",null),H=G=e([u("esri.geometry.support.MeshTransform")],H);const J=w(),K=H;export{K as N,I as d,y as j,A as k,k as w,$ as z};
//# sourceMappingURL=p-e11049fd.js.map