import{n as t,b as e,h as i,j as s,y as n,P as a,x as r,g as o,a as l,c as u,S as c,v as h,t as f,I as d,d as y}from"./p-3a28ec18.js";import{t as p}from"./p-1f0b604e.js";import{e as m}from"./p-94b15954.js";import{gP as w,a as g,hV as x,fE as F,hW as S,hX as v,hO as T,cm as b,ch as R,hY as _,hZ as z,bS as M,h_ as E,cn as I,aL as V,h$ as q,g as N,i0 as A,i1 as C,cC as P,aX as Q,ac as D,af as G,co as $,b$ as j,W as B,i2 as Z,gq as O,b4 as L,i3 as U,gZ as H,ge as k,aQ as W,bF as X,b0 as J,aT as Y,i4 as K,go as tt,gn as et,g$ as it,aO as st}from"./p-028496e2.js";import{o as nt}from"./p-854d8fad.js";import{x as at}from"./p-70a81651.js";import{t as rt}from"./p-976040d8.js";import{w as ot}from"./p-19df9fac.js";import{c as lt,B as ut,d as ct,p as ht,C as ft,k as dt,$ as yt,E as pt,P as mt,U as wt,T as gt,v as xt,f as Ft}from"./p-8979c003.js";const St={getObjectId:t=>t.objectId,getAttributes:t=>t.attributes,getAttribute:(t,e)=>t.attributes[e],cloneWithGeometry:(t,e)=>new p(e,t.attributes,null,t.objectId),getGeometry:t=>t.geometry,getCentroid:(e,i)=>(null==e.centroid&&(e.centroid=t(new m,e.geometry,i.hasZ,i.hasM)),e.centroid)};class vt{constructor(t,e){this._cache=new w(t),this._invalidCache=new w(e)}get(t,e){const i=`${e.uid}:${t}`,s=this._cache.get(i);if(s)return s;if(null!=this._invalidCache.get(i))return null;try{const s=at.create(t,e);return this._cache.put(i,s),s}catch(t){return this._invalidCache.put(i,t),null}}getError(t,e){const i=`${e.uid}:${t}`;return this._invalidCache.get(i)??null}}const Tt=new vt(50,500),bt="unsupported-query",Rt=" as ",_t=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeBigInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong"]),zt=new Set(["esriFieldTypeDate","esriFieldTypeDateOnly","esriFieldTypeTimeOnly","esriFieldTypeTimestampOffset"]),Mt=new Set(["esriFieldTypeString","esriFieldTypeGUID","esriFieldTypeGlobalID",..._t,...zt]);function Et(t,e,i={}){const s=qt(e,t);if(!s){const i=Tt.getError(e,t);throw new g(bt,"invalid SQL expression",{expression:e,error:i})}const n=i.expressionName||"expression";if(i.validateStandardized&&!s.isStandardized)throw new g(bt,`${n} is not standard`,{expression:e});if(i.validateAggregate&&!s.isAggregate)throw new g(bt,`${n} does not contain a valid aggregate function`,{expression:e});return s.fieldNames}function It(t,e,i,s){if(!i)return!0;const n="where clause";return Ct(t,e,Et(t,i,{validateStandardized:!0,expressionName:n}),{expressionName:n,query:s}),!0}function Vt(t,e,i,s,n){if(!i)return!0;const a="having clause",r=Et(t,i,{validateAggregate:!0,expressionName:a});Ct(t,e,r,{expressionName:a,query:n});const o=qt(i,t),l=o?.getExpressions().every((e=>{const{aggregateType:i,field:n}=e,a=t.get(n)?.name;return s.some((e=>{const{onStatisticField:s,statisticType:n}=e,r=t.get(s)?.name;return r===a&&n.toLowerCase().trim()===i}))}));if(!l)throw new g(bt,"expressions in having clause should also exist in outStatistics",{having:i});return!0}function qt(t,e){return t?Tt.get(t,e):null}function Nt(t){return/\((.*?)\)/.test(t)?t:t.split(Rt)[0]}function At(t){return t.split(Rt)[1]}function Ct(t,e,i,s={}){const n=new Map;if(Pt(n,t,e,s.allowedFieldTypes??Mt,i),n.size){const t=s.expressionName??"expression";throw new g(bt,`${t} contains invalid or missing fields`,{errors:Array.from(n.values()),query:s.query})}}function Pt(t,e,i,s,n){const a=n.includes("*")?[...i,...n.filter((t=>"*"!==t))]:n;for(const n of a){if(e.get(n))Qt(t,e,i,s,n);else try{const a=Et(e,Nt(n),{validateStandardized:!0});for(const n of a)Qt(t,e,i,s,n)}catch(e){t.set(n,{type:"expression-error",expression:n,error:e})}}}function Qt(t,e,i,s,n){const a=e.get(n);a?i.has(a.name)?"all"!==s&&!1===s?.has(a.type)&&t.set(n,{type:"invalid-type",fieldName:a.name,fieldType:x.fromJSON(a.type),allowedFieldTypes:Array.from(s,(t=>x.fromJSON(t)))}):t.set(n,{type:"missing-field",fieldName:a.name}):t.set(n,{type:"invalid-field",fieldName:n})}class Dt{constructor(t,e,i){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=t.returnDistinctValues??!1,this.fieldsIndex=i,this.featureAdapter=e;const s=t.outFields;if(s&&!s.includes("*")){this.outFields=s;let t=0;for(const e of s){const s=Nt(e),n=this.fieldsIndex.get(s),a=n?null:qt(s,i),r=n?n.name:At(e)||"FIELD_EXP_"+t++;this._fieldDataCache.set(e,{alias:r,clause:a})}}}countDistinctValues(t){return this.returnDistinctValues?(t.forEach((t=>this.getAttributes(t))),this._returnDistinctMap.size):t.length}getAttributes(t){const e=this._processAttributesForOutFields(t);return this._processAttributesForDistinctValues(e)}getFieldValue(t,e,i){const s=i?i.name:e;let n=null;return this._fieldDataCache.has(s)?n=this._fieldDataCache.get(s)?.clause:i||(n=qt(e,this.fieldsIndex),this._fieldDataCache.set(s,{alias:s,clause:n})),i?this.featureAdapter.getAttribute(t,s):n?.calculateValue(t,this.featureAdapter)}getDataValues(t,e,i=!0){const s=e.normalizationType,n=e.normalizationTotal,a=this.fieldsIndex.get(e.field),r=S(a)||v(a),o=T(a);return t.map((t=>{let a=e.field&&this.getFieldValue(t,e.field,this.fieldsIndex.get(e.field));if(e.field2?(a=`${lt(a)}${e.fieldDelimiter}${lt(this.getFieldValue(t,e.field2,this.fieldsIndex.get(e.field2)))}`,e.field3&&(a=`${a}${e.fieldDelimiter}${lt(this.getFieldValue(t,e.field3,this.fieldsIndex.get(e.field3)))}`)):"string"==typeof a&&i&&(r?a=a?new Date(a).getTime():null:o&&(a=a?ot(a):null)),s&&Number.isFinite(a)){const i="field"===s&&e.normalizationField?this.getFieldValue(t,e.normalizationField,this.fieldsIndex.get(e.normalizationField)):null;a=ut(a,s,i,n)}return a}))}async getExpressionValues(t,i,s,n,a){const{arcadeUtils:r}=await F(),o=r.hasGeometryOperations(i);o&&await r.enableGeometryOperations();const l=r.createFunction(i),u=r.getViewInfo(s),c={fields:this.fieldsIndex.fields};return t.map((t=>{const i={attributes:this.featureAdapter.getAttributes(t),layer:c,geometry:o?{...e(n.geometryType,n.hasZ,n.hasM,this.featureAdapter.getGeometry(t)),spatialReference:s?.spatialReference}:null},h=r.createExecContext(i,u,a);return r.executeFunction(l,h)}))}validateItem(t,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:qt(e,this.fieldsIndex)}),this._fieldDataCache.get(e)?.clause?.testFeature(t,this.featureAdapter)??!1}validateItems(t,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:qt(e,this.fieldsIndex)}),this._fieldDataCache.get(e)?.clause?.testSet(t,this.featureAdapter)??!1}_processAttributesForOutFields(t){const e=this.outFields;if(!e?.length)return this.featureAdapter.getAttributes(t);const i={};for(const s of e){const{alias:e,clause:n}=this._fieldDataCache.get(s);i[e]=n?n.calculateValue(t,this.featureAdapter):this.featureAdapter.getAttribute(t,e)}return i}_processAttributesForDistinctValues(t){if(null==t||!this.returnDistinctValues)return t;const e=this.outFields,i=[];if(e)for(const s of e){const{alias:e}=this._fieldDataCache.get(s);i.push(t[e])}else for(const e in t)i.push(t[e]);const s=`${(e||["*"]).join(",")}=${i.join(",")}`;let n=this._returnDistinctMap.get(s)||0;return this._returnDistinctMap.set(s,++n),n>1?null:t}}function Gt(t,e,i){return{objectId:t,target:e,distance:i,type:"vertex"}}function $t(t,e,i,s,n,a=!1){return{objectId:t,target:e,distance:i,type:"edge",start:s,end:n,draped:a}}class jt{constructor(t,e,i){this.items=t,this.query=e,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const t=new Dt(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return t.countDistinctValues(this.items);const{groupByFieldsForStatistics:e,having:i,outStatistics:s}=this.query,n=e?.length;if(!!!n)return 1;const a=new Map,r=new Map,o=new Set;for(const n of s){const{statisticType:s}=n,l="exceedslimit"!==s?n.onStatisticField:void 0;if(!r.has(l)){const i=[];for(const s of e){const e=this._getAttributeValues(t,s,a);i.push(e)}r.set(l,this._calculateUniqueValues(i,t.returnDistinctValues))}const u=r.get(l);for(const e in u){const{data:s,items:n}=u[e],a=s.join(",");i&&!t.validateItems(n,i)||o.add(a)}}return o.size}async createQueryResponse(){let t;if(this.query.outStatistics){t=this.query.outStatistics.some((t=>"exceedslimit"===t.statisticType))?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query)}else t=this._createFeatureQueryResponse(this.query);if(this.query.returnQueryGeometry){const e=this.query.geometry;b(this.query.outSR)&&!R(e.spatialReference,this.query.outSR)?t.queryGeometry=i({spatialReference:this.query.outSR,...s(e,e.spatialReference,this.query.outSR)}):t.queryGeometry=i({spatialReference:this.query.outSR,...e})}return t}createSnappingResponse(t,e){const i=this.featureAdapter,s=Zt(this.hasZ,this.hasM),{point:n,mode:a}=t,r="number"==typeof t.distance?t.distance:t.distance.x,o="number"==typeof t.distance?t.distance:t.distance.y,l={candidates:[]},u="esriGeometryPolygon"===this.geometryType,c=this._getPointCreator(a,this.spatialReference,e),h=new Ot(null,0),f=new Ot(null,0),d={x:0,y:0,z:0};for(const e of this.items){const a=i.getGeometry(e);if(null==a)continue;const{coords:y,lengths:p}=a;if(h.coords=y,f.coords=y,t.returnEdge){let t=0;for(let a=0;a<p.length;a++){const u=p[a];for(let a=0;a<u;a++,t+=s){const y=h;if(y.coordsIndex=t,a!==u-1){const a=f;a.coordsIndex=t+s;const u=d;Bt(d,n,y,a);const h=(n.x-u.x)/r,p=(n.y-u.y)/o,m=h*h+p*p;m<=1&&l.candidates.push($t(i.getObjectId(e),c(u),Math.sqrt(m),c(y),c(a)))}}}}if("none"!==t.vertexMode){const a=u?y.length-s:y.length;if("all"===t.vertexMode)for(let t=0;t<a;t+=s){const s=h;s.coordsIndex=t;const a=(n.x-s.x)/r,u=(n.y-s.y)/o,f=a*a+u*u;f<=1&&l.candidates.push(Gt(i.getObjectId(e),c(s),Math.sqrt(f)))}else if("ends"===t.vertexMode){const t=[0];u||t.push(y.length-s);for(const s of t){const t=h;t.coordsIndex=s;const a=(n.x-t.x)/r,u=(n.y-t.y)/o,f=a*a+u*u;f<=1&&l.candidates.push(Gt(i.getObjectId(e),c(t),Math.sqrt(f)))}}}}return l.candidates.sort(((t,e)=>t.distance-e.distance)),l}_getPointCreator(t,e,i){const n=null==i||R(e,i)?t=>t:t=>s(t,e,i),{hasZ:a}=this,r=0;return"3d"===t?a?({x:t,y:e,z:i})=>n({x:t,y:e,z:i}):({x:t,y:e})=>n({x:t,y:e,z:r}):({x:t,y:e})=>n({x:t,y:e})}async createSummaryStatisticsResponse(t){const{field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,minValue:r,maxValue:o,scale:l,timeZone:u}=t,c=this.fieldsIndex.get(e),h=M(c)||S(c)||v(c),f=await this._getDataValues({field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,scale:l,timeZone:u}),d=Ft({normalizationType:n,normalizationField:s,minValue:r,maxValue:o}),y={value:.5,fieldType:c?.type},p=_(c)?ct({values:f,supportsNullCount:d,percentileParams:y}):ht({values:f,minValue:r,maxValue:o,useSampleStdDev:!n,supportsNullCount:d,percentileParams:y});return ft(p,h)}async createUniqueValuesResponse(t){const{field:e,valueExpression:i,domains:s,returnAllCodedValues:n,scale:a,timeZone:r}=t,o=await this._getDataValues({field:e,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,valueExpression:i,scale:a,timeZone:r},!1),l=dt(o);return yt(l,s,n,t.fieldDelimiter)}async createClassBreaksResponse(t){const{field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c,scale:h,timeZone:f}=t,d=await this._getDataValues({field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,scale:h,timeZone:f}),y=pt(d,{field:e,normalizationField:s,normalizationType:n,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c});return mt(y,r)}async createHistogramResponse(t){const{field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c,scale:h,timeZone:f}=t,d=await this._getDataValues({field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,scale:h,timeZone:f});return wt(d,{field:e,normalizationField:s,normalizationType:n,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c})}_sortFeatures(t,e,i){if(t.length>1&&e?.length)for(const s of e.reverse()){const e=s.split(" "),n=e[0],a=this.fieldsIndex.get(n),r=!!e[1]&&"desc"===e[1].toLowerCase(),o=gt(a?.type,r);t.sort(((t,e)=>{const s=i(t,n,a),r=i(e,n,a);return o(s,r)}))}}_createFeatureQueryResponse(t){const e=this.items,{geometryType:s,hasM:n,hasZ:a,objectIdField:r,spatialReference:o}=this,{outFields:l,outSR:u,quantizationParameters:c,resultRecordCount:h,resultOffset:f,returnZ:d,returnM:y}=t,p=null!=h&&e.length>(f||0)+h,m=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map((t=>this.fieldsIndex.get(t))));return{exceededTransferLimit:p,features:this._createFeatures(t,e),fields:m,geometryType:s,hasM:n&&y,hasZ:a&&d,objectIdFieldName:r,spatialReference:i(u||o),transform:c&&z(c)||null}}_createFeatures(t,i){const s=new Dt(t,this.featureAdapter,this.fieldsIndex),{hasM:a,hasZ:r}=this,{orderByFields:o,quantizationParameters:l,returnGeometry:u,returnCentroid:c,maxAllowableOffset:h,resultOffset:f,resultRecordCount:d,returnZ:y=!1,returnM:p=!1}=t,m=r&&y,w=a&&p;let g=[],x=0;const F=[...i];if(this._sortFeatures(F,o,((t,e,i)=>s.getFieldValue(t,e,i))),this.geometryType&&(u||c)){const t=z(l)??void 0,i="esriGeometryPolygon"===this.geometryType||"esriGeometryPolyline"===this.geometryType;if(u&&!c)for(const a of F){const r=this.featureAdapter.getGeometry(a),o={attributes:s.getAttributes(a),geometry:e(this.geometryType,this.hasZ,this.hasM,r,h,t,m,w)};i&&r&&!o.geometry&&(o.centroid=n(this,this.featureAdapter.getCentroid(a,this),t)),g[x++]=o}else if(!u&&c)for(const e of F)g[x++]={attributes:s.getAttributes(e),centroid:n(this,this.featureAdapter.getCentroid(e,this),t)};else for(const i of F)g[x++]={attributes:s.getAttributes(i),centroid:n(this,this.featureAdapter.getCentroid(i,this),t),geometry:e(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(i),h,t,m,w)}}else for(const t of F){const e=s.getAttributes(t);e&&(g[x++]={attributes:e})}const S=f||0;if(null!=d){const t=S+d;g=g.slice(S,Math.min(g.length,t))}return g}_createExceedsLimitQueryResponse(t){let e=!1,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,n=Number.POSITIVE_INFINITY;for(const e of t.outStatistics??[])if("exceedslimit"===e.statisticType){i=null!=e.maxPointCount?e.maxPointCount:Number.POSITIVE_INFINITY,s=null!=e.maxRecordCount?e.maxRecordCount:Number.POSITIVE_INFINITY,n=null!=e.maxVertexCount?e.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)e=this.items.length>i;else if(this.items.length>s)e=!0;else{const t=Zt(this.hasZ,this.hasM),i=this.featureAdapter;e=this.items.reduce(((t,e)=>{const s=i.getGeometry(e);return t+(null!=s&&s.coords.length||0)}),0)/t>n}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(t){const e={attributes:{}},i=[],s=new Map,n=new Map,a=new Map,r=new Map,o=new Dt(t,this.featureAdapter,this.fieldsIndex),l=t.outStatistics,{groupByFieldsForStatistics:u,having:c,orderByFields:h,resultRecordCount:f}=t,d=u?.length,y=!!d,p=y?u[0]:null,m=y&&!this.fieldsIndex.get(p);for(const t of l??[]){const{outStatisticFieldName:l,statisticType:h}=t,f=t,w="exceedslimit"!==h?t.onStatisticField:void 0,g="percentile_disc"===h||"percentile_cont"===h,x="EnvelopeAggregate"===h||"CentroidAggregate"===h||"ConvexHullAggregate"===h,F=y&&1===d&&(w===p||m)&&"count"===h;if(y){if(!a.has(w)){const t=[];for(const e of u){const i=this._getAttributeValues(o,e,s);t.push(i)}a.set(w,this._calculateUniqueValues(t,!x&&o.returnDistinctValues))}const t=a.get(w);if(!t)continue;const e=Object.keys(t);for(const i of e){const{count:e,data:n,items:a,itemPositions:h}=t[i],d=n.join(",");if(!c||o.validateItems(a,c)){const t=r.get(d)||{attributes:{}};if(x){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(f,a);t.aggregateGeometries[i]=e}else{let i=null;if(F)i=e;else{const t=this._getAttributeValues(o,w,s),e=h.map((e=>t[e]));i=g&&"statisticParameters"in f?this._getPercentileValue(f,e):this._getStatisticValue(f,e,null,o.returnDistinctValues)}t.attributes[l]=i}let i=0;u.forEach(((e,s)=>t.attributes[this.fieldsIndex.get(e)?e:"EXPR_"+ ++i]=n[s])),r.set(d,t)}}}else if(x){e.aggregateGeometries||(e.aggregateGeometries={});const{aggregateGeometries:t,outStatisticFieldName:i}=await this._getAggregateGeometry(f,this.items);e.aggregateGeometries[i]=t}else{const t=this._getAttributeValues(o,w,s);e.attributes[l]=g&&"statisticParameters"in f?this._getPercentileValue(f,t):this._getStatisticValue(f,t,n,o.returnDistinctValues)}const S="min"!==h&&"max"!==h||!_(this.fieldsIndex.get(w))&&!this._isAnyDateField(w)?null:this.fieldsIndex.get(w)?.type;i.push({name:l,alias:l,type:S||"esriFieldTypeDouble"})}const w=y?Array.from(r.values()):[e];return this._sortFeatures(w,h,((t,e)=>t.attributes[e])),f&&(w.length=Math.min(f,w.length)),{fields:i,features:w}}_isAnyDateField(t){const e=this.fieldsIndex.get(t);return M(e)||S(e)||v(e)||T(e)}async _getAggregateGeometry(t,i){const{convexHull:s,union:n}=await import("./p-6d4e518a.js"),{statisticType:a,outStatisticFieldName:r}=t,{featureAdapter:o,spatialReference:l,geometryType:u,hasZ:c,hasM:h}=this,f=i.map((t=>e(u,c,h,o.getGeometry(t)))),d=s(l,f,!0)[0],y={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===a){const t=d?E(d):I(n(l,f));y.aggregateGeometries={...t,spatialReference:l},y.outStatisticFieldName=r||"extent"}else if("CentroidAggregate"===a){const t=d?V(d):q(I(n(l,f)));y.aggregateGeometries={x:t[0],y:t[1],spatialReference:l},y.outStatisticFieldName=r||"centroid"}else"ConvexHullAggregate"===a&&(y.aggregateGeometries=d,y.outStatisticFieldName=r||"convexHull");return y}_getStatisticValue(t,e,i,s){const{onStatisticField:n,statisticType:a}=t;let r=null;r=i?.has(n)?i.get(n):_(this.fieldsIndex.get(n))||this._isAnyDateField(n)?ct({values:e,returnDistinct:s}):ht({values:s?[...new Set(e)]:e,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(n,r);return r["var"===a?"variance":a]}_getPercentileValue(t,e){const{onStatisticField:i,statisticParameters:s,statisticType:n}=t,{value:a,orderBy:r}=s,o=this.fieldsIndex.get(i);return xt(e,{value:a,orderBy:r,fieldType:o?.type,isDiscrete:"percentile_disc"===n})}_getAttributeValues(t,e,i){if(i.has(e))return i.get(e);const s=this.fieldsIndex.get(e),n=this.items.map((i=>t.getFieldValue(i,e,s)));return i.set(e,n),n}_calculateUniqueValues(t,e){const i={},s=this.items,n=s.length;for(let a=0;a<n;a++){const n=s[a],r=[];for(const e of t)r.push(e[a]);const o=r.join(",");null==i[o]?i[o]={count:1,data:r,items:[n],itemPositions:[a]}:(e||i[o].count++,i[o].items.push(n),i[o].itemPositions.push(a))}return i}async _getDataValues(t,e=!0){const i=new Dt(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:s,scale:n,timeZone:a}=t;return s?i.getExpressionValues(this.items,s,{viewingMode:"map",scale:n,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},a):i.getDataValues(this.items,N(t),e)}}function Bt(t,e,i,s){const n=s.x-i.x,a=s.y-i.y,r=n*n+a*a,o=(e.x-i.x)*n+(e.y-i.y)*a,l=Math.min(1,Math.max(0,o/r));t.x=i.x+n*l,t.y=i.y+a*l}function Zt(t,e){return t?e?4:3:e?3:2}class Ot{constructor(t,e){this.coords=t,this.coordsIndex=e}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}const Lt="unsupported-query";async function Ut(t,{fieldsIndex:e,geometryType:i,spatialReference:s,availableFields:n}){if((t.distance??0)<0||null!=t.geometryPrecision||t.multipatchOption&&"xyFootprint"!==t.multipatchOption||t.pixelSize||t.relationParam||t.text)throw new g(Lt,"Unsupported query options",{query:t});return Ht(e,n,t),Wt(e,n,t),Promise.all([a(t,i,s),r(s,t.outSR)]).then((()=>t))}function Ht(t,e,i){const{outFields:s,orderByFields:n,returnDistinctValues:a,outStatistics:r}=i,o=r?r.map((t=>t.outStatisticFieldName&&t.outStatisticFieldName.toLowerCase())).filter(Boolean):[];if(n&&n.length>0){const s=" asc",a=" desc",r=n.map((t=>{const e=t.toLowerCase();return e.includes(s)?e.split(s)[0]:e.includes(a)?e.split(a)[0]:t})).filter((t=>!o.includes(t)));Ct(t,e,r,{expressionName:"orderByFields",query:i})}if(s&&s.length>0)Ct(t,e,s,{expressionName:"outFields",query:i,allowedFieldTypes:"all"});else if(a)throw new g(Lt,"outFields should be specified for returnDistinctValues",{query:i});It(t,e,i.where,i)}const kt=new Set([..._t,...zt]);function Wt(t,e,i){const{outStatistics:s,groupByFieldsForStatistics:n,having:a}=i,r=n?.length,o=s?.length;if(a){if(!r||!o)throw new g(Lt,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:i});Vt(t,e,a,s,i)}if(o){if(!Yt(s))return;const a=s.map((t=>t.onStatisticField)).filter(Boolean);Ct(t,e,a,{expressionName:"onStatisticFields",query:i}),r&&Ct(t,e,n,{expressionName:"groupByFieldsForStatistics",query:i});for(const n of s){const{onStatisticField:s,statisticType:a}=n;if(("percentile_disc"===a||"percentile_cont"===a)&&"statisticParameters"in n){const{statisticParameters:t}=n;if(!t)throw new g(Lt,"statisticParameters should be set for percentile type",{definition:n,query:i})}else t.get(s)&&"count"!==a&&"min"!==a&&"max"!==a&&Ct(t,e,[s],{expressionName:`outStatistics with '${a}' statistic type`,allowedFieldTypes:kt,query:i})}}}async function Xt(t,e,{fieldsIndex:i,geometryType:s,spatialReference:n,availableFields:o}){if((t.distance??0)<0||null!=t.geometryPrecision||t.multipatchOption||t.pixelSize||t.relationParam||t.text||t.outStatistics||t.groupByFieldsForStatistics||t.having||t.orderByFields)throw new g(Lt,"Unsupported query options",{query:t});return Ht(i,o,t),Promise.all([Jt(i,o,e,t),a(t,s,n),r(n,t.outSR)]).then((()=>t))}async function Jt(t,e,i,s){let n=[];if(i.valueExpression){const{arcadeUtils:t}=await F();n=t.extractFieldNames(i.valueExpression)}if(i.field&&n.push(i.field),i.field2&&n.push(i.field2),i.field3&&n.push(i.field3),i.normalizationField&&n.push(i.normalizationField),!n.length&&!i.valueExpression)throw new g(Lt,"field or valueExpression is required",{params:i});Ct(t,e,n,{expressionName:"statistics",query:s})}function Yt(t){return null!=t&&t.every((t=>"exceedslimit"!==t.statisticType))}const Kt="unsupported-query";const te=new A(2e6);let ee=0;class ie{constructor(t){this._geometryQueryCache=null,this._changeHandle=null,this.capabilities={query:rt},this.geometryType=t.geometryType,this.hasM=!!t.hasM,this.hasZ=!!t.hasZ,this.objectIdField=t.objectIdField,this.spatialReference=t.spatialReference,this.definitionExpression=t.definitionExpression,this.featureStore=t.featureStore,this.aggregateAdapter=t.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=t.timeInfo,t.cacheSpatialQueries&&(this._geometryQueryCache=new C(ee+++"$$",te)),this.fieldsIndex=P(t.fieldsIndex)?t.fieldsIndex:Q.fromJSON(t.fieldsIndex),!t.availableFields||1===t.availableFields.length&&"*"===t.availableFields[0]?this.availableFields=new Set(this.fieldsIndex.fields.map((t=>t.name))):this.availableFields=new Set(t.availableFields.map((t=>this.fieldsIndex.get(t)?.name)).filter((t=>null!=t))),t.scheduler&&t.priority&&(this._frameTask=t.scheduler.registerTask(t.priority))}destroy(){this._frameTask=D(this._frameTask),this.clearCache(),G(this._geometryQueryCache),this._changeHandle=D(this._changeHandle)}get featureAdapter(){return this.featureStore.featureAdapter}clearCache(){this._geometryQueryCache?.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async executeQuery(t,e){const i=K(e);try{return(await this._executeQuery(t,{},i)).createQueryResponse()}catch(e){if(e!==o)throw e;return new jt([],t,this).createQueryResponse()}}async executeQueryForCount(t={},e){const i=K(e);try{return(await this._executeQuery(t,{returnGeometry:!1,returnCentroid:!1,outSR:null},i)).createQueryResponseForCount()}catch(t){if(t!==o)throw t;return 0}}async executeQueryForExtent(t,e){const i=K(e),s=t.outSR;try{const e=await this._executeQuery(t,{returnGeometry:!0,returnCentroid:!1,outSR:null},i),n=e.size;if(!n)return{count:0,extent:null};return{count:n,extent:await this._getBounds(e.items,e.spatialReference,s||this.spatialReference)}}catch(t){if(t===o)return{count:0,extent:null};throw t}}async executeQueryForIds(t,e){return this.executeQueryForIdSet(t,e).then((t=>Array.from(t)))}async executeQueryForIdSet(t,e){const i=K(e);try{const e=await this._executeQuery(t,{returnGeometry:!0,returnCentroid:!1,outSR:null},i),s=e.items,n=new Set;return await this._reschedule((()=>{for(const t of s)n.add(e.featureAdapter.getObjectId(t))}),i),n}catch(t){if(t===o)return new Set;throw t}}async executeQueryForSnapping(t,e){const i=K(e),{point:n,distance:a,returnEdge:o,vertexMode:u}=t;if(!o&&"none"===u)return{candidates:[]};let c=N(t.query);c=await this._schedule((()=>l(c,this.definitionExpression,this.spatialReference)),i),c=await this._reschedule((()=>Ut(c,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i);const h=!R(n.spatialReference,this.spatialReference);h&&await r(n.spatialReference,this.spatialReference);const f="number"==typeof a?a:a.x,d="number"==typeof a?a:a.y,y={xmin:n.x-f,xmax:n.x+f,ymin:n.y-d,ymax:n.y+d,spatialReference:n.spatialReference},p=h?s(y,this.spatialReference):y;if(!p)return{candidates:[]};const m=(await $(j(n),null,{signal:i}))[0],w=(await $(j(p),null,{signal:i}))[0];if(null==m||null==w)return{candidates:[]};const g=new jt(await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(w.toJSON()))),i),c,this);await this._reschedule((()=>this._executeObjectIdsQuery(g)),i),await this._reschedule((()=>this._executeTimeQuery(g)),i),await this._reschedule((()=>this._executeAttributesQuery(g)),i),await this._reschedule((()=>this._executeGeometryQueryForSnapping(g,i)),i);const x=m.toJSON(),F=h?s(x,this.spatialReference):x,S=h?Math.max(p.xmax-p.xmin,p.ymax-p.ymin)/2:a;return g.createSnappingResponse({...t,point:F,distance:S},n.spatialReference)}async executeQueryForLatestObservations(t,e){const i=K(e);if(!this.timeInfo?.trackIdField)throw new g(Kt,"Missing timeInfo or timeInfo.trackIdField",{query:t,timeInfo:this.timeInfo});try{const e=await this._executeQuery(t,{},i);return await this._reschedule((()=>this._filterLatest(e)),i),e.createQueryResponse()}catch(e){if(e!==o)throw e;return new jt([],t,this).createQueryResponse()}}async executeQueryForSummaryStatistics(t={},e,i){const s=K(i),{field:n,normalizationField:a,valueExpression:r}=e;return(await this._executeQueryForStatistics(t,{field:n,normalizationField:a,valueExpression:r},s)).createSummaryStatisticsResponse(e)}async executeQueryForUniqueValues(t={},e,i){const s=K(i),{field:n,field2:a,field3:r,valueExpression:o}=e;return(await this._executeQueryForStatistics(t,{field:n,field2:a,field3:r,valueExpression:o},s)).createUniqueValuesResponse(e)}async executeQueryForClassBreaks(t={},e,i){const s=K(i),{field:n,normalizationField:a,valueExpression:r}=e;return(await this._executeQueryForStatistics(t,{field:n,normalizationField:a,valueExpression:r},s)).createClassBreaksResponse(e)}async executeQueryForHistogram(t={},e,i){const s=K(i),{field:n,normalizationField:a,valueExpression:r}=e;return(await this._executeQueryForStatistics(t,{field:n,normalizationField:a,valueExpression:r},s)).createHistogramResponse(e)}async fetchRecomputedExtents(t){const e=K(t);this._timeExtentPromise||=u(this.timeInfo,this.featureStore);const[i,s]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return B(e),{fullExtent:i,timeExtent:s}}async _getBounds(t,e,n){const a=Z(et(),tt);await this.featureStore.forEachBounds(t,(t=>O(a,t)));const r={xmin:a[0],ymin:a[1],xmax:a[3],ymax:a[4],spatialReference:i(this.spatialReference)};this.hasZ&&isFinite(a[2])&&isFinite(a[5])&&(r.zmin=a[2],r.zmax=a[5]);const o=s(r,e,n);if(o.spatialReference=i(n),o.xmax-o.xmin==0){const t=L(o.spatialReference);o.xmin-=t,o.xmax+=t}if(o.ymax-o.ymin==0){const t=L(o.spatialReference);o.ymin-=t,o.ymax+=t}if(this.hasZ&&null!=o.zmin&&null!=o.zmax&&o.zmax-o.zmin==0){const t=L(o.spatialReference);o.zmin-=t,o.zmax+=t}return o}_getFullExtent(){return this._fullExtentPromise||="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then((t=>this._getBounds(t,this.spatialReference,this.spatialReference))),this._fullExtentPromise}async _schedule(t,e){return null!=this._frameTask?this._frameTask.schedule(t,e):t(U)}async _reschedule(t,e){return null!=this._frameTask?this._frameTask.reschedule(t,e):t(U)}async _getAllFeaturesQueryEngineResult(t){return new jt(await this._getAllFeatures(),t,this)}async _getAllFeatures(){if(null==this._allFeaturesPromise){const t=[];this._allFeaturesPromise=(async()=>{await this.featureStore.forEach((e=>t.push(e)))})().then((()=>t))}const t=this._allFeaturesPromise,e=await t;return t===this._allFeaturesPromise?e.slice():this._getAllFeatures()}async _executeQuery(t,e,i){t=N(t),t=await this._schedule((()=>c(t,this.definitionExpression,this.spatialReference)),i),t=await this._reschedule((()=>Ut(t,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i),t={...t,...e};const s=await this._reschedule((()=>this._executeSceneFilterQuery(t,i)),i),n=await this._reschedule((()=>this._executeGeometryQuery(t,s,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(n)),i),await this._reschedule((()=>this._executeObjectIdsQuery(n)),i),await this._reschedule((()=>this._executeTimeQuery(n)),i),await this._reschedule((()=>this._executeAttributesQuery(n)),i),n}async _executeSceneFilterQuery(t,e){if(null==t.sceneFilter)return null;const{outSR:i,returnGeometry:n,returnCentroid:a}=t,r=this.featureStore.featureSpatialReference,o=t.sceneFilter.geometry,l=null==r||R(r,o.spatialReference)?o:s(o,r);if(!l)return null;const u=n||a,c=b(i)&&!R(this.spatialReference,i)&&u?async t=>this._project(t,i):t=>t,f=this.featureAdapter,d=await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(l))),e);if("disjoint"===t.sceneFilter.spatialRelationship){if(!d.length)return null;const i=new Set;for(const t of d)i.add(f.getObjectId(t));const s=await this._reschedule((()=>this._getAllFeatures()),e),n=await this._reschedule((async()=>{const n=await h("esriSpatialRelDisjoint",l,this.geometryType,this.hasZ,this.hasM),a=t=>!i.has(f.getObjectId(t))||n(f.getGeometry(t)),r=await this._runSpatialFilter(s,a,e);return new jt(r,t,this)}),e);return c(n)}if(!d.length)return new jt([],t,this);if(this._canExecuteSinglePass(l,t))return c(new jt(d,t,this));const y=await h("esriSpatialRelContains",l,this.geometryType,this.hasZ,this.hasM),p=await this._runSpatialFilter(d,(t=>y(f.getGeometry(t))),e);return c(new jt(p,t,this))}async _executeGeometryQuery(t,e,i){if(null!=e&&0===e.items.length)return e;t=null!=e?e.query:t;const{geometry:n,outSR:a,spatialRel:r,returnGeometry:o,returnCentroid:l}=t,u=this.featureStore.featureSpatialReference,c=!n||null==u||R(u,n.spatialReference)?n:s(n,u),f=o||l,d=b(a)&&!R(this.spatialReference,a),y=this._geometryQueryCache&&null==e?d&&f?JSON.stringify({originalFilterGeometry:n,spatialRelationship:r,outSpatialReference:a}):JSON.stringify({originalFilterGeometry:n,spatialRelationship:r}):null,p=y?this._geometryQueryCache.get(y):null;if(null!=p)return new jt(p,t,this);const m=async t=>(d&&f&&await this._project(t,a),y&&this._geometryQueryCache.put(y,t.items,t.items.length+1),t);if(!c)return m(null!=e?e:await this._getAllFeaturesQueryEngineResult(t));const w=this.featureAdapter;let g=await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(n))),i);if("esriSpatialRelDisjoint"===r){if(!g.length)return m(null!=e?e:await this._getAllFeaturesQueryEngineResult(t));const s=new Set;for(const t of g)s.add(w.getObjectId(t));const n=null!=e?e.items:await this._reschedule((()=>this._getAllFeatures()),i),a=await this._reschedule((async()=>{const e=await h(r,c,this.geometryType,this.hasZ,this.hasM),a=t=>!s.has(w.getObjectId(t))||e(w.getGeometry(t)),o=await this._runSpatialFilter(n,a,i);return new jt(o,t,this)}),i);return m(a)}if(null!=e){const t=new it;g=g.filter((i=>H(e.items,i,e.items.length,t)>=0))}if(!g.length){const e=new jt([],t,this);return y&&this._geometryQueryCache.put(y,e.items,1),e}if(this._canExecuteSinglePass(c,t))return m(new jt(g,t,this));const x=await h(r,c,this.geometryType,this.hasZ,this.hasM),F=await this._runSpatialFilter(g,(t=>x(w.getGeometry(t))),i);return m(new jt(F,t,this))}async _executeGeometryQueryForSnapping(t,e){const{query:i}=t,{spatialRel:s}=i;if(!t?.items?.length||!i.geometry||!s)return;const n=await h(s,i.geometry,this.geometryType,this.hasZ,this.hasM),a=await this._runSpatialFilter(t.items,(t=>n(t.geometry)),e);t.items=a}_executeAggregateIdsQuery(t){if(0===t.items.length||!t.query.aggregateIds?.length||null==this.aggregateAdapter)return;const e=new Set;for(const i of t.query.aggregateIds){this.aggregateAdapter.getFeatureObjectIds(i).forEach((t=>e.add(t)))}const i=this.featureAdapter.getObjectId;t.items=t.items.filter((t=>e.has(i(t))))}_executeObjectIdsQuery(t){if(0===t.items.length||!t.query.objectIds?.length)return;const e=new Set(t.query.objectIds),i=this.featureAdapter.getObjectId;t.items=t.items.filter((t=>e.has(i(t))))}_executeTimeQuery(t){if(0===t.items.length)return;const e=f(this.timeInfo,t.query.timeExtent,this.featureAdapter);null!=e&&(t.items=t.items.filter(e))}_executeAttributesQuery(t){if(0===t.items.length)return;const e=qt(t.query.where,this.fieldsIndex);if(e){if(!e.isStandardized)throw new TypeError("Where clause is not standardized");t.items=t.items.filter((t=>e.testFeature(t,this.featureAdapter)))}}async _runSpatialFilter(t,e,i){if(!e)return t;if(null==this._frameTask)return t.filter((t=>e(t)));let s=0;const n=new Array,a=async r=>{for(;s<t.length;){const o=t[s++];e(o)&&(n.push(o),r.madeProgress()),r.done&&await this._reschedule((t=>a(t)),i)}};return this._reschedule((t=>a(t)),i).then((()=>n))}_filterLatest(t){const{trackIdField:e,startTimeField:i,endTimeField:s}=this.timeInfo,n=s||i,a=new Map,r=this.featureAdapter.getAttribute;for(const i of t.items){const t=r(i,e),s=r(i,n),o=a.get(t);(!o||s>r(o,n))&&a.set(t,i)}t.items=Array.from(a.values())}_canExecuteSinglePass(t,e){const{spatialRel:i}=e;return d(t)&&("esriSpatialRelEnvelopeIntersects"===i||"esriGeometryPoint"===this.geometryType&&("esriSpatialRelIntersects"===i||"esriSpatialRelContains"===i))}async _project(t,i){if(!i||R(this.spatialReference,i))return t;const s=this.featureAdapter;let n;try{const t=await this._getFullExtent();n=k(this.spatialReference,i,t)}catch{}const a=await y(t.items.map((t=>e(this.geometryType,this.hasZ,this.hasM,s.getGeometry(t)))),this.spatialReference,i,n);return t.items=a.map(((e,i)=>s.cloneWithGeometry(t.items[i],nt(e,this.hasZ,this.hasM)))),t}_getQueryBBoxes(t){if(d(t)){if(W(t))return[X(Math.min(t.xmin,t.xmax),Math.min(t.ymin,t.ymax),Math.max(t.xmin,t.xmax),Math.max(t.ymin,t.ymax))];if(J(t))return t.rings.map((t=>X(Math.min(t[0][0],t[2][0]),Math.min(t[0][1],t[2][1]),Math.max(t[0][0],t[2][0]),Math.max(t[0][1],t[2][1]))))}return[Y(st(),t)]}async _searchFeatures(t){const e=new Set;await Promise.all(t.map((t=>this.featureStore.forEachInBounds(t,(t=>e.add(t))))));const i=Array.from(e.values());return e.clear(),i}async _executeQueryForStatistics(t,e,i){t=N(t);try{t=await this._schedule((()=>c(t,this.definitionExpression,this.spatialReference)),i),t=await this._reschedule((()=>Xt(t,e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i);const s=await this._reschedule((()=>this._executeSceneFilterQuery(t,i)),i),n=await this._reschedule((()=>this._executeGeometryQuery(t,s,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(n)),i),await this._reschedule((()=>this._executeObjectIdsQuery(n)),i),await this._reschedule((()=>this._executeTimeQuery(n)),i),await this._reschedule((()=>this._executeAttributesQuery(n)),i),n}catch(e){if(e!==o)throw e;return new jt([],t,this)}}}export{ie as $,St as o};
//# sourceMappingURL=p-ec8156a6.js.map