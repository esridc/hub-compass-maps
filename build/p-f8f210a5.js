import{a3 as t,s,n_ as e,ax as i,c9 as r,dv as n,lM as o,aU as a,aW as h,$ as c,n as f,ah as u,hP as l,a2 as p,mI as d,ap as m,nR as w,d8 as y,M as g}from"./p-aad64c9f.js";import{N as b,T as A}from"./p-dfaba342.js";import{r as E,t as T,e as N}from"./p-93091a88.js";import{m as I}from"./p-a68c6147.js";import{B as _}from"./p-25b70cc1.js";import{r as O}from"./p-c2c2e8b2.js";import"./p-2af77f97.js";import"./p-79c28fb7.js";import"./p-e11049fd.js";import"./p-88dd7081.js";import"./p-fefc46e8.js";import"./p-17b3a90f.js";import"./p-5d8d2e95.js";import"./p-c0b174ee.js";import"./p-5b459e36.js";import"./p-a040372a.js";import"./p-f9e31f43.js";import"./p-66c1870a.js";import"./p-1826fadd.js";import"./p-e51694e6.js";import"./p-dcc79702.js";import"./p-cde3f633.js";import"./p-d5a66c42.js";import"./p-fa12d64c.js";import"./p-a0f1b2e3.js";import"./p-dc92c2ea.js";function S(t){const s=B(t);return null!=s?s.toDataURL():""}async function j(e,i){const r=B(e);if(null==r)throw new s("imageToArrayBuffer","Unsupported image type");const n=M(e),o=await new Promise((t=>r.toBlob(t,n)));if(t(i),!o)throw new s("imageToArrayBuffer","Failed to encode image");const a=await o.arrayBuffer();return t(i),{data:a,type:n}}function M(t){if(!(t instanceof HTMLImageElement))return"image/png";const s=t.src;if(e(s)){const t=i(s);return"image/jpeg"===t?.mediaType?t.mediaType:"image/png"}return/\.png$/i.test(s)?"image/png":/\.(jpg|jpeg)$/i.test(s)?"image/jpeg":"image/png"}function B(t){if(t instanceof HTMLCanvasElement)return t;if(t instanceof HTMLVideoElement)return null;const s=document.createElement("canvas");s.width=t.width,s.height=t.height;const e=s.getContext("2d");return t instanceof HTMLImageElement?e.drawImage(t,0,0,t.width,t.height):t instanceof ImageData&&e.putImageData(t,0,0),s}function x(t){const s=[],e=new Uint8Array(t);for(let t=0;t<e.length;t++)s.push(String.fromCharCode(e[t]));return"data:application/octet-stream;base64,"+btoa(s.join(""))}function L(t){if(t.byteLength<8)return!1;const s=new Uint8Array(t);return 137===s[0]&&80===s[1]&&78===s[2]&&71===s[3]&&13===s[4]&&10===s[5]&&26===s[6]&&10===s[7]}var C;!function(t){t[t.JSON=1313821514]="JSON",t[t.BIN=5130562]="BIN"}(C||(C={}));class R{constructor(t,s){if(!t)throw new Error("GLB requires a JSON gltf chunk");this._length=R.HEADER_SIZE,this._length+=R.CHUNK_HEADER_SIZE;const e=U(t);if(this._length+=P(e.byteLength,4),s&&(this._length+=R.CHUNK_HEADER_SIZE,this._length+=s.byteLength,s.byteLength%4))throw new Error("Expected BIN chunk length to be divisible by 4 at this point");this.buffer=new ArrayBuffer(this._length),this._outView=new DataView(this.buffer),this._writeHeader();const i=this._writeChunk(e,12,C.JSON,32);s&&this._writeChunk(s,i,C.BIN)}_writeHeader(){this._outView.setUint32(0,R.MAGIC,!0),this._outView.setUint32(4,R.VERSION,!0),this._outView.setUint32(8,this._length,!0)}_writeChunk(t,s,e,i=0){const r=P(t.byteLength,4);for(this._outView.setUint32(s,r,!0),this._outView.setUint32(s+=4,e,!0),v(this._outView.buffer,t,s+=4,0,t.byteLength),s+=t.byteLength;s%4;)i&&this._outView.setUint8(s,i),s++;return s}}function v(t,s,e,i,r){new Uint8Array(t,e,r).set(new Uint8Array(s,i,r),0)}function U(t){return(new TextEncoder).encode(t).buffer}function P(t,s){return s*Math.ceil(t/s)}R.HEADER_SIZE=12,R.CHUNK_HEADER_SIZE=8,R.MAGIC=1179937895,R.VERSION=2;var k,V,z,F,G,D,H;!function(t){t[t.External=0]="External",t[t.DataURI=1]="DataURI",t[t.GLB=2]="GLB"}(k||(k={})),function(t){t[t.External=0]="External",t[t.DataURI=1]="DataURI",t[t.GLB=2]="GLB"}(V||(V={})),function(t){t[t.ARRAY_BUFFER=34962]="ARRAY_BUFFER",t[t.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER"}(z||(z={})),function(t){t.SCALAR="SCALAR",t.VEC2="VEC2",t.VEC3="VEC3",t.VEC4="VEC4",t.MAT2="MAT2",t.MAT3="MAT3",t.MAT4="MAT4"}(F||(F={})),function(t){t[t.POINTS=0]="POINTS",t[t.LINES=1]="LINES",t[t.LINE_LOOP=2]="LINE_LOOP",t[t.LINE_STRIP=3]="LINE_STRIP",t[t.TRIANGLES=4]="TRIANGLES",t[t.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",t[t.TRIANGLE_FAN=6]="TRIANGLE_FAN"}(G||(G={})),function(t){t.OPAQUE="OPAQUE",t.MASK="MASK",t.BLEND="BLEND"}(D||(D={})),function(t){t[t.NoColor=0]="NoColor",t[t.FaceColor=1]="FaceColor",t[t.VertexColor=2]="VertexColor"}(H||(H={}));class ${constructor(t,s,e,i,r){this._buffer=t,this._componentType=e,this._dataType=i,this._data=[],this._isFinalized=!1,this._accessorIndex=-1,this._accessorAttribute=null,this._accessorMin=null,this._accessorMax=null,s.bufferViews||(s.bufferViews=[]),this.index=s.bufferViews.length,this._bufferView={buffer:t.index,byteLength:-1,target:r};const n=this._getElementSize();n>=4&&r!==z.ELEMENT_ARRAY_BUFFER&&(this._bufferView.byteStride=n),s.bufferViews.push(this._bufferView),this._numComponentsForDataType=this._calculateNumComponentsForDataType()}push(t){const s=this._data.length;if(this._data.push(t),this._accessorIndex>=0){const e=s%this._numComponentsForDataType,i=this._accessorMin[e];this._accessorMin[e]="number"!=typeof i?t:Math.min(i,t);const r=this._accessorMax[e];this._accessorMax[e]="number"!=typeof r?t:Math.max(r,t)}}get dataSize(){return this._data.length*this._sizeComponentType()}get byteSize(){function t(t,s){return s*Math.ceil(t/s)}return t(this.dataSize,4)}getByteOffset(){if(!this._isFinalized)throw new Error("Cannot get BufferView offset until it is finalized");return this._buffer.getByteOffset(this)}get byteOffset(){if(!this._isFinalized)throw new Error("Cannot get BufferView offset until it is finalized");return this._buffer.getByteOffset(this)}_createTypedArray(t,s){switch(this._componentType){case r.BYTE:return new Int8Array(t,s);case r.FLOAT:return new Float32Array(t,s);case r.SHORT:return new Int16Array(t,s);case r.UNSIGNED_BYTE:return new Uint8Array(t,s);case r.UNSIGNED_INT:return new Uint32Array(t,s);case r.UNSIGNED_SHORT:return new Uint16Array(t,s)}}writeOutToBuffer(t,s){this._createTypedArray(t,s).set(this._data)}writeAsync(t){if(this._asyncWritePromise)throw new Error("Can't write multiple bufferView values asynchronously");return this._asyncWritePromise=t.then((t=>{const s=new Uint8Array(t);for(let t=0;t<s.length;++t)this._data.push(s[t]);delete this._asyncWritePromise})),this._asyncWritePromise}startAccessor(t){if(this._accessorIndex>=0)throw new Error("Accessor was started without ending the previous one");this._accessorIndex=this._data.length,this._accessorAttribute=t;const s=this._numComponentsForDataType;this._accessorMin=new Array(s),this._accessorMax=new Array(s)}endAccessor(){if(this._accessorIndex<0)throw new Error("An accessor was not started, but was attempted to be ended");const t=this._getElementSize(),s=this._numComponentsForDataType,e=(this._data.length-this._accessorIndex)/s;if(e%1)throw new Error("An accessor was ended with missing component values");for(let t=0;t<this._accessorMin.length;++t)"number"!=typeof this._accessorMin[t]&&(this._accessorMin[t]=0),"number"!=typeof this._accessorMax[t]&&(this._accessorMax[t]=0);const i={byteOffset:t*(this._accessorIndex/s),componentType:this._componentType,count:e,type:this._dataType,min:this._accessorMin,max:this._accessorMax,name:this._accessorAttribute};switch(this._accessorAttribute){case"TEXCOORD_0":case"TEXCOORD_1":case"COLOR_0":case"WEIGHTS_0":switch(this._componentType){case r.UNSIGNED_BYTE:case r.UNSIGNED_SHORT:i.normalized=!0}}return this._accessorIndex=-1,this._accessorAttribute=null,this._accessorMin=null,this._accessorMax=null,i}get finalized(){return this._finalizedPromise?this._finalizedPromise:this._isFinalized?this._finalizedPromise=Promise.resolve():this._finalizedPromise=new Promise((t=>this._finalizedPromiseResolve=t))}async finalize(){const t=this._bufferView,s=this._buffer.getViewFinalizePromises(this);this._asyncWritePromise&&s.push(this._asyncWritePromise),await Promise.allSettled(s),this._isFinalized=!0,t.byteOffset=this.getByteOffset(),t.byteLength=this.dataSize,this._finalizedPromiseResolve&&this._finalizedPromiseResolve()}_getElementSize(){return this._sizeComponentType()*this._numComponentsForDataType}_sizeComponentType(){switch(this._componentType){case r.BYTE:case r.UNSIGNED_BYTE:return 1;case r.SHORT:case r.UNSIGNED_SHORT:return 2;case r.UNSIGNED_INT:case r.FLOAT:return 4}}_calculateNumComponentsForDataType(){switch(this._dataType){case F.SCALAR:return 1;case F.VEC2:return 2;case F.VEC3:return 3;case F.VEC4:case F.MAT2:return 4;case F.MAT3:return 9;case F.MAT4:return 16}}}class J{constructor(t){this._gltf=t,this._bufferViews=[],this._isFinalized=!1,t.buffers||(t.buffers=[]),this.index=t.buffers.length;const s={byteLength:-1};t.buffers.push(s),this._buffer=s}addBufferView(t,s,e){if(this._finalizePromise)throw new Error("Cannot add buffer view after fiinalizing buffer");const i=new $(this,this._gltf,t,s,e);return this._bufferViews.push(i),i}getByteOffset(t){let s=0;for(const e of this._bufferViews){if(e===t)return s;s+=e.byteSize}throw new Error("Given bufferView was not present in this buffer")}getViewFinalizePromises(t){const s=[];for(const e of this._bufferViews){if(t&&e===t)return s;s.push(e.finalized)}return s}getArrayBuffer(){if(!this._isFinalized)throw new Error("Cannot get ArrayBuffer from Buffer before it is finalized");const t=this._getTotalSize(),s=new ArrayBuffer(t);let e=0;for(const t of this._bufferViews)t.writeOutToBuffer(s,e),e+=t.byteSize;return s}finalize(){if(this._finalizePromise)throw new Error(`Buffer ${this.index} was already finalized`);return this._finalizePromise=Promise.allSettled(this.getViewFinalizePromises()).then((()=>{this._isFinalized=!0;const t=this.getArrayBuffer();this._buffer.byteLength=t.byteLength,this._buffer.uri=t})),this._gltf.extras.promises.push(this._finalizePromise),this._finalizePromise}_getTotalSize(){let t=0;for(const s of this._bufferViews)t+=s.byteSize;return t}}function X(t,s){if(t.components)for(const e of t.components)e.faces&&"smooth"===e.shading&&W(e,s)}function W(t,s){null==s.normal&&(s.normal=new Float32Array(s.position.length));const e=t.faces,{position:i,normal:r}=s,c=e.length/3;for(let t=0;t<c;++t){const s=3*e[3*t],h=3*e[3*t+1],c=3*e[3*t+2],f=n(Y,i[s],i[s+1],i[s+2]),u=n(q,i[h],i[h+1],i[h+2]),l=n(K,i[c],i[c+1],i[c+2]),p=o(u,u,f),d=o(l,l,f),m=a(p,p,d);r[s]+=m[0],r[s+1]+=m[1],r[s+2]+=m[2],r[h]+=m[0],r[h+1]+=m[1],r[h+2]+=m[2],r[c]+=m[0],r[c+1]+=m[1],r[c+2]+=m[2]}for(let t=0;t<r.length;t+=3)n(Q,r[t],r[t+1],r[t+2]),h(Q,Q),r[t]=Q[0],r[t+1]=Q[1],r[t+2]=Q[2]}const Y=c(),q=c(),K=c(),Q=c();const Z=()=>f.getLogger("esri.geometry.support.meshUtils.exporters.gltf.gltf");class tt{constructor(t,s){this.options=s,this._materialMap=new Array,this._imageMap=new Map,this._textureMap=new Map,this.gltf={asset:{version:"2.0",copyright:t.copyright,generator:t.generator},extras:{output:s.output,binChunkBuffer:null,promises:[]}},this._addScenes(t)}_addScenes(t){this.gltf.scene=t.defaultScene;const s=this.gltf.extras,e=s.output.buffer===k.GLB||s.output.image===V.GLB;e&&(s.binChunkBuffer=new J(this.gltf)),t.forEachScene((t=>{this._addScene(t)})),e&&s.binChunkBuffer.finalize()}_addScene(t){this.gltf.scenes||(this.gltf.scenes=[]);const s={};t.name&&(s.name=t.name),t.forEachNode((t=>{s.nodes||(s.nodes=[]),s.nodes.push(...this._addNodes(t))})),this.gltf.scenes.push(s)}_addNodes(t){this.gltf.nodes||(this.gltf.nodes=[]);const s={};t.name&&(s.name=t.name);const e=t.translation;p(e,d)||(s.translation=m(e));const i=t.rotation;b(i,E)||(s.rotation=T(i));const r=t.scale;p(r,w)||(s.scale=m(r));const n=this.gltf.nodes.length;if(this.gltf.nodes.push(s),t.mesh&&t.mesh.vertexAttributes.position){const e=this._createMeshes(t.mesh),i=[n];if(1===e.length)this._addMesh(s,e[0]);else for(const t of e){const s={};this._addMesh(s,t),i.push(this.gltf.nodes.length),this.gltf.nodes.push(s)}return i}return t.forEachNode((t=>{s.children||(s.children=[]),s.children.push(...this._addNodes(t))})),[n]}_addMesh(t,s){this.gltf.meshes??=[];const e=this.gltf.meshes.length;this.gltf.meshes.push(s),t.mesh=e}_createMeshes(t){const s=this.gltf.extras,e=s.output.buffer===k.GLB;let i;i=e?s.binChunkBuffer:new J(this.gltf);const n=this.options.origin,o=t.vertexSpace.clone();o.origin=[n.x,n.y,n.z??0];const a=_({vertexAttributes:t.vertexAttributes,vertexSpace:t.vertexSpace,transform:this.options?.ignoreLocalTransform?null:t.transform,spatialReference:t.spatialReference},o,{targetUnit:this.options.unitConversionDisabled?void 0:"meters"});if(!a)return[];X(t,a),st(a);const{position:h,normal:c,tangent:f}=a,{uv:u,color:l}=t.vertexAttributes,p=i.addBufferView(r.FLOAT,F.VEC3,z.ARRAY_BUFFER);let d,m,w,y;c&&(d=i.addBufferView(r.FLOAT,F.VEC3,z.ARRAY_BUFFER)),u&&(m=i.addBufferView(r.FLOAT,F.VEC2,z.ARRAY_BUFFER)),f&&(w=i.addBufferView(r.FLOAT,F.VEC4,z.ARRAY_BUFFER)),l&&(y=i.addBufferView(r.UNSIGNED_BYTE,F.VEC4,z.ARRAY_BUFFER)),p.startAccessor("POSITION"),d&&d.startAccessor("NORMAL"),m&&m.startAccessor("TEXCOORD_0"),w&&w.startAccessor("TANGENT"),y&&y.startAccessor("COLOR_0");const g=a.position.length/3;for(let t=0;t<g;++t)p.push(h[3*t]),p.push(h[3*t+1]),p.push(h[3*t+2]),d&&null!=c&&(d.push(c[3*t]),d.push(c[3*t+1]),d.push(c[3*t+2])),m&&null!=u&&(m.push(u[2*t]),m.push(u[2*t+1])),w&&null!=f&&(w.push(f[4*t]),w.push(f[4*t+1]),w.push(f[4*t+2]),w.push(f[4*t+3])),y&&null!=l&&(y.push(l[4*t]),y.push(l[4*t+1]),y.push(l[4*t+2]),y.push(l[4*t+3]));const b=p.endAccessor(),A=this._addAccessor(p.index,b);let E,T,N,I,O;if(d){const t=d.endAccessor();E=this._addAccessor(d.index,t)}if(m){const t=m.endAccessor();T=this._addAccessor(m.index,t)}if(w){const t=w.endAccessor();N=this._addAccessor(w.index,t)}if(y){const t=y.endAccessor();I=this._addAccessor(y.index,t)}const S=[];return t.components&&t.components.length>0&&t.components[0].faces?(O=i.addBufferView(r.UNSIGNED_INT,F.SCALAR,z.ELEMENT_ARRAY_BUFFER),this._addMeshVertexIndexed(O,t.components,S,A,E,T,N,I)):this._addMeshVertexNonIndexed(t.components,S,A,E,T,N,I),p.finalize(),d&&d.finalize(),m&&m.finalize(),w&&w.finalize(),O&&O.finalize(),y&&y.finalize(),e||i.finalize(),S}_addMaterial(t){if(null===t)return;const s=this._materialMap.indexOf(t);if(-1!==s)return s;this.gltf.materials||(this.gltf.materials=[]);const e={};switch(t.alphaMode){case"mask":e.alphaMode=D.MASK;break;case"auto":case"blend":e.alphaMode=D.BLEND}e.alphaCutoff=t.alphaCutoff,t.doubleSided&&(e.doubleSided=t.doubleSided),e.pbrMetallicRoughness={};const i=t=>t**2.1,r=t=>{const s=t.toRgba();return s[0]=i(s[0]/255),s[1]=i(s[1]/255),s[2]=i(s[2]/255),s};if(null!=t.color&&(e.pbrMetallicRoughness.baseColorFactor=r(t.color)),null!=t.colorTexture&&(e.pbrMetallicRoughness.baseColorTexture=this._createTextureInfo(t.colorTexture,t.colorTextureTransform)),null!=t.normalTexture&&(e.normalTexture=this._createTextureInfo(t.normalTexture,t.normalTextureTransform)),t instanceof I){if(null!=t.emissiveTexture&&(e.emissiveTexture=this._createTextureInfo(t.emissiveTexture,t.emissiveTextureTransform)),null!=t.emissiveColor){const s=r(t.emissiveColor);e.emissiveFactor=[s[0],s[1],s[2]]}null!=t.occlusionTexture&&(e.occlusionTexture=this._createTextureInfo(t.occlusionTexture,t.occlusionTextureTransform)),null!=t.metallicRoughnessTexture&&(e.pbrMetallicRoughness.metallicRoughnessTexture=this._createTextureInfo(t.metallicRoughnessTexture,t.metallicRoughnessTextureTransform)),e.pbrMetallicRoughness.metallicFactor=t.metallic,e.pbrMetallicRoughness.roughnessFactor=t.roughness}else e.pbrMetallicRoughness.metallicFactor=1,e.pbrMetallicRoughness.roughnessFactor=1,Z().warnOnce("Meshes exported to GLTF without MeshMaterialMetallicRoughness material will appear different when imported back.");const n=this.gltf.materials.length;return this.gltf.materials.push(e),this._materialMap.push(t),n}_createTextureInfo(t,s){const e={index:this._addTexture(t)};return s?(e.extensions||(e.extensions={}),e.extensions.KHR_texture_transform={scale:s.scale,offset:s.offset,rotation:u(s.rotation)},e):e}_addTexture(t){const s=this.gltf.textures??[];return this.gltf.textures=s,l(this._textureMap,t,(()=>{const e={sampler:this._addSampler(t),source:this._addImage(t)},i=s.length;return s.push(e),i}))}_addImage(t){const s=this._imageMap.get(t);if(null!=s)return s;this.gltf.images||(this.gltf.images=[]);const e={};if(t.url)e.uri=t.url;else{const s=t.data;e.extras=s;for(let t=0;t<this.gltf.images.length;++t)if(s===this.gltf.images[t].extras)return t;const i=this.gltf.extras;switch(i.output.image){case V.GLB:{const t=i.binChunkBuffer.addBufferView(r.UNSIGNED_BYTE,F.SCALAR);if(O(s))null!=s.data&&t.writeOutToBuffer(s.data,0);else{const r=j(s,this.options.signal).then((({data:t,type:s})=>(e.mimeType=s,t)));i.promises.push(t.writeAsync(r).then((()=>{t.finalize()})))}e.bufferView=t.index;break}case V.DataURI:if(O(s)){Z().warnOnce("Image export for basis compressed textures not available.");break}e.uri=S(s);break;default:if(O(s)){Z().warnOnce("Image export for basis compressed textures not available.");break}i.promises.push(j(s,this.options.signal).then((({data:t,type:s})=>{e.uri=t,e.mimeType=s})))}}const i=this.gltf.images.length;return this.gltf.images.push(e),this._imageMap.set(t,i),i}_addSampler(t){this.gltf.samplers||(this.gltf.samplers=[]);let s=y.REPEAT,e=y.REPEAT;if("string"==typeof t.wrap)switch(t.wrap){case"clamp":s=y.CLAMP_TO_EDGE,e=y.CLAMP_TO_EDGE;break;case"mirror":s=y.MIRRORED_REPEAT,e=y.MIRRORED_REPEAT}else{switch(t.wrap.vertical){case"clamp":e=y.CLAMP_TO_EDGE;break;case"mirror":e=y.MIRRORED_REPEAT}switch(t.wrap.horizontal){case"clamp":s=y.CLAMP_TO_EDGE;break;case"mirror":s=y.MIRRORED_REPEAT}}const i={wrapS:s,wrapT:e};for(let t=0;t<this.gltf.samplers.length;++t)if(JSON.stringify(i)===JSON.stringify(this.gltf.samplers[t]))return t;const r=this.gltf.samplers.length;return this.gltf.samplers.push(i),r}_addAccessor(t,s){this.gltf.accessors||(this.gltf.accessors=[]);const e={bufferView:t,byteOffset:s.byteOffset,componentType:s.componentType,count:s.count,type:s.type,min:s.min,max:s.max,name:s.name};s.normalized&&(e.normalized=!0);const i=this.gltf.accessors.length;return this.gltf.accessors.push(e),i}_addMeshVertexIndexed(t,s,e,i,r,n,o,a){const h=new Map;for(const c of s){t.startAccessor("INDICES");for(let s=0;s<c.faces.length;++s)t.push(c.faces[s]);const s=t.endAccessor(),f={attributes:{POSITION:i},indices:this._addAccessor(t.index,s),material:this._addMaterial(c.material)};r&&"flat"!==c.shading&&(f.attributes.NORMAL=r),n&&(f.attributes.TEXCOORD_0=n),o&&"flat"!==c.shading&&(f.attributes.TANGENT=o),a&&(f.attributes.COLOR_0=a);const u=h.get(c.name);if(u)u.primitives.push(f);else{const t={name:c.name,primitives:[f]};h.set(c.name,t),e.push(t)}}}_addMeshVertexNonIndexed(t,s,e,i,r,n,o){const a={primitives:[]};s.push(a);const h={attributes:{POSITION:e}};i&&(h.attributes.NORMAL=i),r&&(h.attributes.TEXCOORD_0=r),n&&(h.attributes.TANGENT=n),o&&(h.attributes.COLOR_0=o),t&&(h.material=this._addMaterial(t[0].material)),a.primitives.push(h)}}function st({position:t,normal:s,tangent:e}){et(t,3),et(s,3),et(e,4)}function et(t,s){if(null!=t)for(let e=1,i=2;e<t.length;e+=s,i+=s){const s=t[e],r=t[i];t[e]=r,t[i]=-s}}class it{constructor(){this.copyright="",this.defaultScene=0,this.generator="",this._scenes=[]}addScene(t){if(this._scenes.includes(t))throw new Error("Scene already added");this._scenes.push(t)}removeScene(t){g(this._scenes,t)}forEachScene(t){this._scenes.forEach(t)}}class rt{constructor(){this.name="",this._nodes=[]}addNode(t){if(this._nodes.includes(t))throw new Error("Node already added");this._nodes.push(t)}forEachNode(t){this._nodes.forEach(t)}}class nt{constructor(t){this.mesh=t,this.name="",this.translation=c(),this.rotation=N(),this.scale=m(w),this._nodes=[]}addNode(t){if(this._nodes.includes(t))throw new Error("Node already added");this._nodes.push(t)}forEachNode(t){this._nodes.forEach(t)}set rotationAngles(t){A(this.rotation,t[0],t[1],t[2])}}const ot="model.gltf",at="model.glb";async function ht(s,e){const i=new tt(s,e).gltf,r=i.extras.promises;let n=1,o=1,a=null;await Promise.allSettled(r),t(e.signal);const h=e.jsonSpacing??4,c=new Map,f=JSON.stringify(i,((t,s)=>{if("extras"!==t){if(s instanceof ArrayBuffer){if(L(s))switch(e.output?.image){case V.DataURI:case V.GLB:break;case V.External:default:{const t=`img${o}.png`;return o++,c.set(t,s),t}}switch(e.output?.buffer){case k.DataURI:return x(s);case k.GLB:if(a)throw new Error("Already encountered an ArrayBuffer, there should only be one in the GLB format.");return void(a=s);case k.External:default:{const t=`data${n}.bin`;return n++,c.set(t,s),t}}}return s}}),h);return e.output?.buffer===k.GLB||e.output?.image===V.GLB?c.set(at,new R(f,a).buffer):c.set(ot,f),c}async function ct(t,s){const e=(await ht(t,{output:{buffer:k.GLB,image:V.GLB},jsonSpacing:0,...s})).get(at);if(!(e&&e instanceof ArrayBuffer))throw new Error("failed to export to glb");return e}async function ft(t,s){const e=new it,i=new rt;return e.addScene(i),i.addNode(new nt(t)),await ct(e,{origin:t.origin,...s})}export{ft as toBinaryGLTF};
//# sourceMappingURL=p-f8f210a5.js.map