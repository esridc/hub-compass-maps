{"version":3,"names":["componentsWithInputEvent","getClearValidationEventName","componentTag","componentTagCamelCase","split","map","part","index","toUpperCase","slice","join","clearValidationEvent","includes","hiddenFormInputSlotName","isCheckable","component","onFormResetMap","WeakMap","formComponentSet","WeakSet","hasRegisteredFormComponentParent","form","formComponentEl","hasParentComponentWithFormIdSet","closestElementCrossShadowBoundary","parentElement","formComponentRegisterEventName","addEventListener","event","composedPath","some","element","has","stopPropagation","once","dispatchEvent","CustomEvent","bubbles","composed","clearFormValidation","status","validationIcon","validationMessage","setInvalidFormValidation","message","displayValidationMessage","hiddenInput","target","formComponent","nodeName","toLowerCase","componentTagParts","length","preventDefault","submitForm","formEl","requestSubmit","removeEventListener","requestAnimationFrame","invalidEls","querySelectorAll","el","setFocus","resetForm","reset","connectForm","value","associatedForm","findAssociatedForm","defaultValue","defaultChecked","checked","boundOnFormReset","onFormReset","bind","set","add","queryElementRoots","id","this","disconnectForm","get","delete","afterConnectDefaultValueSet","internalHiddenInputInputEvent","hiddenInputInputHandler","removeHiddenInputChangeEventListener","input","syncHiddenFormInput","name","ownerDocument","inputs","forEach","remove","values","Array","isArray","extra","seen","Set","valueMatch","find","val","defaultSyncHiddenFormInput","push","docFrag","pop","createElement","slot","createDocumentFragment","append","disabled","required","tabIndex","setAttribute","removeAttribute","HiddenFormInputSlot","h"],"sources":["./node_modules/@arcgis/core/node_modules/@esri/calcite-components/dist/components/form.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.\n * v2.7.0\n */\nimport { q as queryElementRoots, c as closestElementCrossShadowBoundary } from './dom.js';\nimport { h } from '@stencil/core/internal/client/index.js';\n\n/**\n * Any form <Component> with a `calcite<Component>Input` event needs to be included in this array.\n */\nconst componentsWithInputEvent = [\n    \"calcite-input\",\n    \"calcite-input-number\",\n    \"calcite-input-text\",\n    \"calcite-text-area\",\n];\n/**\n * Get the event name to listen for that, when emitted, will clear the\n * validation message that displays after form submission. Only validation\n * messages that are set by the browser will be cleared. If a user sets\n * validationMessage to a custom value, they are responsible for clearing it.\n *\n * Exported for testing purposes.\n *\n * @param componentTag the tag of the component, e.g. \"calcite-input\"\n * @returns the event name\n */\nfunction getClearValidationEventName(componentTag) {\n    const componentTagCamelCase = componentTag\n        .split(\"-\")\n        .map((part, index) => index === 0 ? part : `${part[0].toUpperCase()}${part.slice(1)}`)\n        .join(\"\");\n    const clearValidationEvent = `${componentTagCamelCase}${componentsWithInputEvent.includes(componentTag) ? \"Input\" : \"Change\"}`;\n    return clearValidationEvent;\n}\n/**\n * Exported for testing purposes.\n */\nconst hiddenFormInputSlotName = \"hidden-form-input\";\nfunction isCheckable(component) {\n    return \"checked\" in component;\n}\nconst onFormResetMap = new WeakMap();\nconst formComponentSet = new WeakSet();\n/**\n * This helps determine if our form component is part of a composite form-associated component.\n *\n * @param form\n * @param formComponentEl\n */\nfunction hasRegisteredFormComponentParent(form, formComponentEl) {\n    // if we have a parent component using the form ID attribute, we assume it is form-associated\n    const hasParentComponentWithFormIdSet = closestElementCrossShadowBoundary(formComponentEl.parentElement, \"[form]\");\n    if (hasParentComponentWithFormIdSet) {\n        return true;\n    }\n    // we use events as a way to test for nested form-associated components across shadow bounds\n    const formComponentRegisterEventName = \"calciteInternalFormComponentRegister\";\n    let hasRegisteredFormComponentParent = false;\n    form.addEventListener(formComponentRegisterEventName, (event) => {\n        hasRegisteredFormComponentParent = event\n            .composedPath()\n            .some((element) => formComponentSet.has(element));\n        event.stopPropagation();\n    }, { once: true });\n    formComponentEl.dispatchEvent(new CustomEvent(formComponentRegisterEventName, {\n        bubbles: true,\n        composed: true,\n    }));\n    return hasRegisteredFormComponentParent;\n}\nfunction clearFormValidation(component) {\n    \"status\" in component && (component.status = \"idle\");\n    \"validationIcon\" in component && (component.validationIcon = false);\n    \"validationMessage\" in component && (component.validationMessage = \"\");\n}\nfunction setInvalidFormValidation(component, message) {\n    \"status\" in component && (component.status = \"invalid\");\n    \"validationIcon\" in component && !component.validationIcon && (component.validationIcon = true);\n    \"validationMessage\" in component &&\n        !component.validationMessage &&\n        (component.validationMessage = message);\n}\nfunction displayValidationMessage(event) {\n    // target is the hidden input, which is slotted in the actual form component\n    const hiddenInput = event?.target;\n    // not necessarily a calcite-input, but we don't have an HTMLCalciteFormElement type\n    const formComponent = hiddenInput?.parentElement;\n    const componentTag = formComponent?.nodeName?.toLowerCase();\n    const componentTagParts = componentTag?.split(\"-\");\n    if (componentTagParts.length < 2 || componentTagParts[0] !== \"calcite\") {\n        return;\n    }\n    // prevent the browser from showing the native validation popover\n    event?.preventDefault();\n    setInvalidFormValidation(formComponent, hiddenInput?.validationMessage);\n    if (formComponent?.validationMessage !== hiddenInput?.validationMessage) {\n        return;\n    }\n    const clearValidationEvent = getClearValidationEventName(componentTag);\n    formComponent.addEventListener(clearValidationEvent, () => clearFormValidation(formComponent), {\n        once: true,\n    });\n}\n/**\n * Helper to submit a form.\n *\n * @param component\n * @returns true if its associated form was submitted, false otherwise.\n */\nfunction submitForm(component) {\n    const { formEl } = component;\n    if (!formEl) {\n        return false;\n    }\n    formEl.addEventListener(\"invalid\", displayValidationMessage, true);\n    formEl.requestSubmit();\n    formEl.removeEventListener(\"invalid\", displayValidationMessage, true);\n    requestAnimationFrame(() => {\n        const invalidEls = formEl.querySelectorAll(\"[status=invalid]\");\n        // focus the first invalid element that has a validation message\n        for (const el of invalidEls) {\n            if (el?.validationMessage) {\n                el?.setFocus();\n                break;\n            }\n        }\n    });\n    return true;\n}\n/**\n * Helper to reset a form.\n *\n * @param component\n */\nfunction resetForm(component) {\n    component.formEl?.reset();\n}\n/**\n * Helper to set up form interactions on connectedCallback.\n *\n * @param component\n */\nfunction connectForm(component) {\n    const { el, value } = component;\n    const associatedForm = findAssociatedForm(component);\n    if (!associatedForm || hasRegisteredFormComponentParent(associatedForm, el)) {\n        return;\n    }\n    component.formEl = associatedForm;\n    component.defaultValue = value;\n    if (isCheckable(component)) {\n        component.defaultChecked = component.checked;\n    }\n    const boundOnFormReset = (component.onFormReset || onFormReset).bind(component);\n    associatedForm.addEventListener(\"reset\", boundOnFormReset);\n    onFormResetMap.set(component.el, boundOnFormReset);\n    formComponentSet.add(el);\n}\n/**\n * Utility method to find a form-component's associated form element.\n *\n * @param component\n */\nfunction findAssociatedForm(component) {\n    const { el, form } = component;\n    return form\n        ? queryElementRoots(el, { id: form })\n        : closestElementCrossShadowBoundary(el, \"form\");\n}\nfunction onFormReset() {\n    clearFormValidation(this);\n    if (isCheckable(this)) {\n        this.checked = this.defaultChecked;\n        return;\n    }\n    this.value = this.defaultValue;\n}\n/**\n * Helper to tear down form interactions on disconnectedCallback.\n *\n * @param component\n */\nfunction disconnectForm(component) {\n    const { el, formEl } = component;\n    if (!formEl) {\n        return;\n    }\n    const boundOnFormReset = onFormResetMap.get(el);\n    formEl.removeEventListener(\"reset\", boundOnFormReset);\n    onFormResetMap.delete(el);\n    component.formEl = null;\n    formComponentSet.delete(el);\n}\n/**\n * Helper for setting the default value on initialization after connectedCallback.\n *\n * Note that this is only needed if the default value cannot be determined on connectedCallback.\n *\n * @param component\n * @param value\n */\nfunction afterConnectDefaultValueSet(component, value) {\n    component.defaultValue = value;\n}\nconst internalHiddenInputInputEvent = \"calciteInternalHiddenInputInput\";\nconst hiddenInputInputHandler = (event) => {\n    event.target.dispatchEvent(new CustomEvent(internalHiddenInputInputEvent, { bubbles: true }));\n};\nconst removeHiddenInputChangeEventListener = (input) => input.removeEventListener(\"input\", hiddenInputInputHandler);\n/**\n * Helper for maintaining a form-associated's hidden input in sync with the component.\n *\n * Based on Ionic's approach: https://github.com/ionic-team/ionic-framework/blob/e4bf052794af9aac07f887013b9250d2a045eba3/core/src/utils/helpers.ts#L198\n *\n * @param component\n */\nfunction syncHiddenFormInput(component) {\n    const { el, formEl, name, value } = component;\n    const { ownerDocument } = el;\n    const inputs = el.querySelectorAll(`input[slot=\"${hiddenFormInputSlotName}\"]`);\n    if (!formEl || !name) {\n        inputs.forEach((input) => {\n            removeHiddenInputChangeEventListener(input);\n            input.remove();\n        });\n        return;\n    }\n    const values = Array.isArray(value) ? value : [value];\n    const extra = [];\n    const seen = new Set();\n    inputs.forEach((input) => {\n        const valueMatch = values.find((val) => \n        /* intentional non-strict equality check */\n        val == input.value);\n        if (valueMatch != null) {\n            seen.add(valueMatch);\n            defaultSyncHiddenFormInput(component, input, valueMatch);\n        }\n        else {\n            extra.push(input);\n        }\n    });\n    let docFrag;\n    values.forEach((value) => {\n        if (seen.has(value)) {\n            return;\n        }\n        let input = extra.pop();\n        if (!input) {\n            input = ownerDocument.createElement(\"input\");\n            input.slot = hiddenFormInputSlotName;\n        }\n        if (!docFrag) {\n            docFrag = ownerDocument.createDocumentFragment();\n        }\n        docFrag.append(input);\n        // emits when hidden input is autofilled\n        input.addEventListener(\"input\", hiddenInputInputHandler);\n        defaultSyncHiddenFormInput(component, input, value);\n    });\n    if (docFrag) {\n        el.append(docFrag);\n    }\n    extra.forEach((input) => {\n        removeHiddenInputChangeEventListener(input);\n        input.remove();\n    });\n}\nfunction defaultSyncHiddenFormInput(component, input, value) {\n    const { defaultValue, disabled, form, name, required } = component;\n    // keep in sync to prevent losing reset value\n    input.defaultValue = defaultValue;\n    input.disabled = disabled;\n    input.name = name;\n    input.required = required;\n    input.tabIndex = -1;\n    // we set the attr as the prop is read-only\n    if (form) {\n        input.setAttribute(\"form\", form);\n    }\n    else {\n        input.removeAttribute(\"form\");\n    }\n    if (isCheckable(component)) {\n        input.checked = component.checked;\n        // keep in sync to prevent losing reset value\n        input.defaultChecked = component.defaultChecked;\n        // heuristic to support default/on mode from https://html.spec.whatwg.org/multipage/input.html#dom-input-value-default-on\n        input.value = component.checked ? value || \"on\" : \"\";\n    }\n    else {\n        input.value = value || \"\";\n    }\n    component.syncHiddenFormInput?.(input);\n}\n/**\n * Helper to render the slot for form-associated component's hidden input.\n *\n * If the component has a default slot, this must be placed at the bottom of the component's root container to ensure it is the last child.\n *\n * render(): VNode {\n *   <Host>\n *     <div class={CSS.container}>\n *     // ...\n *     <HiddenFormInputSlot component={this} />\n *     </div>\n *   </Host>\n * }\n *\n * Note that the hidden-form-input Sass mixin must be added to the component's style to apply specific styles.\n *\n * @param root0\n * @param root0.component\n */\nconst HiddenFormInputSlot = ({ component, }) => {\n    syncHiddenFormInput(component);\n    return h(\"slot\", { name: hiddenFormInputSlotName });\n};\n\nexport { HiddenFormInputSlot as H, afterConnectDefaultValueSet as a, connectForm as c, disconnectForm as d, findAssociatedForm as f, internalHiddenInputInputEvent as i, resetForm as r, submitForm as s };\n\n//# sourceMappingURL=form.js.map"],"mappings":"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"}