import{h0 as e,kV as t,h1 as s,hq as i,hr as r,hs as a,ht as o,kq as n,kA as l,kz as h,fa as p,du as d,ld as c,lX as m,gr as u,fq as f,dP as y,U as g,cB as v,dr as b,kB as j,kW as w,a as x,X as S,an as I,ao as k,l4 as T,fx as q,fv as E,fg as F,hw as M,ap as R,lH as A}from"./p-3013819f.js";import{m as B,f as L,Y as P}from"./p-6868ac29.js";import{t as z}from"./p-ca143f53.js";import"./p-3b51db5e.js";import"./p-a6f8f87f.js";import"./p-c2c5c63d.js";import"./p-d9641be7.js";import"./p-71d25f62.js";import"./p-a71453e3.js";import"./p-ad726e47.js";import"./p-94b15954.js";import"./p-1f0b604e.js";import"./p-347800d3.js";import"./p-8b19323a.js";import"./p-72299f2e.js";import"./p-ec95a4fb.js";let O=class extends(e(t(s(B(L(i(r(a(o(n(l(h(p))))))))))))){constructor(...e){super(...e),this.dateFieldsTimeZone=null,this.datesInUnknownTimezone=!1,this.dpi=96,this.gdbVersion=null,this.imageFormat="png24",this.imageMaxHeight=2048,this.imageMaxWidth=2048,this.imageTransparency=!0,this.isReference=null,this.labelsVisible=!1,this.operationalLayerType="ArcGISMapServiceLayer",this.preferredTimeZone=null,this.sourceJSON=null,this.sublayers=null,this.type="map-image",this.url=null}normalizeCtorArgs(e,t){return"string"==typeof e?{url:e,...t}:e}load(e){const t=null!=e?e.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Map Service"]},e).catch(d).then((()=>this._fetchService(t)))),Promise.resolve(this)}readImageFormat(e,t){const s=t.supportedImageFormatTypes;return s&&s.includes("PNG32")?"png32":"png24"}writeSublayers(e,t,s,i){if(!this.loaded||!e)return;const r=e.slice().reverse().flatten((({sublayers:e})=>e&&e.toArray().reverse())).toArray();let a=!1;if(this.capabilities?.operations.supportsExportMap&&this.capabilities?.exportMap?.supportsDynamicLayers){const e=A(i.origin);if(e===c.PORTAL_ITEM){const e=this.createSublayersForOrigin("service").sublayers;a=m(r,e,c.SERVICE)}else if(e>c.PORTAL_ITEM){const e=this.createSublayersForOrigin("portal-item");a=m(r,e.sublayers,A(e.origin))}}const o=[],n={writeSublayerStructure:a,...i};let l=a;r.forEach((e=>{const t=e.write({},n);o.push(t),l=l||"user"===e.originOf("visible")}));o.some((e=>Object.keys(e).length>1))&&(t.layers=o),l&&(t.visibleLayers=r.filter((e=>e.visible)).map((e=>e.id)))}createExportImageParameters(e,t,s,i){const r=i?.pixelRatio||1;e&&this.version>=10&&(e=e.clone().shiftCentralMeridian());const a=new u({layer:this,floors:i?.floors,scale:f({extent:e,width:t})*r}),o=a.toJSON();a.destroy();const n=!i?.rotation||this.version<10.3?{}:{rotation:-i.rotation},l=e?.spatialReference,h=y(l);o.dpi*=r;const p={};if(i?.timeExtent){const{start:e,end:t}=i.timeExtent.toJSON();p.time=e&&t&&e===t?""+e:`${e??"null"},${t??"null"}`}else this.timeInfo&&!this.timeInfo.hasLiveData&&(p.time="null,null");return{bbox:e&&e.xmin+","+e.ymin+","+e.xmax+","+e.ymax,bboxSR:h,imageSR:h,size:t+","+s,...o,...n,...p}}async fetchImage(e,t,s,i){const{data:r}=await this._fetchImage("image",e,t,s,i);return r}async fetchImageBitmap(e,t,s,i){const{data:r,url:a}=await this._fetchImage("blob",e,t,s,i);return z(r,a,i?.signal)}async fetchRecomputedExtents(e={}){const t={...e,query:{returnUpdates:!0,f:"json",...this.customParameters,token:this.apiKey}},{data:s}=await g(this.url,t),{extent:i,fullExtent:r,timeExtent:a}=s,o=i||r;return{fullExtent:o&&v.fromJSON(o),timeExtent:a&&b.fromJSON({start:a[0],end:a[1]})}}loadAll(){return j(this,(e=>{e(this.allSublayers)}))}serviceSupportsSpatialReference(e){return w(this,e)}async _fetchImage(e,t,s,i,r){const a={responseType:e,signal:r?.signal??null,query:{...this.parsedUrl.query,...this.createExportImageParameters(t,s,i,r),f:"image",...this.refreshParameters,...this.customParameters,token:this.apiKey}},o=this.parsedUrl.path+"/export";if(null!=a.query?.dynamicLayers&&!this.capabilities?.exportMap?.supportsDynamicLayers)throw new x("mapimagelayer:dynamiclayer-not-supported",`service ${this.url} doesn't support dynamic layers, which is required to be able to change the sublayer's order, rendering, labeling or source.`,{query:a.query});try{const{data:e}=await g(o,a);return{data:e,url:o}}catch(e){if(S(e))throw e;throw new x("mapimagelayer:image-fetch-error",`Unable to load image: ${o}`,{error:e})}}async _fetchService(e){if(this.sourceJSON)return void this.read(this.sourceJSON,{origin:"service",url:this.parsedUrl});const{data:t,ssl:s}=await g(this.parsedUrl.path,{query:{f:"json",...this.parsedUrl.query,...this.customParameters,token:this.apiKey},signal:e});s&&(this.url=this.url.replace(/^http:/i,"https:")),this.sourceJSON=t,this.read(t,{origin:"service",url:this.parsedUrl})}};I([k(T("dateFieldsTimeReference"))],O.prototype,"dateFieldsTimeZone",void 0),I([k({type:Boolean})],O.prototype,"datesInUnknownTimezone",void 0),I([k()],O.prototype,"dpi",void 0),I([k()],O.prototype,"gdbVersion",void 0),I([k()],O.prototype,"imageFormat",void 0),I([q("imageFormat",["supportedImageFormatTypes"])],O.prototype,"readImageFormat",null),I([k({json:{origins:{service:{read:{source:"maxImageHeight"}}}}})],O.prototype,"imageMaxHeight",void 0),I([k({json:{origins:{service:{read:{source:"maxImageWidth"}}}}})],O.prototype,"imageMaxWidth",void 0),I([k()],O.prototype,"imageTransparency",void 0),I([k({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],O.prototype,"isReference",void 0),I([k({json:{read:!1,write:!1}})],O.prototype,"labelsVisible",void 0),I([k({type:["ArcGISMapServiceLayer"]})],O.prototype,"operationalLayerType",void 0),I([k({json:{read:!1,write:!1}})],O.prototype,"popupEnabled",void 0),I([k(T("preferredTimeReference"))],O.prototype,"preferredTimeZone",void 0),I([k()],O.prototype,"sourceJSON",void 0),I([k({json:{write:{ignoreOrigin:!0}}})],O.prototype,"sublayers",void 0),I([E("sublayers",{layers:{type:[P]},visibleLayers:{type:[F]}})],O.prototype,"writeSublayers",null),I([k({type:["show","hide","hide-children"]})],O.prototype,"listMode",void 0),I([k({json:{read:!1},readOnly:!0,value:"map-image"})],O.prototype,"type",void 0),I([k(M)],O.prototype,"url",void 0),O=I([R("esri.layers.MapImageLayer")],O);const $=O;export default $;
//# sourceMappingURL=p-7cad7ca6.js.map