import{fI as n,b$ as e,av as t}from"./p-3013819f.js";import"./p-3b51db5e.js";function a(n){return Array.isArray(n)?n[0]?.spatialReference:n?.spatialReference}function r(n){return n?Array.isArray(n)?n.map(r):n.toJSON?n.toJSON():n:n}function i(n){return Array.isArray(n)?n.map((n=>e(n))):e(n)}function s(n,e){let t;return Array.isArray(n)?t=n:(t=[],t.push(n),null!=e&&t.push(e)),t}let c;async function o(){return c||(c=n("geometryEngineWorker",{strategy:"distributed"})),c}async function u(n,e){return(await o()).invoke("executeGEOperation",{operation:n,parameters:r(e)})}async function f(n,e){const t=await o();return Promise.all(t.broadcast("executeGEOperation",{operation:n,parameters:r(e)}))}function l(n){return u("extendedSpatialReferenceInfo",[n])}async function y(n,e){return i(await u("clip",[a(n),n,e]))}async function w(n,e){return i(await u("cut",[a(n),n,e]))}function p(n,e){return u("contains",[a(n),n,e])}function d(n,e){return u("crosses",[a(n),n,e])}function g(n,e,t){return u("distance",[a(n),n,e,t])}function m(n,e){return u("equals",[a(n),n,e])}function h(n,e){return u("intersects",[a(n),n,e])}function x(n,e){return u("touches",[a(n),n,e])}function A(n,e){return u("within",[a(n),n,e])}function D(n,e){return u("disjoint",[a(n),n,e])}function S(n,e){return u("overlaps",[a(n),n,e])}function b(n,e,t){return u("relate",[a(n),n,e,t])}function L(n){return u("isSimple",[a(n),n])}async function R(n){return i(await u("simplify",[a(n),n]))}async function T(n,e=!1){return i(await u("convexHull",[a(n),n,e]))}async function V(n,e){return i(await u("difference",[a(n),n,e]))}async function v(n,e){return i(await u("symmetricDifference",[a(n),n,e]))}async function E(n,e){return i(await u("intersect",[a(n),n,e]))}async function j(n,e=null){const t=s(n,e);return i(await u("union",[a(t),t]))}async function z(n,e,t,r,s,c){return i(await u("offset",[a(n),n,e,t,r,s,c]))}async function H(n,e,t,r=!1){const s=[a(n),n,e,t,r];return i(await u("buffer",s))}async function I(n,e,t,r,s,c){const o=[a(n),n,e,t,r,s,c];return i(await u("geodesicBuffer",o))}async function P(n,e,r=!0){const i=await u("nearestCoordinate",[a(n),n,e,r]);return{...i,coordinate:t.fromJSON(i.coordinate)}}async function q(n,e){const r=await u("nearestVertex",[a(n),n,e]);return{...r,coordinate:t.fromJSON(r.coordinate)}}async function B(n,e,r,i){return(await u("nearestVertices",[a(n),n,e,r,i])).map((n=>({...n,coordinate:t.fromJSON(n.coordinate)})))}function C(n){return"xmin"in n?n.center:"x"in n?n:n.extent?.center}async function G(n,e,t){if(null==n)throw new Y;const a=n.spatialReference;if(null==(t=t??C(n)))throw new Y;const r=n.constructor.fromJSON(await u("rotate",[a,n,e,t]));return r.spatialReference=a,r}async function O(n,e){if(null==n)throw new Y;const t=n.spatialReference;if(null==(e=e??C(n)))throw new Y;const a=n.constructor.fromJSON(await u("flipHorizontal",[t,n,e]));return a.spatialReference=t,a}async function k(n,e){if(null==n)throw new Y;const t=n.spatialReference;if(null==(e=e??C(n)))throw new Y;const a=n.constructor.fromJSON(await u("flipVertical",[t,n,e]));return a.spatialReference=t,a}async function W(n,e,t,r){return i(await u("generalize",[a(n),n,e,t,r]))}async function $(n,e,t){return i(await u("densify",[a(n),n,e,t]))}async function F(n,e,t,r=0){return i(await u("geodesicDensify",[a(n),n,e,t,r]))}function J(n,e){return u("planarArea",[a(n),n,e])}function K(n,e){return u("planarLength",[a(n),n,e])}function M(n,e,t){return u("geodesicArea",[a(n),n,e,t])}function N(n,e,t){return u("geodesicLength",[a(n),n,e,t])}async function Q(n,e){return i(await u("intersectLinesToPoints",[a(n),n,e]))}async function U(n,e){await f("changeDefaultSpatialReferenceTolerance",[n,e])}async function X(n){await f("clearDefaultSpatialReferenceTolerance",[n])}class Y extends Error{constructor(){super("Illegal Argument Exception")}}export{H as buffer,U as changeDefaultSpatialReferenceTolerance,X as clearDefaultSpatialReferenceTolerance,y as clip,p as contains,T as convexHull,d as crosses,w as cut,$ as densify,V as difference,D as disjoint,g as distance,m as equals,l as extendedSpatialReferenceInfo,O as flipHorizontal,k as flipVertical,W as generalize,M as geodesicArea,I as geodesicBuffer,F as geodesicDensify,N as geodesicLength,E as intersect,Q as intersectLinesToPoints,h as intersects,L as isSimple,P as nearestCoordinate,q as nearestVertex,B as nearestVertices,z as offset,S as overlaps,J as planarArea,K as planarLength,b as relate,G as rotate,R as simplify,v as symmetricDifference,x as touches,j as union,A as within};
//# sourceMappingURL=p-bc6b9750.js.map