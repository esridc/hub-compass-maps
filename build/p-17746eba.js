import{bK as t,gY as s,as as i,ig as n,jY as e,jZ as r,i8 as h,j_ as o,a0 as c,az as a,jI as u,i7 as l,an as f,ap as d,W as m,iq as p}from"./p-3013819f.js";import{v as _,b as j,j as O}from"./p-22d74e36.js";import{d as T,O as b,p as M,Z as g,I as N,w as E,V as R,s as w}from"./p-d8a5b509.js";import{s as x}from"./p-a111f32d.js";import"./p-1f7d3618.js";import{m as A}from"./p-bc8871af.js";import"./p-3b51db5e.js";import"./p-10315be7.js";import"./p-5f148c96.js";import"./p-897991e6.js";import"./p-c887d4a8.js";import"./p-2e59108c.js";import"./p-ad63a882.js";import"./p-7020cf1b.js";import"./p-6fe73432.js";import"./p-c99b552a.js";import"./p-8567e6fe.js";import"./p-89242a33.js";function F(t){return t?{ray:T(t.ray),c0:t.c0,c1:t.c1}:{ray:T(),c0:0,c1:Number.MAX_VALUE}}new x((()=>F()));function I(t,s){for(let i=0;i<v;i++){const n=t[i];if(n[0]*s[0]+n[1]*s[1]+n[2]*s[2]+n[3]>=s[3])return!1}return!0}var y,S;!function(t){t[t.LEFT=0]="LEFT",t[t.RIGHT=1]="RIGHT",t[t.BOTTOM=2]="BOTTOM",t[t.TOP=3]="TOP",t[t.NEAR=4]="NEAR",t[t.FAR=5]="FAR"}(y||(y={})),function(t){t[t.NEAR_BOTTOM_LEFT=0]="NEAR_BOTTOM_LEFT",t[t.NEAR_BOTTOM_RIGHT=1]="NEAR_BOTTOM_RIGHT",t[t.NEAR_TOP_RIGHT=2]="NEAR_TOP_RIGHT",t[t.NEAR_TOP_LEFT=3]="NEAR_TOP_LEFT",t[t.FAR_BOTTOM_LEFT=4]="FAR_BOTTOM_LEFT",t[t.FAR_BOTTOM_RIGHT=5]="FAR_BOTTOM_RIGHT",t[t.FAR_TOP_RIGHT=6]="FAR_TOP_RIGHT",t[t.FAR_TOP_LEFT=7]="FAR_TOP_LEFT"}(S||(S={}));const v=6;new x(F);class L{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(t,s){this.objectToBoundingSphere=t,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new P,this._objectCount=0,s&&(void 0!==s.maximumObjectsPerNode&&(this._maximumObjectsPerNode=s.maximumObjectsPerNode),void 0!==s.maximumDepth&&(this._maximumDepth=s.maximumDepth))}destroy(){this._degenerateObjects.clear(),P.clearPool(),q[0]=null,$.prune(),rt.prune()}add(t,s=t.length){this._objectCount+=s,this._grow(t,s);const i=P.acquire();for(let n=0;n<s;n++){const s=t[n];this._isDegenerate(s)?this._degenerateObjects.add(s):(i.init(this._root),this._add(s,i))}P.release(i)}remove(t,s=null){this._objectCount-=t.length;const i=P.acquire();for(const n of t){const t=s??b(this.objectToBoundingSphere(n),tt);W(t[3])?(i.init(this._root),this._remove(n,t,i)):this._degenerateObjects.delete(n)}P.release(i),this._shrink()}update(t,s){if(!W(s[3])&&this._isDegenerate(t))return;const i=Y(t);this.remove(i,s),this.add(i)}forEachAlongRay(t,s,i){const n=M(t,s);this._forEachNode(this._root,(t=>{if(!this._intersectsNode(n,t))return!1;const s=t.node;return s.terminals.forAll((t=>{this._intersectsObject(n,t)&&i(t)})),null!==s.residents&&s.residents.forAll((t=>{this._intersectsObject(n,t)&&i(t)})),!0}))}forEachAlongRayWithVerticalOffset(t,s,i,n){const e=M(t,s);this._forEachNode(this._root,(t=>{if(!this._intersectsNodeWithOffset(e,t,n))return!1;const s=t.node;return s.terminals.forAll((t=>{this._intersectsObjectWithOffset(e,t,n)&&i(t)})),null!==s.residents&&s.residents.forAll((t=>{this._intersectsObjectWithOffset(e,t,n)&&i(t)})),!0}))}forEach(t){this._forEachNode(this._root,(s=>{const i=s.node;return i.terminals.forAll(t),null!==i.residents&&i.residents.forAll(t),!0})),this._degenerateObjects.forEach(t)}forEachDegenerateObject(t){this._degenerateObjects.forEach(t)}findClosest(t,s,e,r=(()=>!0),h=1/0){let o=1/0,c=1/0,a=null;const u=z(t,s),l=i=>{if(--h,!r(i))return;const n=this.objectToBoundingSphere(i);if(!I(e,n))return;const u=G(t,s,g(n)),l=u-n[3],f=u+n[3];l<o&&(o=l,c=f,a=i)};return this._forEachNodeDepthOrdered(this._root,(r=>{if(h<=0||!I(e,r.bounds))return!1;i(Q,u,r.halfSize),n(Q,Q,g(r.bounds));if(G(t,s,Q)>c)return!1;const o=r.node;return o.terminals.forAll((t=>l(t))),null!==o.residents&&o.residents.forAll((t=>l(t))),!0}),t,s),a}forEachInDepthRange(t,s,e,r,h,o,c){let a=-1/0,u=1/0;const l={setRange:t=>{e===L.DepthOrder.FRONT_TO_BACK?(a=Math.max(a,t.near),u=Math.min(u,t.far)):(a=Math.max(a,-t.far),u=Math.min(u,-t.near))}};l.setRange(r);const f=G(s,e,t),d=z(s,e),m=z(s,-e),p=t=>{if(!c(t))return;const i=this.objectToBoundingSphere(t),n=g(i),r=G(s,e,n)-f,d=r-i[3],m=r+i[3];d>u||m<a||!I(o,i)||h(t,l)};this._forEachNodeDepthOrdered(this._root,(t=>{if(!I(o,t.bounds))return!1;i(Q,d,t.halfSize),n(Q,Q,g(t.bounds));if(G(s,e,Q)-f>u)return!1;i(Q,m,t.halfSize),n(Q,Q,g(t.bounds));if(G(s,e,Q)-f<a)return!1;const r=t.node;return r.terminals.forAll((t=>p(t))),null!==r.residents&&r.residents.forAll((t=>p(t))),!0}),s,e)}forEachNode(t){this._forEachNode(this._root,(s=>t(s.node,s.bounds,s.halfSize,s.depth)))}forEachNeighbor(t,s){const i=R(s),n=g(s),r=s=>{const r=this.objectToBoundingSphere(s),h=R(r),o=i+h;return!(e(g(r),n)-o*o<=0)||t(s)};let h=!0;const o=t=>{h&&(h=r(t))};this._forEachNode(this._root,(t=>{const s=R(t.bounds),r=i+s;if(e(g(t.bounds),n)-r*r>0)return!1;const c=t.node;return c.terminals.forAll(o),h&&null!==c.residents&&c.residents.forAll(o),h})),h&&this.forEachDegenerateObject(o)}_intersectsNode(t,s){return D(g(s.bounds),2*-s.halfSize,U),D(g(s.bounds),2*s.halfSize,X),r(t.origin,t.direction,U,X)}_intersectsNodeWithOffset(t,s,i){return D(g(s.bounds),2*-s.halfSize,U),D(g(s.bounds),2*s.halfSize,X),i.applyToMinMax(U,X),r(t.origin,t.direction,U,X)}_intersectsObject(t,s){const i=this.objectToBoundingSphere(s);return!(i[3]>0)||N(i,t)}_intersectsObjectWithOffset(t,s,i){const n=this.objectToBoundingSphere(s);return!(n[3]>0)||N(i.applyToBoundingSphere(n),t)}_forEachNode(t,s){let i=P.acquire().init(t);const n=[i];for(;0!==n.length;){if(i=n.pop(),s(i)&&!i.isLeaf())for(let t=0;t<i.node.children.length;t++){i.node.children[t]&&n.push(P.acquire().init(i).advance(t))}P.release(i)}}_forEachNodeDepthOrdered(t,s,i,n=L.DepthOrder.FRONT_TO_BACK){let e=P.acquire().init(t);const r=[e];for(H(i,n,ht);0!==r.length;){if(e=r.pop(),s(e)&&!e.isLeaf())for(let t=7;t>=0;--t){const s=ht[t];e.node.children[s]&&r.push(P.acquire().init(e).advance(s))}P.release(e)}}_remove(t,s,i){$.clear();const n=i.advanceTo(s,((t,s)=>{$.push(t.node),$.push(s)}))?i.node.terminals:i.node.residents;if(n.removeUnordered(t),0===n.length)for(let t=$.length-2;t>=0;t-=2){const s=$.data[t],i=$.data[t+1];if(!this._purge(s,i))break}}_nodeIsEmpty(t){if(0!==t.terminals.length)return!1;if(null!==t.residents)return 0===t.residents.length;for(let s=0;s<t.children.length;s++)if(t.children[s])return!1;return!0}_purge(t,i){return i>=0&&(t.children[i]=null),!!this._nodeIsEmpty(t)&&(null===t.residents&&(t.residents=new s({shrink:!0})),!0)}_add(t,s){s.advanceTo(this.objectToBoundingSphere(t))?s.node.terminals.push(t):(s.node.residents.push(t),s.node.residents.length>this._maximumObjectsPerNode&&s.depth<this._maximumDepth&&this._split(s))}_split(t){const s=t.node.residents;t.node.residents=null;for(let i=0;i<s.length;i++){const n=P.acquire().init(t);this._add(s.at(i),n),P.release(n)}}_grow(t,s){if(0!==s&&(k(t,s,(t=>this.objectToBoundingSphere(t)),st),W(st[3])&&!this._fitsInsideTree(st)))if(this._nodeIsEmpty(this._root.node))b(st,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],this._root.updateBoundsRadiusFromHalfSize();else{const t=this._rootBoundsForRootAsSubNode(st);this._placingRootViolatesMaxDepth(t)?this._rebuildTree(st,t):this._growRootAsSubNode(t),P.release(t)}}_rebuildTree(t,s){h(g(it),g(s.bounds)),it[3]=s.halfSize,k([t,it],2,(t=>t),nt);const i=P.acquire().init(this._root);this._root.initFrom(null,nt,nt[3]),this._root.increaseHalfSize(1.25),this._forEachNode(i,(t=>(this.add(t.node.terminals.data,t.node.terminals.length),null!==t.node.residents&&this.add(t.node.residents.data,t.node.residents.length),!0))),P.release(i)}_placingRootViolatesMaxDepth(t){const s=Math.log(t.halfSize/this._root.halfSize)*Math.LOG2E;let i=0;return this._forEachNode(this._root,(t=>(i=Math.max(i,t.depth),i+s<=this._maximumDepth))),i+s>this._maximumDepth}_rootBoundsForRootAsSubNode(t){const s=t[3],i=t;let n=-1/0;const e=this._root.bounds,r=this._root.halfSize;for(let t=0;t<3;t++){const h=e[t]-r-(i[t]-s),o=i[t]+s-(e[t]+r),c=Math.max(0,Math.ceil(h/(2*r))),a=Math.max(0,Math.ceil(o/(2*r)))+1,u=2**Math.ceil(Math.log(c+a)*Math.LOG2E);n=Math.max(n,u),et[t].min=c,et[t].max=a}for(let t=0;t<3;t++){let s=et[t].min,i=et[t].max;const h=(n-(s+i))/2;s+=Math.ceil(h),i+=Math.floor(h);const o=e[t]-r-s*r*2;Z[t]=o+(i+s)*r}const h=n*r;return Z[3]=h*V,P.acquire().initFrom(null,Z,h,0)}_growRootAsSubNode(t){const s=this._root.node;h(g(st),g(this._root.bounds)),st[3]=this._root.halfSize,this._root.init(t),t.advanceTo(st,null,!0),t.node.children=s.children,t.node.residents=s.residents,t.node.terminals=s.terminals}_shrink(){for(;;){const t=this._findShrinkIndex();if(-1===t)break;this._root.advance(t),this._root.depth=0}}_findShrinkIndex(){if(0!==this._root.node.terminals.length||this._root.isLeaf())return-1;let t=null;const s=this._root.node.children;let i=0,n=0;for(;n<s.length&&null==t;)i=n++,t=s[i];for(;n<s.length;)if(s[n++])return-1;return i}_isDegenerate(t){return!W(this.objectToBoundingSphere(t)[3])}_fitsInsideTree(t){const s=this._root.bounds,i=this._root.halfSize;return t[3]<=i&&t[0]>=s[0]-i&&t[0]<=s[0]+i&&t[1]>=s[1]-i&&t[1]<=s[1]+i&&t[2]>=s[2]-i&&t[2]<=s[2]+i}toJSON(){const{maximumDepth:t,maximumObjectsPerNode:s,_objectCount:i}=this,n=this._nodeToJSON(this._root.node);return{maximumDepth:t,maximumObjectsPerNode:s,objectCount:i,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:n}}}_nodeToJSON(t){const s=t.children.map((t=>t?this._nodeToJSON(t):null)),i=t.residents?.map((t=>this.objectToBoundingSphere(t))),n=t.terminals?.map((t=>this.objectToBoundingSphere(t)));return{children:s,residents:i,terminals:n}}static fromJSON(t){const s=new L((t=>t),{maximumDepth:t.maximumDepth,maximumObjectsPerNode:t.maximumObjectsPerNode});return s._objectCount=t.objectCount,s._root.initFrom(t.root.node,t.root.bounds,t.root.halfSize,t.root.depth),s}}class P{constructor(){this.bounds=E(),this.halfSize=0,this.initFrom(null,null,0,0)}init(t){return this.initFrom(t.node,t.bounds,t.halfSize,t.depth)}initFrom(t,s,i,n=this.depth){return this.node=null!=t?t:P.createEmptyNode(),s&&b(s,this.bounds),this.halfSize=i,this.depth=n,this}increaseHalfSize(t){this.halfSize*=t,this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*V}advance(t){let s=this.node.children[t];s||(s=P.createEmptyNode(),this.node.children[t]=s),this.node=s,this.halfSize/=2,this.depth++;const i=J[t];return this.bounds[0]+=i[0]*this.halfSize,this.bounds[1]+=i[1]*this.halfSize,this.bounds[2]+=i[2]*this.halfSize,this.updateBoundsRadiusFromHalfSize(),this}advanceTo(t,s,i=!1){for(;;){if(this.isTerminalFor(t))return s&&s(this,-1),!0;if(this.isLeaf()){if(!i)return s&&s(this,-1),!1;this.node.residents=null}const n=this._childIndex(t);s&&s(this,n),this.advance(n)}}isLeaf(){return null!=this.node.residents}isTerminalFor(t){return t[3]>this.halfSize/2}_childIndex(t){const s=this.bounds;return(s[0]<t[0]?1:0)+(s[1]<t[1]?2:0)+(s[2]<t[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new s({shrink:!0}),residents:new s({shrink:!0})}}static acquire(){return P._pool.acquire()}static release(t){P._pool.release(t)}static clearPool(){P._pool.prune()}}function C(t,s){t[0]=Math.min(t[0],s[0]-s[3]),t[1]=Math.min(t[1],s[1]-s[3]),t[2]=Math.min(t[2],s[2]-s[3])}function B(t,s){t[0]=Math.max(t[0],s[0]+s[3]),t[1]=Math.max(t[1],s[1]+s[3]),t[2]=Math.max(t[2],s[2]+s[3])}function D(t,s,i){i[0]=t[0]+s,i[1]=t[1]+s,i[2]=t[2]+s}function k(t,s,i,n){if(1===s){const s=i(t[0]);b(s,n)}else{U[0]=1/0,U[1]=1/0,U[2]=1/0,X[0]=-1/0,X[1]=-1/0,X[2]=-1/0;for(let n=0;n<s;n++){const s=i(t[n]);W(s[3])&&(C(U,s),B(X,s))}o(g(n),U,X,.5),n[3]=Math.max(X[0]-U[0],X[1]-U[1],X[2]-U[2])/2}}function H(t,s,i){if(!rt.length)for(let t=0;t<8;++t)rt.push({index:0,distance:0});for(let i=0;i<8;++i){const n=J[i];rt.data[i].index=i,rt.data[i].distance=G(t,s,n)}rt.sort(((t,s)=>t.distance-s.distance));for(let t=0;t<8;++t)i[t]=rt.data[t].index}function z(t,s){let i,n=1/0;for(let e=0;e<8;++e){const r=G(t,s,K[e]);r<n&&(n=r,i=K[e])}return i}function G(t,s,i){return s*(t[0]*i[0]+t[1]*i[1]+t[2]*i[2])}function W(t){return!isNaN(t)&&t!==-1/0&&t!==1/0&&t>0}P._pool=new t(P),function(t){var s;(s=t.DepthOrder||(t.DepthOrder={}))[s.FRONT_TO_BACK=1]="FRONT_TO_BACK",s[s.BACK_TO_FRONT=-1]="BACK_TO_FRONT"}(L||(L={}));const J=[a(-1,-1,-1),a(1,-1,-1),a(-1,1,-1),a(1,1,-1),a(-1,-1,1),a(1,-1,1),a(-1,1,1),a(1,1,1)],K=[a(-1,-1,-1),a(-1,-1,1),a(-1,1,-1),a(-1,1,1),a(1,-1,-1),a(1,-1,1),a(1,1,-1),a(1,1,1)],V=Math.sqrt(3),q=[null];function Y(t){return q[0]=t,q}const Z=E(),Q=c(),U=c(),X=c(),$=new s,tt=E(),st=E(),it=E(),nt=E(),et=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],rt=new s,ht=[0,0,0,0,0,0,0,0],ot=L;const ct=1e3;function at(t,s,i){const e=E(),r=g(e);return u(r,r,t,.5),u(r,r,s,.5),e[3]=l(r,t),n(r,r,i),e}let ut=class{constructor(){this._idToComponent=new Map,this._components=new ot((t=>t.bounds)),this._edges=new ot((t=>t.bounds)),this._tmpLineSegment=_(),this._tmpP1=c(),this._tmpP2=c(),this._tmpP3=c(),this.remoteClient=null}async fetchCandidates(t,s){await Promise.resolve(),m(s),await this._ensureEdgeLocations(t,s);const i=[];return this._edges.forEachNeighbor((s=>(this._addCandidates(t,s,i),i.length<ct)),t.bounds),{result:{candidates:i}}}async _ensureEdgeLocations(t,s){const i=[];if(this._components.forEachNeighbor((t=>{if(null==t.info){const{id:s,uid:n}=t;i.push({id:s,uid:n})}return!0}),t.bounds),!i.length)return;const n={components:i},e=await this.remoteClient.invoke("fetchAllEdgeLocations",n,s??{});for(const t of e.components)this._setFetchEdgeLocations(t)}async add(t){const s=new ft(t.id,t.bounds);return this._idToComponent.set(s.id,s),this._components.add([s]),{result:{}}}async remove(t){const s=this._idToComponent.get(t.id);if(s){const t=[];this._edges.forEachNeighbor((i=>(i.component===s&&t.push(i),!0)),s.bounds),this._edges.remove(t),this._components.remove([s]),this._idToComponent.delete(s.id)}return{result:{}}}_setFetchEdgeLocations(t){const s=this._idToComponent.get(t.id);if(null==s||t.uid!==s.uid)return;const i=A.createView(t.locations),n=new Array(i.count),e=c(),r=c();for(let h=0;h<i.count;h++){i.position0.getVec(h,e),i.position1.getVec(h,r);const o=at(e,r,t.origin),c=new dt(s,h,o);n[h]=c}this._edges.add(n);const{objectIds:h,origin:o}=t;s.info={locations:i,objectIds:h,origin:o}}_addCandidates(t,s,i){const{info:e}=s.component,{origin:r,objectIds:h}=e,o=e.locations,c=o.position0.getVec(s.index,this._tmpP1),a=o.position1.getVec(s.index,this._tmpP2);n(c,c,r),n(a,a,r);const u=h[o.componentIndex.get(s.index)];this._addEdgeCandidate(t,u,c,a,i),this._addVertexCandidate(t,u,c,i),this._addVertexCandidate(t,u,a,i)}_addEdgeCandidate(t,s,i,n,e){if(!t.returnEdge)return;const r=g(t.bounds),h=j(i,n,this._tmpLineSegment),o=O(h,r,this._tmpP3);w(t.bounds,o)&&e.push({type:"edge",objectId:s,target:p(o),distance:l(r,o),start:p(i),end:p(n)})}_addVertexCandidate(t,s,i,n){if(!t.returnVertex||!w(t.bounds,i))return;const e=g(t.bounds);n.push({type:"vertex",objectId:s,target:p(i),distance:l(e,i)})}};ut=f([d("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],ut);const lt=ut;class ft{constructor(t,s){this.id=t,this.bounds=s,this.info=null,this.uid=++ft.uid}}ft.uid=0;class dt{constructor(t,s,i){this.component=t,this.index=s,this.bounds=i}}export default lt;
//# sourceMappingURL=p-17746eba.js.map