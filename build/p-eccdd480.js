import{aK as t,aL as s,aM as e,aN as i,aO as r,aP as n,aQ as h,h as o,aR as a,aS as c,aT as u,u as l,aU as d,aV as p,aW as f,am as m,aX as w,ah as y,aY as g,aZ as b,W as I,a_ as _,a$ as x,b0 as S,b1 as v,b2 as G,c as M,b3 as T,an as j,ao as R,ap as V}from"./p-028496e2.js";import{W as E,J as $,U as A,K as C}from"./p-6b5df147.js";import{a as P,O as U}from"./p-b362a32c.js";import{b as k}from"./p-b0afd947.js";import{M as D,p as F,b as z,s as O,a as X,n as L,c as Y}from"./p-18b49978.js";import{y as q,z as N,h as W,p as H,S as Z,u as Q,x as B,s as K,a as J,t as tt}from"./p-6339641f.js";import{d as st,n as et}from"./p-eaa7279e.js";import{o as it,h as rt,a as nt}from"./p-854d8fad.js";import{e as ht}from"./p-94b15954.js";import{a as ot}from"./p-f87a9f21.js";import{x as at,j as ct}from"./p-3a28ec18.js";async function ut(t,s,e){const i=[],r={scaleInfo:K(t),scaleExpression:null};for(const t of s)switch(t.type){case"marker":i.push(...Q(e.instances.marker,t,B,r));break;case"fill":null==t.spriteRasterizationParam?i.push(...H(e.instances.fill,t,r)):i.push(...Z(e.instances.complexFill,t,!1,r));break;case"line":t.spriteRasterizationParam?i.push(...N(e.instances.texturedLine,t,!1,r)):i.push(...W(e.instances.line,t,!1,r));break;case"text":i.push(...q(e.instances.text,t,B,r))}return i}class lt extends D{static from(t,s,e){return new lt(t,s,e)}constructor(t,s,e){super(e),this._items=t,this._tile=s,this._index=-1,this._cachedGeometry=null;const i=s.lod;i.wrap&&(this._wrappingInfo={worldSizeX:i.worldSize[0]})}get _current(){return this._items[this._index]}getItem(){return this._current}getZOrder(){return this._current.zOrder}getMeshWriters(){return this._current.symbolResource?.symbolInfo.meshWriters??[]}hasField(t){return null!=this._current.attributes[t]}field(t){return this.readAttribute(t)}get geometryType(){const t=e(this._current.geometry);return"esriGeometryPoint"===t?"esriGeometryMultipoint":t}getCursor(){return this.copy()}copy(){const t=new lt(this._items,this._tile,this.metadata);return this.copyInto(t),t}copyInto(t){super.copyInto(t),t._cachedGeometry=this._cachedGeometry,t._index=this._index}get fields(){throw new Error("Fields reading not supported to graphics.")}get hasFeatures(){return!!this._items.length}get hasNext(){return this._index+1<this._items.length}get exceededTransferLimit(){throw new Error("InternalError: exceededTransferLimit not implemented for graphics.")}get hasZ(){return!1}get hasM(){return!1}getInTransform(){return this._tile.transform}getSize(){return this._items.length}getAttributeHash(){let t="";for(const s in this._current.attributes)t+=this._current.attributes[s];return t}getObjectId(){return this._items[this._index].objectId}getDisplayId(){return this._current.displayId}setDisplayId(t){throw new Error("InternalError: Setting displayId not supported for graphics.")}setIndex(t){this._index=t}getIndex(){return this._index}next(){for(this._cachedGeometry=null;++this._index<this._items.length&&!this._getExists(););return this._index<this._items.length}readGeometryArea(){throw new Error("InternalError: readGeometryArea not supported for graphics.")}_readGeometry(){if(!this._cachedGeometry){let t=it(this._current.projectedGeometry,this.hasZ,this.hasM);if("esriGeometryPolyline"===this.geometryType&&(t=rt(new ht,t,this.hasZ,this.hasM,this.geometryType,this._tile.transform.scale[0])),this._cachedGeometry=nt(new ht,t,this.hasZ,this.hasM,this.geometryType,this._tile.transform),!this._cachedGeometry)return null;this._wrapGeometry(this._cachedGeometry)}return this._cachedGeometry}_wrapGeometry(t){if(!this._wrappingInfo)return;const{worldSizeX:s}=this._wrappingInfo;if(t.isPoint)return 1===s?(t.coords.push(P,0),t.coords.push(2*-P,0),void t.lengths.push(3)):2===s?(t.coords.push(2*P,0),t.coords.push(4*-P,0),void t.lengths.push(3)):void this._wrapVertex(t.coords,0,2,s);if("esriGeometryMultipoint"!==this.geometryType);else{if(1===s){const s=t.coords.slice();s[0]-=512;const e=t.coords.slice();e[0]+=512,t.coords.push(...s,...e);const i=t.lengths[0];return void t.lengths.push(i,i)}this._wrapVertex(t.coords,0,2,s)}}_wrapVertex(t,s,e,i){const r=s*e,n=t[r];n<-P*(i-2)?t[r]=n+P*i:n>P*(i-1)&&(t[r]=n-P*i)}_readX(){const t=this._readGeometry();return null!=t?t.coords[0]:0}_readY(){const t=this._readGeometry();return null!=t?t.coords[1]:0}_readServerCentroid(){switch(this.geometryType){case"esriGeometryPolygon":{const t=s(this._current.projectedGeometry),e=new ht([],t);return nt(new ht,e,this.hasZ,this.hasM,this.geometryType,this._tile.transform)}case"esriGeometryPolyline":{const s=this._current.projectedGeometry,e=t(s.paths,this.hasZ),i=new ht([],e);return nt(new ht,i,this.hasZ,this.hasM,this.geometryType,this._tile.transform)}}return null}_readAttribute(t,s){const e=this._current.attributes[t];if(void 0!==e)return e;const i=t.toLowerCase();for(const t in this._current.attributes)if(t.toLowerCase()===i)return this._current.attributes[t]}_readAttributes(){return this._current.attributes}}const dt=50;function pt(t){if(!t)return null;const{xmin:s,ymin:e,xmax:r,ymax:n,spatialReference:h}=t;return new i({rings:[[[s,e],[s,n],[r,n],[r,e],[s,e]]],spatialReference:h})}class ft{static fromGraphic(t,s,e,i){return new ft(t.geometry,s,t.attributes,t.visible,t.uid,e,i)}constructor(t,s,e,i,n,h,o){this.geometry=t,this.symbol=s,this.attributes=e,this.visible=i,this.objectId=n,this.zOrder=h,this.displayId=o,this.bounds=r(),this.prevBounds=r(),this.size=[0,0,0,0]}get linearCIM(){return this.symbolResource?.symbolInfo.linearCIM}update(t,s,e){return(this.geometry!==t.geometry||this.attributes!==t.attributes||this.symbol!==s||this.zOrder!==e||this.visible!==t.visible)&&(this.prevBounds=this.bounds,this.bounds=r(),this.zOrder=e,this.geometry=t.geometry,this.attributes=t.attributes,this.symbol=s,this.visible=t.visible,this.symbolResource=null,this.projectedGeometry=null,!0)}async projectAndNormalize(t){let s=this.geometry;if(!s||!s.spatialReference||"mesh"===s.type)return;"extent"===s.type&&(s=pt(s)),await at(s.spatialReference,t);const e=ot(s);if(!e)return;const i=ct(e,s.spatialReference,t);i&&n(i),this.projectedGeometry=h(i)?pt(i):i}}class mt{constructor(t,s,e){this.added=t,this.updated=s,this.removed=e}hasAnyUpdate(){return!!(this.added.length||this.updated.length||this.removed.length)}}const wt=1e-5;function yt(t,s){return s.zOrder-t.zOrder}class gt{constructor(t,s,e,i,r){this._items=new Map,this._boundsDirty=!1,this._outSpatialReference=t,this._cimResourceManager=s,this._hittestDrawHelper=new E(s),this._tileInfoView=e,this._store=r;const n=e.getClosestInfoForScale(i);this._resolution=this._tileInfoView.getTileResolution(n.level)}items(){return this._items.values()}getItem(t){return this._items.get(t)}async update(t,s,e){const i=[],r=[],n=[],h=new Set,o=[];let a=0;for(const n of t.items){a++;const t=n.uid,c=this._items.get(t),u=s(n);if(h.add(t),c){c.update(n,u,a)&&(r.push(c),o.push(this._updateItem(c,e)));continue}const l=this._store.createDisplayIdForObjectId(t),d=ft.fromGraphic(n,u,a,l);o.push(this._updateItem(d,e)),this._items.set(d.objectId,d),i.push(d)}for(const[t,s]of this._items.entries())h.has(t)||(this._store.releaseDisplayIdForObjectId(t),this._items.delete(t),n.push(s));return await Promise.all(o),this._index=null,new mt(i,r,n)}updateLevel(t){this._resolution!==t&&(this._index=null,this._boundsDirty=!0,this._resolution=t)}hitTest(t,s,e,i,n){const h=o("esri-mobile"),c=o(h?"hittest-2d-mobile-tolerance":"hittest-2d-desktop-tolerance"),u=c+(h?0:o("hittest-2d-small-symbol-tolerance"));t=d(t,this._tileInfoView.spatialReference);const l=i*window.devicePixelRatio*u,p=r();p[0]=t-l,p[1]=s-l,p[2]=t+l,p[3]=s+l;const f=i*window.devicePixelRatio*c,m=r();m[0]=t-f,m[1]=s-f,m[2]=t+f,m[3]=s+f;const w=.5*i*(u+dt),y=this._searchIndex(t-w,s-w,t+w,s+w);if(!y||0===y.length)return[];const g=[],b=r(),I=r();for(const t of y){if(!t.visible)continue;const{projectedGeometry:s,symbolResource:e}=t;this._getSymbolBounds(b,e,s,I,n),I[3]=I[2]=I[1]=I[0]=0,a(b,p)&&g.push(t)}if(0===g.length)return[];const _=this._hittestDrawHelper,x=[];for(const t of g){const{projectedGeometry:s,symbolResource:e}=t;if(!e)continue;const{textInfo:r,symbolInfo:h}=e,o=h.cimSymbol;_.hitTest(m,o.symbol,s,r,n,i)&&x.push(t)}return x.sort(yt),x.map((t=>t.objectId))}queryItems(t){return 0===this._items.size?[]:this._searchForItems(t)}clear(){this._items.clear(),this._index=null}async _updateItem(t,s){await t.projectAndNormalize(this._outSpatialReference),await s(t);const{size:e}=t;e[0]=e[1]=e[2]=e[3]=0,this._getSymbolBounds(t.bounds,t.symbolResource,t.projectedGeometry,t.size,0)}_searchIndex(t,s,e,i){return this._boundsDirty&&(this._items.forEach((t=>this._getSymbolBounds(t.bounds,t.symbolResource,t.projectedGeometry,t.size,0))),this._boundsDirty=!1),this._index||(this._index=c(9,(t=>({minX:t.bounds[0],minY:t.bounds[1],maxX:t.bounds[2],maxY:t.bounds[3]}))),this._index.load(Array.from(this._items.values()))),this._index.search({minX:t,minY:s,maxX:e,maxY:i})}_searchForItems(t){const s=this._tileInfoView.spatialReference,e=t.bounds,i=p(s);if(i&&s.isWrappable){const[s,n]=i.valid,h=Math.abs(e[2]-n)<wt,o=Math.abs(e[0]-s)<wt;if((!h||!o)&&(h||o)){const i=t.resolution;let o;o=r(h?[s,e[1],s+i*dt,e[3]]:[n-i*dt,e[1],n,e[3]]);const a=this._searchIndex(e[0],e[1],e[2],e[3]),c=this._searchIndex(o[0],o[1],o[2],o[3]);return[...new Set([...a,...c])]}}return this._searchIndex(e[0],e[1],e[2],e[3])}_getSymbolBounds(t,s,e,i,n){if(!s||!s.symbolInfo.linearCIM||!e)return null;if(t||(t=r()),u(t,e),!i||0===i[0]&&0===i[1]&&0===i[2]&&0===i[3]){const{textInfo:t,symbolInfo:e}=s,r=e.cimSymbol;i||(i=[0,0,0,0]);const h=$.getSymbolInflateSize(i,r.symbol,this._cimResourceManager,n,t);i[0]=l(h[0]),i[1]=l(h[1]),i[2]=l(h[2]),i[3]=l(h[3])}const h=this._resolution,o=$.safeSize(i);return t[0]-=o*h,t[1]-=o*h,t[2]+=o*h,t[3]+=o*h,t}}class bt{static getOrCreate(t,s,e){let i=s.get(t.id);return i||(i=new bt(t,e),s.set(t.id,i)),i}static fromItems(t,s,e){const i=new bt(t,e);return i.addedOrModified.push(...s),i}constructor(t,s){this.tile=t,this.metadata=s,this.addedOrModified=[],this.removed=[]}get reader(){return this._reader||(this._reader=lt.from(this.addedOrModified,this.tile,this.metadata)),this._reader}}let It=class extends(f(m)){constructor(t){super(t),this._attached=!1,this._tiles=new Map,this._controller=new AbortController,this._hashToSymbolInfo=new Map,this._lastCleanup=performance.now(),this._cleanupRequired=!0,this.lastUpdateId=-1,this.renderer=null,this._updateTracking=new st({debugName:"GraphicsView2D"}),this.updateRequested=!1,this.defaultPointSymbolEnabled=!0,this._commandQueue=new J({process:t=>{switch(t.type){case"processed-edit":throw new Error("InternalError: Unsupported command");case"update":return this._update()}}}),this.graphicUpdateHandler=this.graphicUpdateHandler.bind(this)}destroy(){this.container.destroy(),this.view=null,this.renderer=null,this._set("graphics",null),this._controller.abort(),this._graphicStore.clear(),this._attributeStore=null,this._hashToSymbolInfo.clear(),this._updateTracking.destroy(),this._commandQueue.destroy()}_initAttributeStore(){this._storage=new F({spatialReference:this.view.spatialReference,fields:new w}),this._attributeStore=new z({isLocal:!0,update:async t=>{o("esri-2d-update-debug")&&console.debug(`[Id: ${this.layerId}] GraphicsView2D.AttributeStoreView.updateStart`,{message:t});const s=this.container.attributeView.requestUpdate(t);this.container.requestRender(),await s,o("esri-2d-update-debug")&&console.debug(`[Id: ${this.layerId}] GraphicsView2D.AttributeStoreView.updateEnd`,{message:t})}});const t=tt(null,[]);this._attributeStore.update(t,this._storage,null),this.container.checkHighlight=()=>this._attributeStore.hasHighlight}initialize(){this._initAttributeStore(),this._metadata=O.create(this.view.spatialReference),this._resourceProxy=new X({fetch:t=>Promise.all(t.map((t=>this.view.stage.textureManager.rasterizeItem(t)))),fetchDictionary:t=>{throw new Error("InternalError: Graphics do not support Dictionary requests")}}),this.addHandles([y((()=>this._effectiveRenderer),(()=>this._pushUpdate())),this.view.graphicsTileStore.on("update",this._onTileUpdate.bind(this)),this.container.on("attach",(()=>{this.addHandles([this.graphics.on("change",(()=>this._pushUpdate()))]),this._graphicStore=new gt(this.view.spatialReference,this._cimResourceManager,this.view.featuresTilingScheme,this.view.state.scale,this._attributeStore),this._attached=!0,this.requestUpdate(),this._pushUpdate()}))]),this._updateTracking.addUpdateTracking("CommandQueue",this._commandQueue.updateTracking);const t=this.view.graphicsTileStore.tiles;this._onTileUpdate({added:t,removed:[]})}get _effectiveRenderer(){return"function"==typeof this.renderer?this.renderer():this.renderer}get _cimResourceManager(){return this.view.stage.textureManager.resourceManager}get updating(){const t=!this._attached||this._updateTracking.updating;return o("esri-2d-log-updating")&&console.log(`Updating GraphicsView2D: ${t}\n  -> attaching ${!this._attached}\n  -> updateTracking ${this._updateTracking.updating}`),t}hitTest(t){if(!this.view||this.view.suspended)return[];const{resolution:s,rotation:e}=this.view.state,i=this._graphicStore.hitTest(t.x,t.y,2,s,e),r=new Set(i),n=this.graphics.items.reduce(((t,s)=>(r.has(s.uid)&&t.set(s.uid,s),t)),new Map);return i.map((t=>n.get(t))).filter(g)}requestUpdate(){this.updateRequested||(this.updateRequested=!0,this.requestUpdateCallback()),this.notifyChange("updating")}processUpdate(t){this.updateRequested&&(this.updateRequested=!1,this.update(t))}viewChange(){this.requestUpdate()}setHighlight(t){const s=[];for(const{objectId:e,highlightFlags:i}of t){const t=this._graphicStore.getItem(e)?.displayId;s.push({objectId:e,highlightFlags:i,displayId:t})}this._attributeStore.setHighlight(s,t),this._pushUpdate()}graphicUpdateHandler(t){this._pushUpdate()}update(t){this.updateRequested=!1,this._attached&&this._graphicStore.updateLevel(t.state.resolution)}_pushUpdate(){b(this._commandQueue.push({type:"update"}))}async _update(){try{o("esri-2d-update-debug")&&console.debug(`[Id: ${this.layerId}] GraphicsView._update start`);const t=await this._graphicStore.update(this.graphics,(t=>this._getSymbolForGraphic(t)),(t=>this._ensureSymbolResource(t)));if(!t.hasAnyUpdate())return void await this._attributeStore.sendUpdates();t.removed.length&&(this._cleanupRequired=!0),o("esri-2d-update-debug")&&console.debug(`[Id: ${this.layerId}] GraphicsView updateMessage`,t);const s=this._createTileMessages(t);await this._fetchResources(s),this._write(s);for(const s of t.added)this._setFilterState(s);for(const s of t.updated)this._setFilterState(s);o("esri-2d-update-debug")&&console.debug(`[Id: ${this.layerId}] GraphicsView sendUpdate`,t),await this._attributeStore.sendUpdates(),o("esri-2d-update-debug")&&console.debug(`[Id: ${this.layerId}] GraphicsView sendUpdate.await`,t)}catch(t){}this._cleanupSharedResources()}_createTileMessages(t){const s=new Map;for(const e of t.added){const t=this.view.graphicsTileStore.getIntersectingTiles(e.bounds);for(const i of t){bt.getOrCreate(i,s,this._metadata).addedOrModified.push(e)}}for(const e of t.updated){const t=this.view.graphicsTileStore.getIntersectingTiles(e.prevBounds),i=this.view.graphicsTileStore.getIntersectingTiles(e.bounds);for(const i of t){bt.getOrCreate(i,s,this._metadata).removed.push(e.displayId)}for(const t of i){bt.getOrCreate(t,s,this._metadata).addedOrModified.push(e)}}for(const e of t.removed){const t=this.view.graphicsTileStore.getIntersectingTiles(e.bounds);for(const i of t){bt.getOrCreate(i,s,this._metadata).removed.push(e.displayId)}}return Array.from(s.values())}async _fetchResources(t){for(const{tile:s,reader:e}of t){o("esri-2d-update-debug")&&console.debug(`Id[${this.layerId}] Tile[${s.id}] GraphicsView fetchResources`,t);const i=e.getCursor();for(;i.next();)for(const t of i.getMeshWriters())t.enqueueRequest(this._resourceProxy,i,s.createArcadeEvaluationOptions(this.view.timeZone))}await this._resourceProxy.fetchEnqueuedResources()}_write(t){for(const s of t){o("esri-2d-update-debug")&&console.debug(`Id[${this.layerId}] Tile[${s.tile.id}] GraphicsView write`,s);const t=this._writeMeshes(s);let e=this._tiles.get(s.tile.key);e||(e=this._createFeatureTile(s.tile.key)),o("esri-2d-update-debug")&&console.debug(`Id[${this.layerId}] Tile[${s.tile.id}] GraphicsView onTileData`,s),this.container.onTileData(e,{type:"update",modify:t,remove:s.removed,end:!1,attributeEpoch:this._attributeStore.epoch}),this.container.requestRender()}}_writeMeshes(t){const s=new L(t.tile.id),e=t.reader.getCursor();for(;e.next();){s.entityStart(e.getDisplayId(),e.getZOrder());for(const i of e.getMeshWriters())i.write(s,this._resourceProxy,e,t.tile.createArcadeEvaluationOptions(this.view.timeZone),t.tile.level);s.entityEnd()}return{...s.serialize().message,tileId:t.tile.id}}_setFilterState(t){const s=t.displayId,e=this._attributeStore.getHighlightFlags(t.objectId);this._attributeStore.setData(s,0,0,e|(t.visible?U:0))}_getSymbolForGraphic(t){return null!=t.symbol?t.symbol:null!=this._effectiveRenderer?this._effectiveRenderer.getSymbol(t):this._getNullSymbol(t)}async _ensureSymbolResource(t){if(!t.symbol)return;const s=await this._getSymbolInfo(t.symbol);if(!s)return;const e=s.linearCIM.filter((t=>"text"===t.type));if(e.length>0){const i=await this._getTextResources(t,e);t.symbolResource={symbolInfo:s,textInfo:i}}else t.symbolResource={symbolInfo:s}}_getSymbolInfo(t){const s=t.hash();return this._hashToSymbolInfo.has(s)||this._hashToSymbolInfo.set(s,this._createSymbolInfo(s,t).catch((t=>null))),this._hashToSymbolInfo.get(s)}async _createSymbolInfo(t,s){const e=await this._convertToCIMSymbol(s),i=await this._createLinearCIM(e);if("text"===s.type)for(const t of i)"text"===t.type&&(t.lineWidth=s.lineWidth);return{hash:t,cimSymbol:e,linearCIM:i,meshWriters:await this._createMeshWriters(e,i)}}async _convertToCIMSymbol(t){const s=A(t);if("web-style"===s.type){return(await s.fetchCIMSymbol()).data}return s}async _createLinearCIM(t){return await Promise.all(C.fetchResources(t.symbol,this._cimResourceManager,[])),this.view.stage.cimAnalyzer.analyzeSymbolReference(t,!1)}async _createMeshWriters(t,s){I(this._controller.signal);const e=this.container.instanceStore,i=await ut(t,s,e);return Promise.all(i.map((t=>Y(this._storage,this._resourceProxy,t.meshWriterName,et(t.id),t.options,{tileInfo:this.view.featuresTilingScheme.tileInfo},t.optionalAttributes))))}_onTileUpdate(t){if(t.added&&t.added.length>0)for(const s of t.added)this._updateTracking.addPromise(this._addTile(s));if(t.removed&&t.removed.length>0)for(const s of t.removed)this._removeTile(s.key)}_createFeatureTile(t){const s=this.view.featuresTilingScheme.getTileBounds(r(),t),e=this.view.featuresTilingScheme.getTileResolution(t.level),i=new k(t,e,s[0],s[3]);return this._tiles.set(t,i),this.container.addChild(i),i}async _addTile(t){if(!this._attached)return;const s=this._graphicStore.queryItems(t);if(!s.length)return;const e=this._createFeatureTile(t.key),i=bt.fromItems(t,s,this._metadata);await this._fetchResources([i]);const r=this._writeMeshes(i);e.onMessage({type:"append",append:r,clear:!1,end:!0,attributeEpoch:this._attributeStore.epoch})}_removeTile(t){if(!this._tiles.has(t))return;const s=this._tiles.get(t);this.container.removeChild(s),s.destroy(),this._tiles.delete(t)}_getNullSymbol(t){const s=t.geometry;return _(s)?x:S(s)||h(s)?v:this.defaultPointSymbolEnabled?G:null}async _getTextResources(t,s){const i=new Array,r=new Array;for(let n=0;n<s.length;n++){const h=s[n],{resource:o,overrides:a}=h.textRasterizationParam;if(a?.length>0){const s=M.resolveSymbolOverrides({type:"CIMSymbolReference",primitiveOverrides:a,symbol:{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,size:o.symbol.height,anchorPointUnits:"Relative",frame:{xmin:-5,ymin:-5,xmax:5,ymax:5},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:o.symbol,textString:o.textString}],scaleSymbolsProportionally:!0,respectFrame:!0}]}},t,this.view.spatialReference,null,e(t.projectedGeometry),null,null);s.then((t=>{const s=t.symbolLayers[0],{textString:e}=s.markerGraphics[0];r.push({type:"cim-rasterization-info",resource:{type:"text",textString:e||"",font:o.font}}),h.text=o.textString=e||""})),i.push(s)}else r.push({type:"cim-rasterization-info",resource:o})}i.length>0&&await Promise.all(i);const n=r.map((t=>this.view.stage.textureManager.rasterizeItem(t))),h=await Promise.all(n);T(h);const o=new Map;for(let t=0;t<s.length;t++){const e=s[t];o.set(e.textRasterizationParam.resource.symbol,{text:e.text,glyphMosaicItems:h[t]})}return o}_cleanupSharedResources(){if(!this._cleanupRequired)return;const t=performance.now();if(t-this._lastCleanup<5e3)return;this._cleanupRequired=!1,this._lastCleanup=t;const s=new Set;for(const t of this._graphicStore.items()){const e=t.symbolResource?.symbolInfo.hash;s.add(e)}const e=new Set(this._hashToSymbolInfo.keys());for(const t of e.values())s.has(t)||this._hashToSymbolInfo.delete(t)}};j([R()],It.prototype,"_effectiveRenderer",null),j([R({constructOnly:!0})],It.prototype,"layerId",void 0),j([R({constructOnly:!0})],It.prototype,"requestUpdateCallback",void 0),j([R()],It.prototype,"container",void 0),j([R({constructOnly:!0})],It.prototype,"graphics",void 0),j([R()],It.prototype,"renderer",void 0),j([R()],It.prototype,"_updateTracking",void 0),j([R()],It.prototype,"updating",null),j([R()],It.prototype,"view",void 0),j([R()],It.prototype,"updateRequested",void 0),j([R()],It.prototype,"defaultPointSymbolEnabled",void 0),It=j([V("esri.views.2d.layers.support.GraphicsView2D")],It);const _t=It;export{_t as $};
//# sourceMappingURL=p-eccdd480.js.map