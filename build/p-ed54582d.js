import{ap as n,ag as t,eo as o,lN as r,dv as e,b4 as s,lJ as i,ep as a,lL as c,lM as u,a2 as f,ar as l,m9 as p,m2 as d,nd as m,ne as b,aW as h,na as g,aX as M,n as P,ao as j,$ as v,lK as w}from"./p-aad64c9f.js";import{s as y,a as A}from"./p-175d4a9b.js";import{e as x}from"./p-88dd7081.js";import{v as N,A as C,M as S}from"./p-e974c449.js";import{M as _,D as k,h as B,P as O,O as R,c as V,U as E,b as L,x as U,q as W,w as q,z,H as D,y as F}from"./p-a040372a.js";const H=()=>P.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class J{constructor(){this.plane=_(),this.origin=v(),this.basis1=v(),this.basis2=v()}}const K=J;function T(t=Cn){return{plane:_(t.plane),origin:n(t.origin),basis1:n(t.basis1),basis2:n(t.basis2)}}function X(n,t,o){const r=Bn.get();return r.origin=n,r.basis1=t,r.basis2=o,r.plane=k(0,0,0,0),Q(r),r}function $(n,t=T()){return I(n.origin,n.basis1,n.basis2,t)}function G(n,o){t(o.origin,n.origin),t(o.basis1,n.basis1),t(o.basis2,n.basis2),B(o.plane,n.plane)}function I(n,o,r,e=T()){return t(e.origin,n),t(e.basis1,o),t(e.basis2,r),Q(e),xn(e,"fromValues()"),e}function Q(n){O(n.basis2,n.basis1,n.origin,n.plane)}function Y(n,t,e){n!==e&&$(n,e);const s=o(V.get(),jn(n),t);return r(e.origin,e.origin,s),e.plane[3]-=t,e}function Z(n,t,o){return tn(t,o),Y(o,bn(n,n.origin),o),o}function nn(n,t){const o=n.basis1[0],r=n.basis2[1],[e,i]=n.origin;return s(e-o,i-r,e+o,i+r,t)}function tn(n,t=T()){const o=(n[2]-n[0])/2,r=(n[3]-n[1])/2;return e(t.origin,n[0]+o,n[1]+r,0),e(t.basis1,o,0,0),e(t.basis2,0,r,0),E(0,0,1,0,t.plane),t}function on(n,t,o){return!!U(n.plane,t,o)&&wn(n,o)}function rn(n,t,e){if(on(n,t,e))return e;const s=en(n,t,V.get());return r(e,t.origin,o(V.get(),t.direction,i(t.origin,s)/a(t.direction))),e}function en(n,o,r){const e=Sn.get();Nn(n,o,e,Sn.get());let s=Number.POSITIVE_INFINITY;for(const i of On){const a=An(n,i,_n.get()),u=V.get();if(W(e,a,u)){const n=c(V.get(),o.origin,u),e=Math.abs(w(M(o.direction,n)));e<s&&(s=e,t(r,u))}}return s===Number.POSITIVE_INFINITY?an(n,o,r):r}function sn(n,t){return(t-n)/t}function an(n,o,r){if(on(n,o,r))return r;const e=Sn.get(),s=Sn.get();Nn(n,o,e,s);let i=Number.POSITIVE_INFINITY;for(const a of On){const c=An(n,a,_n.get()),u=V.get();if(q(e,c,u)){const n=A(o,u);if(!z(s,u))continue;n<i&&(i=n,t(r,u))}}return fn(n,o.origin)<i&&cn(n,o.origin,r),r}function cn(n,t,o){const e=D(n.plane,t,V.get()),s=C(yn(n,n.basis1),e,-1,1,V.get()),i=C(yn(n,n.basis2),e,-1,1,V.get());return u(o,r(V.get(),s,i),n.origin),o}function un(n,t,o){const{origin:r,basis1:s,basis2:i}=n,a=u(V.get(),t,r),c=L(s,a),f=L(i,a),l=L(jn(n),a);return e(o,c,f,l)}function fn(n,t){const o=un(n,t,V.get()),{basis1:r,basis2:e}=n,s=a(r),i=a(e),c=Math.max(Math.abs(o[0])-s,0),u=Math.max(Math.abs(o[1])-i,0),f=o[2];return c*c+u*u+f*f}function ln(n,t){return Math.sqrt(fn(n,t))}function pn(n,t){let o=Number.NEGATIVE_INFINITY;for(const r of On){const e=An(n,r,_n.get()),s=S(e,t);s>o&&(o=s)}return Math.sqrt(o)}function dn(n,t){return z(n.plane,t)&&wn(n,t)}function mn(n,t,o,r){return vn(n,o,r)}function bn(n,t){const o=-n.plane[3];return L(jn(n),t)-o}function hn(n,t,e,s){const i=bn(n,t),a=o(kn,jn(n),e-i);return r(s,t,a),s}function gn(n,t){return f(n.basis1,t.basis1)&&f(n.basis2,t.basis2)&&f(n.origin,t.origin)}function Mn(n,t,o){return n!==o&&$(n,o),l(Rn,t),p(Rn,Rn),d(o.basis1,n.basis1,Rn),d(o.basis2,n.basis2,Rn),d(R(o.plane),R(n.plane),Rn),d(o.origin,n.origin,t),F(o.plane,o.plane,o.origin),o}function Pn(n,t,o,r){return n!==r&&$(n,r),m(Vn,t,o),d(r.basis1,n.basis1,Vn),d(r.basis2,n.basis2,Vn),Q(r),r}function jn(n){return R(n.plane)}function vn(n,o,r){switch(o){case b.X:t(r,n.basis1),h(r,r);break;case b.Y:t(r,n.basis2),h(r,r);break;case b.Z:t(r,jn(n))}return r}function wn(n,t){const o=u(V.get(),t,n.origin),r=g(n.basis1),e=g(n.basis2),s=M(n.basis1,o),i=M(n.basis2,o);return-s-r<0&&s-r<0&&-i-e<0&&i-e<0}function yn(n,o){const r=_n.get();return t(r.origin,n.origin),t(r.vector,o),r}function An(n,t,e){const{basis1:s,basis2:i,origin:a}=n,c=o(V.get(),s,t.origin[0]),u=o(V.get(),i,t.origin[1]);r(e.origin,c,u),r(e.origin,e.origin,a);const f=o(V.get(),s,t.direction[0]),l=o(V.get(),i,t.direction[1]);return o(e.vector,r(f,f,l),2),e}function xn(n,t){Math.abs(M(n.basis1,n.basis2)/(a(n.basis1)*a(n.basis2)))>1e-6&&H().warn(t,"Provided basis vectors are not perpendicular"),Math.abs(M(n.basis1,jn(n)))>1e-6&&H().warn(t,"Basis vectors and plane normal are not perpendicular"),Math.abs(-M(jn(n),n.origin)-n.plane[3])>1e-6&&H().warn(t,"Plane offset is not consistent with plane origin")}function Nn(n,t,o,r){const e=jn(n);O(e,t.direction,t.origin,o),O(R(o),e,t.origin,r)}const Cn={plane:_(),origin:j(0,0,0),basis1:j(1,0,0),basis2:j(0,1,0)},Sn=new y(_),_n=new y(N),kn=v(),Bn=new y((()=>T())),On=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],Rn=x(),Vn=x(),En=Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:K,altitudeAt:bn,axisAt:mn,cameraFrustumCoverage:sn,closestPoint:an,closestPointOnSilhouette:en,copy:$,copyWithoutVerify:G,create:T,distance:ln,distance2:fn,distanceToSilhouette:pn,elevate:Y,equals:gn,extrusionContainsPoint:dn,fromAABoundingRect:tn,fromValues:I,getExtent:nn,intersectRay:on,intersectRayClosestSilhouette:rn,normal:jn,projectPoint:cn,projectPointLocal:un,rotate:Pn,setAltitudeAt:hn,setExtent:Z,transform:Mn,up:Cn,updateUnboundedPlane:Q,wrap:X},Symbol.toStringTag,{value:"Module"}));export{I as J,Q as K,T as W,$ as Z,En as k};
//# sourceMappingURL=p-ed54582d.js.map