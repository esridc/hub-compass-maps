import{i8 as n,ik as t,il as r,M as e,hF as o,im as a,io as s,an as i,ao as u,ap as l,dG as c,a0 as f,ip as p,az as m,iq as g,ir as h,is as y,it as v,iu as w,dw as A,s as F,iv as b,iw as x,ix as d,iy as j,iz as P,gw as C,gv as M,iA as S,ie as N,iB as T,iC as _,iD as I,iE as O,iF as R,cp as G,iG as z,iH as B,de as k,iI as q}from"./p-3013819f.js";import{e as E}from"./p-10315be7.js";import{e as L,o as U}from"./p-5f148c96.js";import{a as $,R as D}from"./p-71ed4ac4.js";import{t as H,o as J}from"./p-a276ccf5.js";import{I as K,x as Q,v as V}from"./p-9b885976.js";import{e as W}from"./p-897991e6.js";import{g as X,f as Y,u as Z}from"./p-5bd0bced.js";import{n as nn,s as tn,r as rn,i as en}from"./p-53be785a.js";import{i as on,T as an}from"./p-7020cf1b.js";function sn(n=yn){return[n[0],n[1],n[2],n[3]]}function un(t,r,e=sn()){return n(pn(e),t),e[3]=r,e}function ln(n,t=sn()){const r=s(vn,n);return hn(t,o(V(t,r))),t}function cn(n,t,r=sn()){return K(vn,pn(n),gn(n)),K(wn,pn(t),gn(t)),Q(vn,wn,vn),hn(r,o(V(pn(r),vn)))}function fn(n,e,o,s=sn()){return un(a,n,An),un(t,e,Fn),un(r,o,bn),cn(An,Fn,An),cn(An,bn,s),s}function pn(n){return n}function mn(n){return n[3]}function gn(n){return e(n[3])}function hn(n,t){return n[3]=t,n}const yn=[0,0,1,0],vn=W(),wn=W(),An=sn(),Fn=sn(),bn=sn();var xn;let dn=xn=class extends c{constructor(n){super(n),this.translation=f(),this.rotationAxis=p(yn),this.rotationAngle=0,this.scale=m(1,1,1)}get rotation(){return un(this.rotationAxis,this.rotationAngle)}set rotation(n){this.rotationAxis=g(pn(n)),this.rotationAngle=mn(n)}get localMatrix(){const n=L();return K(jn,pn(this.rotation),gn(this.rotation)),h(n,jn,this.translation,this.scale),n}get localMatrixInverse(){return y(L(),this.localMatrix)}applyLocal(n,t){return v(t,n,this.localMatrix)}applyLocalInverse(n,t){return v(t,n,this.localMatrixInverse)}equals(n){return this===n||null!=n&&w(this.localMatrix,n.localMatrix)}clone(){const n={translation:g(this.translation),rotationAxis:g(this.rotationAxis),rotationAngle:this.rotationAngle,scale:g(this.scale)};return new xn(n)}};i([u({type:[Number],nonNullable:!0,json:{write:!0}})],dn.prototype,"translation",void 0),i([u({type:[Number],nonNullable:!0,json:{write:!0}})],dn.prototype,"rotationAxis",void 0),i([u({type:Number,nonNullable:!0,json:{write:!0}})],dn.prototype,"rotationAngle",void 0),i([u({type:[Number],nonNullable:!0,json:{write:!0}})],dn.prototype,"scale",void 0),i([u()],dn.prototype,"rotation",null),i([u()],dn.prototype,"localMatrix",null),i([u()],dn.prototype,"localMatrixInverse",null),dn=xn=i([l("esri.geometry.support.MeshTransform")],dn);const jn=W(),Pn=dn;function Cn(n,t){return n.isGeographic||n.isWebMercator&&(t??!0)}function Mn(n,t){switch(n.type){case"georeferenced":return t.isGeographic;case"local":return t.isGeographic||t.isWebMercator}}function Sn(n,t,r,e){if(void 0!==e){A(F.getLogger(n),"option: geographic",{replacement:"use mesh vertexSpace and spatial reference to control how operations are performed",version:"4.29",warnOnce:!0});const o="local"===t.type;if(!X(t)||e===o){return r.isGeographic||r.isWebMercator&&e}F.getLogger(n).warnOnce(`Specifying the 'geographic' parameter (${e}) for a Mesh vertex space of type "${t.type}" is not supported. This parameter will be ignored.`)}return Mn(t,r)}const Nn=()=>F.getLogger("esri.geometry.support.meshUtils.normalProjection");function Tn(n,t,r,e,o){return qn(e)?(kn(Un.TO_PCPF,on.fromTypedArray(n),an.fromTypedArray(t),an.fromTypedArray(r),e,on.fromTypedArray(o)),o):(Nn().error("Cannot convert spatial reference to PCPF"),o)}function _n(n,t,r,e,o){return qn(e)?(kn(Un.FROM_PCPF,on.fromTypedArray(n),an.fromTypedArray(t),an.fromTypedArray(r),e,on.fromTypedArray(o)),o):(Nn().error("Cannot convert to spatial reference from PCPF"),o)}function In(n,t,r){return b(n,t,0,r,$(t),0,n.length/3),r}function On(n,t,r){return b(n,$(r),0,t,r,0,n.length/3),t}function Rn(n,t,r){return T(Jn,r),nn(t,n,Jn),_(Jn)||tn(t,t),t}function Gn(n,t,r){if(T(Jn,r),nn(t,n,Jn,4),_(Jn)||tn(t,t,4),n!==t)for(let r=3;r<n.length;r+=4)t[r]=n[r];return t}function zn(n,t,r,e,o){if(!qn(e))return Nn().error("Cannot convert spatial reference to PCPF"),o;kn(Un.TO_PCPF,on.fromTypedArray(n,4*Float32Array.BYTES_PER_ELEMENT),an.fromTypedArray(t),an.fromTypedArray(r),e,on.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT));for(let t=3;t<n.length;t+=4)o[t]=n[t];return o}function Bn(n,t,r,e,o){if(!qn(e))return Nn().error("Cannot convert to spatial reference from PCPF"),o;kn(Un.FROM_PCPF,on.fromTypedArray(n,16),an.fromTypedArray(t),an.fromTypedArray(r),e,on.fromTypedArray(o,16));for(let t=3;t<n.length;t+=4)o[t]=n[t];return o}function kn(n,t,r,e,o,a){if(!t)return;const s=r.count,i=$(o);if(En(o))for(let r=0;r<s;r++)e.getVec(r,$n),t.getVec(r,Dn),D(i,$n,Hn,i),P(Jn,Hn),n===Un.FROM_PCPF&&C(Jn,Jn),M(Dn,Dn,Jn),a.setVec(r,Dn);else for(let o=0;o<s;o++){e.getVec(o,$n),t.getVec(o,Dn),D(i,$n,Hn,i),P(Jn,Hn);const s=S(r.get(o,1));let u=Math.cos(s);n===Un.TO_PCPF&&(u=1/u),Jn[0]*=u,Jn[1]*=u,Jn[2]*=u,Jn[3]*=u,Jn[4]*=u,Jn[5]*=u,n===Un.FROM_PCPF&&C(Jn,Jn),M(Dn,Dn,Jn),N(Dn,Dn),a.setVec(o,Dn)}return a}function qn(n){return En(n)||Ln(n)}function En(n){return n.isWGS84||x(n)||d(n)||j(n)}function Ln(n){return n.isWebMercator}var Un;!function(n){n[n.TO_PCPF=0]="TO_PCPF",n[n.FROM_PCPF=1]="FROM_PCPF"}(Un||(Un={}));const $n=f(),Dn=f(),Hn=L(),Jn=E();function Kn(n,t,r){return Cn(t.spatialReference,r?.geographic)?tt(n,t,!1,r):nt(n,t,r)}function Qn(n,t=o){const{position:r,normal:e,tangent:o}=n;return{position:rn(new Float64Array(r.length),r,t),normal:null!=e?Rn(e,new Float32Array(e.length),t):null,tangent:null!=o?Gn(o,new Float32Array(o.length),t):null}}function Vn(n,t,r,e){const{position:o,normal:a,tangent:s}=n;if(!X(t))return{position:o,normal:a,tangent:s};const i=Z(t,e);return Kn(Qn(n,r?.localMatrix),i,{geographic:"local"===t.type})}function Wn(n,t,r){const e=Y(t,r),o=t.spatialReference,a=X(e);if(!a)return{vertexAttributes:Kn(n,t,r),vertexSpace:e,transform:null};const{position:s,normal:i,tangent:u}=n,l=Mn(e,o);switch(e.type){case"georeferenced":return l?{vertexAttributes:tt(n,t,a,r),vertexSpace:e,transform:null}:{vertexAttributes:{position:s,normal:i,tangent:u},vertexSpace:e,transform:new Pn};case"local":return{vertexAttributes:{position:s,normal:i,tangent:u},vertexSpace:e,transform:new Pn}}}function Xn(n,t,r){return Cn(t.spatialReference,r?.geographic)?st(n,t,r):at(n,t,r)}function Yn(n,t,r,e,o){if(!X(t))return Xn(n,e,o);const{spatialReference:a}=e,s=Vn(n,t,r,a);return e.equals(Z(t,a))?at(s,e,o):Xn(s,e,o)}function Zn({positions:n,transform:t,vertexSpace:r,inSpatialReference:e,outSpatialReference:o,outPositions:a,localMode:s}){const i=r.origin??R,u=null!=r.origin?t?.localMatrix??U:U;if("georeferenced"===r.type){const t=a??H(n.length);if(I(u,U)?J(t,n):rn(t,n,u),!O(i,R)){const[n,r,e]=i;for(let o=0;o<t.length;o+=3)t[o]+=n,t[o+1]+=r,t[o+2]+=e}return b(t,e,0,t,o,0,t.length/3),t}let l=e;const c=$(e);l=o.isWebMercator&&s||!G(e,c)?l:c,D(e,i,pt,l),z(pt,pt,u);const f=a??H(n.length);return rn(f,n,pt),b(f,l,0,f,o,0,f.length/3),f}function nt(n,t,r){const e=new Float64Array(n.position.length),o=n.position,a=t.x,s=t.y,i=t.z??0,u=ft(r?r.unit:null,t.spatialReference);for(let n=0;n<o.length;n+=3)e[n]=o[n]*u+a,e[n+1]=o[n+1]*u+s,e[n+2]=o[n+2]*u+i;return{position:e,normal:n.normal,tangent:n.tangent}}function tt(n,t,r,e){const o=t.spatialReference,a=it(t,e,pt),s=new Float64Array(n.position.length),i=rt(n.position,a,o,s),u=T(gt,a),l=et(i,s,n.normal,u,o),c=ot(i,s,n.tangent,u,o);if(r){const{x:n,y:r,z:e}=t;en(i,i,[-n,-r,-(e??0)])}return{position:i,normal:l,tangent:c}}function rt(n,t,r,e){rn(e,n,t);const o=new Float64Array(n.length);return On(e,o,r)}function et(n,t,r,e,o){if(null==r)return null;const a=new Float32Array(r.length);return nn(a,r,e),_n(a,n,t,o,a),a}function ot(n,t,r,e,o){if(null==r)return null;const a=new Float32Array(r.length);nn(a,r,e,4);for(let n=3;n<a.length;n+=4)a[n]=r[n];return Bn(a,n,t,o,a),a}function at(n,t,r){const e=new Float64Array(n.position.length),o=n.position,a=t.x,s=t.y,i=t.z??0,u=ft(r?r.unit:null,t.spatialReference);for(let n=0;n<o.length;n+=3)e[n]=(o[n]-a)/u,e[n+1]=(o[n+1]-s)/u,e[n+2]=(o[n+2]-i)/u;return{position:e,normal:n.normal,tangent:n.tangent}}function st(n,t,r){const e=t.spatialReference;it(t,r,pt);const o=y(mt,pt),a=new Float64Array(n.position.length),s=ut(n.position,e,o,a),i=T(gt,o);return{position:s,normal:lt(n.normal,n.position,a,e,i),tangent:ct(n.tangent,n.position,a,e,i)}}function it(n,t,r){D(n.spatialReference,[n.x,n.y,n.z??0],r,$(n.spatialReference));const e=ft(t?t.unit:null,n.spatialReference);return B(r,r,[e,e,e]),r}function ut(n,t,r,e){const o=In(n,t,e),a=new Float64Array(o.length);return rn(a,o,r),a}function lt(n,t,r,e,o){if(null==n)return null;const a=Tn(n,t,r,e,new Float32Array(n.length));return nn(a,a,o),a}function ct(n,t,r,e,o){if(null==n)return null;const a=zn(n,t,r,e,new Float32Array(n.length));return nn(a,a,o,4),a}function ft(n,t){if(null==n)return 1;const r=k(t);return 1/q(r,"meters",n)}const pt=L(),mt=L(),gt=E();const ht=Object.freeze({__proto__:null,applyTransform:Qn,georeference:Kn,georeferenceApplyTransform:Vn,georeferenceByTransform:Wn,georeferenceGlobal:tt,getUnitScale:ft,project:Zn,ungeoreference:Xn,ungeoreferenceByTransform:Yn,ungeoreferenceGlobal:st});export{gn as A,Yn as C,On as E,Zn as G,tt as I,In as O,Vn as P,st as Q,Wn as V,ft as _,_n as a,Bn as b,Sn as c,Pn as d,sn as e,Qn as f,ht as g,zn as h,Tn as j,ln as k,fn as w,pn as y};
//# sourceMappingURL=p-5dea0c0d.js.map