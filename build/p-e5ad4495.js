import{hy as t,g as i,gR as e,hz as s,a,U as n,gY as r,an as l,ao as h,ap as o,am as c,gP as u,ah as f,ai as m,S as p,V as w,X as v,hA as d,hB as b,gk as g,cH as y,hl as $}from"./p-3013819f.js";import{E as O}from"./p-bc7fdef1.js";function A(i,e=!1){return i<=t?e?new Array(i).fill(0):new Array(i):new Uint32Array(i)}class D{constructor(t){this._validateJSON(t);const{location:s,data:a}=t;this.location=Object.freeze(i(s));const n=this.location.width,r=this.location.height;let l=!0,h=!0;const o=Math.ceil(n*r/32),c=A(o);let u=0;for(let t=0;t<a.length;t++){const i=t%32;a[t]?(h=!1,c[u]|=1<<i):l=!1,31===i&&++u}h?(this._availability="unavailable",this.byteSize=40):l?(this._availability="available",this.byteSize=40):(this._availability=c,this.byteSize=40+e(c))}getAvailability(t,i){if("unavailable"===this._availability||"available"===this._availability)return this._availability;const e=(t-this.location.top)*this.location.width+(i-this.location.left),s=e%32,a=e>>5,n=this._availability;return a<0||a>n.length?"unknown":n[a]&1<<s?"available":"unavailable"}static fromDefinition(t,i){const e=t.service.request||n,{row:r,col:l,width:h,height:o}=t,c={query:{f:"json"}};return i=i?{...c,...i}:c,e(P(t),i).then((t=>t.data)).catch((t=>{if(t&&t.details&&422===t.details.httpStatus)return{location:{top:r,left:l,width:h,height:o},valid:!0,data:s(h*o,0)};throw t})).then((t=>{if(t.location&&(t.location.top!==r||t.location.left!==l||t.location.width!==h||t.location.height!==o))throw new a("tilemap:location-mismatch","Tilemap response for different location than requested",{response:t,definition:{top:r,left:l,width:h,height:o}});return D.fromJSON(t)}))}static fromJSON(t){return Object.freeze(new D(t))}_validateJSON(t){if(!t?.location)throw new a("tilemap:missing-location","Location missing from tilemap response");if(!1===t.valid)throw new a("tilemap:invalid","Tilemap response was marked as invalid");if(!t.data)throw new a("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(t.data))throw new a("tilemap:data-mismatch","Data must be an array of numbers");if(t.data.length!==t.location.width*t.location.height)throw new a("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}}function T(t){return`${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`}function P(t){let i;if(t.service.tileServers?.length){const e=t.service.tileServers;i=`${e&&e.length?e[t.row%e.length]:t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`}else i=`${t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`;const e=t.service.query;return e&&(i=`${i}?${e}`),i}var k;let L=k=class extends c{constructor(t){super(t),this._pendingTilemapRequests={},this.request=n,this.size=32,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new u(2*O.MEGABYTES),this.addHandles(f((()=>{const{layer:t}=this;return[t?.parsedUrl,t?.tileServers,t?.apiKey,t?.customParameters]}),(()=>this._initializeTilemapDefinition()),m))}get effectiveMinLOD(){return this.minLOD??this.layer.tileInfo.lods[0].level}get effectiveMaxLOD(){return this.maxLOD??this.layer.tileInfo.lods[this.layer.tileInfo.lods.length-1].level}fetchTilemap(t,i,e,s){if(!this.layer.tileInfo.lodAt(t)||t<this.effectiveMinLOD||t>this.effectiveMaxLOD)return Promise.reject(new a("tilemap-cache:level-unavailable",`Level ${t} is unavailable in the service`));const n=this._tmpTilemapDefinition,r=this._tilemapFromCache(t,i,e,n);if(r)return Promise.resolve(r);const l=s?.signal;return s={...s,signal:null},new Promise(((t,i)=>{p(l,(()=>i(w())));const e=T(n);let a=this._pendingTilemapRequests[e];if(!a){a=D.fromDefinition(n,s).then((t=>(this._tilemapCache.put(e,t,t.byteSize),t)));const t=()=>{delete this._pendingTilemapRequests[e]};this._pendingTilemapRequests[e]=a,a.then(t,t)}a.then(t,i)}))}getAvailability(t,i,e){if(!this.layer.tileInfo.lodAt(t)||t<this.effectiveMinLOD||t>this.effectiveMaxLOD)return"unavailable";const s=this._tilemapFromCache(t,i,e,this._tmpTilemapDefinition);return s?s.getAvailability(i,e):"unknown"}fetchAvailability(t,i,e,s){return!this.layer.tileInfo.lodAt(t)||t<this.effectiveMinLOD||t>this.effectiveMaxLOD?Promise.reject(new a("tile-map:tile-unavailable","Tile is not available",{level:t,row:i,col:e})):this.fetchTilemap(t,i,e,s).catch((t=>t)).then((s=>{if(s instanceof D){const n=s.getAvailability(i,e);if("unavailable"===n)throw new a("tile-map:tile-unavailable","Tile is not available",{level:t,row:i,col:e});return n}if(v(s))throw s;return"unknown"}))}fetchAvailabilityUpsample(t,i,e,s,a){s.level=t,s.row=i,s.col=e;const n=this.layer.tileInfo;n.updateTileInfo(s);const r=this.fetchAvailability(t,i,e,a).catch((t=>{if(v(t))throw t;if(n.upsampleTile(s))return this.fetchAvailabilityUpsample(s.level,s.row,s.col,s,a);throw t}));return this._fetchAvailabilityUpsamplePrefetch(s.id,t,i,e,a,r),r}async _fetchAvailabilityUpsamplePrefetch(t,i,e,s,a,n){if(!this._prefetchingEnabled||null==t)return;const r=`prefetch-${t}`;if(this.hasHandles(r))return;const l=new AbortController;n.then((()=>l.abort()),(()=>l.abort()));let h=!1;const o=y((()=>{h||(h=!0,l.abort())}));if(this.addHandles(o,r),await d(10,l.signal).catch((()=>{})),h||(h=!0,this.removeHandles(r)),b(l))return;const c=new $(t,i,e,s),u={...a,signal:l.signal},f=this.layer.tileInfo;for(let t=0;k._prefetches.length<k._maxPrefetch&&f.upsampleTile(c);++t){const t=this.fetchAvailability(c.level,c.row,c.col,u);k._prefetches.push(t);const i=()=>{k._prefetches.removeUnordered(t)};t.then(i,i)}}_initializeTilemapDefinition(){if(!this.layer.parsedUrl)return;const{parsedUrl:t,apiKey:i,customParameters:e}=this.layer;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:t.path,query:g({...t.query,...e,token:i??t.query?.token}),tileServers:this.layer.tileServers,request:this.request},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(t,i,e,s){s.level=t,s.row=i-i%this.size,s.col=e-e%this.size;const a=T(s);return this._tilemapCache.get(a)}get test(){const t=this;return{get prefetchingEnabled(){return t._prefetchingEnabled},set prefetchingEnabled(i){t._prefetchingEnabled=i},hasTilemap:(i,e,s)=>!!t._tilemapFromCache(i,e,s,t._tmpTilemapDefinition)}}};L._maxPrefetch=4,L._prefetches=new r({initialSize:k._maxPrefetch}),l([h({constructOnly:!0})],L.prototype,"layer",void 0),l([h({constructOnly:!0})],L.prototype,"minLOD",void 0),l([h({constructOnly:!0})],L.prototype,"maxLOD",void 0),l([h({constructOnly:!0})],L.prototype,"request",void 0),l([h({constructOnly:!0})],L.prototype,"size",void 0),L=k=l([o("esri.layers.support.TilemapCache")],L);export{L as T};
//# sourceMappingURL=p-e5ad4495.js.map